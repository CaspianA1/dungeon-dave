	const int res = 1024;
	const float units_per_texel = 2.0f * glm_aabb_radius(camera_)
	camera_sub_frustum_center[0] = floorf(camera_sub_frustum_center[0] / units_per_texel;
	camera_sub_frustum_center[1] = floorf(camera_sub_frustum_center[1] / units_per_texel;
	camera_sub_frustum_center[2] = floorf(camera_sub_frustum_center[2] / units_per_texel;

_____

	// return float(UV.z - 0.0005f < texture(shadow_cascade_sampler, vec3(UV.xy, layer)).r);

	/*
	float bias = 0.0002f / (layer + 1);
	return texture(shadow_cascade_sampler, vec4(UV.xy, layer, UV.z - bias));
	*/

_____

	// const float esm_constant = 80.0f;

	/*
	const float esm_constants[NUM_CASCADES] = float[NUM_CASCADES](
		// 100.0f, 200.0f, 80.0f, 80.0f, 80.0f, 80.0f, 8.0f, 8.0f
		80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f
	);
	*/

_____

	/*
	const float esm_constants[NUM_CASCADES] = float[NUM_CASCADES](
		// 100.0f, 200.0f, 80.0f, 80.0f, 80.0f, 80.0f, 8.0f, 8.0f
		80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f, 80.0f
	);

_____

	float shadow = csm_shadow(world_depth_value, fragment_pos_world_space);
	// texture_color = layer_color;

_____

		camera_sub_frustum_center[0] = floorf(camera_sub_frustum_center[0]);
		camera_sub_frustum_center[1] = floorf(camera_sub_frustum_center[1]);
		camera_sub_frustum_center[2] = floorf(camera_sub_frustum_center[2]);
		camera_sub_frustum_center[3] = floorf(camera_sub_frustum_center[3]);

_____ Non-working texel snapping:

static void texel_snapping(const GLsizei resolution, const mat4 view_projection, const vec4 center, vec4 final_center) {
	const GLfloat texel_scale = 2.0f / resolution;
	const GLfloat inv_texel_scale = 1.0f / texel_scale;

	vec4 projected_center;
	glm_mat4_mulv((vec4*) view_projection, (vec4) {center[0], center[1], center[2], 1.0f}, projected_center);

	/////////

	const GLfloat w = projected_center[3];

	const GLfloat x = floorf((projected_center[0] / w) * inv_texel_scale) * texel_scale;
	const GLfloat y = floorf((projected_center[1] / w) * inv_texel_scale) * texel_scale;
	const GLfloat z = projected_center[2] / w;

	//////////

	mat4 inv_view_projection;
	glm_mat4_inv((vec4*) view_projection, inv_view_projection);

	vec4 corrected_center;
	glm_mat4_mulv(inv_view_projection, (vec4) {x, y, z, 1.0f}, corrected_center);

	glm_vec4_scale(corrected_center, 1.0f / corrected_center[3], final_center);

	DEBUG_VEC3(final_center);

	/*
	texel scale = 2 / resolution // TODO: possibly make this a 2D vector at some point
	inv texel scale = 1 / texel scale // TODO: remove this division in some way

	// is center the center of the sub frustum in camera space? probably
	// and it may actually be the case that light_view_projection is camera_sub_frustum_view_projection

	projected center = XMVector4Transform(vec4(center, 1.0f), light_view_projection) // TODO: use glm_mat4_mulv3

	w = projected center.w

	x = floor((projected_center.x / w) * inv texel scale) * texel_scale
	y = floor((projected_center.y / w) * inv texel scale) * texel scale

	z = projected_center.z / w

	corrected_center = XMVector4Transform(
		vec4(x, y, z, 1.0f),
		mat4_inverse(light_view_projection)
	)

	final_center = vec3_scale(corrected center, 1.0f / corrected_center.w);
	*/
}

	/*
	const GLfloat texel_scale = 2.0f / resolution;
	const GLfloat inv_texel_scale = 1.0f / texel_scale;

	vec4 projected_center;
	glm_mat4_mulv((vec4*) view_projection, (vec4) {center[0], center[1], center[2], 1.0f}, projected_center);

	/////////

	const GLfloat w = projected_center[3];

	const GLfloat x = floorf((projected_center[0] / w) * inv_texel_scale) * texel_scale;
	const GLfloat y = floorf((projected_center[1] / w) * inv_texel_scale) * texel_scale;
	const GLfloat z = projected_center[2] / w;

	//////////

	mat4 inv_view_projection;
	glm_mat4_inv((vec4*) view_projection, inv_view_projection);

	vec4 corrected_center;
	glm_mat4_mulv(inv_view_projection, (vec4) {x, y, z, 1.0f}, corrected_center);

	glm_vec4_scale(corrected_center, 1.0f / corrected_center[3], final_center);

	DEBUG_VEC3(final_center);
	*/

	/*
	texel scale = 2 / resolution // TODO: possibly make this a 2D vector at some point
	inv texel scale = 1 / texel scale // TODO: remove this division in some way

	// is center the center of the sub frustum in camera space? probably
	// and it may actually be the case that light_view_projection is camera_sub_frustum_view_projection

	projected center = XMVector4Transform(vec4(center, 1.0f), light_view_projection) // TODO: use glm_mat4_mulv3

	w = projected center.w

	x = floor((projected_center.x / w) * inv texel scale) * texel_scale
	y = floor((projected_center.y / w) * inv texel scale) * texel scale

	z = projected_center.z / w

	corrected_center = XMVector4Transform(
		vec4(x, y, z, 1.0f),
		mat4_inverse(light_view_projection)
	)

	final_center = vec3_scale(corrected center, 1.0f / corrected_center.w);
	*/

_____

	// glm_vec2_copy((GLfloat*) light_view_projection[3], shadow_origin);

_____

	glm_vec2_copy((GLfloat*) light_view_projection[3], shadow_origin);
	glm_vec2_scale(shadow_origin, resolution / 2.0f, shadow_origin);

_____

	if (keys[SDL_SCANCODE_G]) {
		puts("Texel snapping");
		apply_texel_snapping(light_projection, light_view_projection);
		glm_mul(light_projection, light_view, light_view_projection);
	}
	else puts("No texel snapping");

_____ From https://dev.theomader.com/stable-csm/ (didn't work):

	const GLsizei size = 1024;

	const GLfloat min_x = light_view_frustum_box[0][0], min_y = light_view_frustum_box[0][1];

	const GLfloat quant_step = 1.0f / size;

	const GLfloat qx = remainderf(min_x, quant_step);
	const GLfloat qy = remainderf(min_y, quant_step);

	light_view_frustum_box[0][0] -= qx;
	light_view_frustum_box[0][1] -= qy;

	light_view_frustum_box[1][0] += size;
	light_view_frustum_box[1][1] += size;

	glm_ortho_aabb(light_view_frustum_box, light_projection);
	glm_mul(light_projection, light_view, light_view_projection);

_____

	DEBUG_VEC4(light_projection[3]);
	DEBUG_VEC4(light_view[3]);
	DEBUG_VEC4(light_view_projection[3]);
	puts("---");

_____

	// only need [3][0] and [3][1] for the math

	#define PRMAT(m) do {\
		puts(#m " = ");\
		for (int y = 0; y < 4; y++) {\
			for (int x = 0; x < 4; x++) {\
				printf("%lf ", (double) m[y][x]);\
			}\
			puts("");\
		}\
		puts("---");\
	} while (0)

	PRMAT(light_projection);
	PRMAT(light_view);
	DEBUG_VEC4(light_view_projection[3]);
	puts("----------");

_____

	// int layer_before = (layer - 1) * int(layer == 0); // If the last layer is 0, yields 0

_____

	// How the hell

	float lin_pct = world_depth_value / far_clip_dist;
	float log_pct = log2(world_depth_value);

	// Try with a smaller world
	return log_pct * NUM_CASCADES;

	/*
	float lin = world_depth_value;
	float lin_pct = near_clip_dist + lin / clip_dist_diff;
	float lg = near_clip_dist * pow(far_clip_dist / near_clip_dist, lin_pct);
	float lg_pct = lg / far_clip_dist;

	layer = int(mix(lg_pct, lin_pct, linear_split_weight) * NUM_CASCADES);
	*/

_____

	const GLfloat a = 125.0f, b = 5.0f;
	const GLfloat c = logf(a) / logf(b);
	DEBUG_FLOAT(c);

_____

GLfloat get_layer(const GLfloat world_depth_value, const GLfloat far_clip_dist, const GLsizei num_layers) {
	/*
	linear:
		linear_dist = near + ((i + 1) / num_layers) * (far - near))
		linear_dist - near = ((i + 1) / num_layers * (far - near))
		(linear_dist - near) / (far - near) = (i + 1) / num_layers
		(linear_dist - near) / (far - near) * num_layers = i + 1
		(linear_dist - near) / (far - near) * num_layers - 1 = i
	
	// how to get linear dist from the start then?
	
	logarithmic:
		log_dist = near * ((far / near) ^ ((i + 1) / num_layers))
		log_dist / near = (far / near) ^ ((i + 1) / num_layers)

		a = b ^ c
		goal: extract c
		c = log(a) / log(b)

		so, log(log_dist / near) / log(far / near) = ((i + 1) / num_layers)
		log(log_dist / near) / log(far / near) * num_layers = i + 1
		log(log_dist / near) / log(far / near) * num_layers - 1 = i
	
	_____
	in fragment shader, I have access to the world depth value, near clip dist, the far clip dist,
	and the number of layers. The world depth value is essentially the linear dist.

	I can get the linear layer without too much difficulty.
	But I will need to think more about how to get the logarithmic dist, since i and the logarithmic dist are both unknown.
	Perhaps I can use the i value gotten from the linear layer calculation?
	And am I really looking for i with the log dist calculation, since i will be the same?
	Try the equation first.
	*/

	const GLfloat near_clip_dist = constants.camera.near_clip_dist;
	const GLfloat linear_layer = (world_depth_value - near_clip_dist) / (far_clip_dist - near_clip_dist) * num_layers - 1.0f;

	const GLfloat log_layer = (logf(world_depth_value / near_clip_dist) / logf(far_clip_dist / near_clip_dist) * num_layers);
	DEBUG_FLOAT(log_layer);

	return linear_layer;
}

_____

	const vec3
		red = vec3(1.0f, 0.0f, 0.0f), green = vec3(0.0f, 1.0f, 0.0f), blue = vec3(0.0f, 0.0f, 1.0f),
		yellow = vec3(1.0f, 1.0f, 0.0f), teal = vec3(0.0f, 1.0f, 1.0f), orange = vec3(1.0f, 0.27f, 0.0f),
		pink = vec3(1.0f, 0.03f, 0.5f), gray = vec3(0.86f, 0.86f, 0.86f);

	const vec3 colors[NUM_CASCADES] = vec3[NUM_CASCADES](red, green, blue, yellow, teal, orange, pink, gray);

	layer_color = colors[layer];

	// TODO: a `blend_between_layers` function

	//////////

	// The constant-time solution would make things so much easier. First find a hacky way to figure out the last layer though.

	/*
	if (layer != 0) {
		if (layer == num_splits_between_cascades) {
			layer_color = vec3(0.0f, 0.0f, 0.0f);
		}
		else {
			int layer_before = layer - 1;

			float
				plane_dist = cascade_plane_distances[layer],
				plane_dist_behind = cascade_plane_distances[layer_before];

			float
				dist_ahead_of_last_plane = world_depth_value - plane_dist_behind,
				depth_range = plane_dist - plane_dist_behind;

			float percent_between = dist_ahead_of_last_plane / depth_range;

			float
				curr_layer_shadow = get_csm_shadow_from_layer(layer, fragment_pos_world_space),
				last_layer_shadow = get_csm_shadow_from_layer(layer_before, fragment_pos_world_space);

			layer_color = mix(colors[layer_before], colors[layer], percent_between);
			return mix(last_layer_shadow, curr_layer_shadow, percent_between);
		}
	}
	*/

_____

	const vec3
		red = vec3(1.0f, 0.0f, 0.0f), green = vec3(0.0f, 1.0f, 0.0f), blue = vec3(0.0f, 0.0f, 1.0f),
		yellow = vec3(1.0f, 1.0f, 0.0f), teal = vec3(0.0f, 1.0f, 1.0f), orange = vec3(1.0f, 0.27f, 0.0f),
		black = vec3(0.0f, 0.0f, 0.0f), white = vec3(1.0f, 1.0f, 1.0f);

	const vec3 colors[NUM_CASCADES] = vec3[NUM_CASCADES](red, green, blue, yellow, teal, orange, black, white);

	layer_color = mix(colors[prev_layer_index], colors[layer_index], percent_between);

_____

	const struct {const GLuint vertex_buffer, vertex_spec;} world_corners;

_____

	if (branch && UV.x < 0.0f || UV.y < 0.0f || UV.x > 1.0f || UV.y > 1.0f) {
		return 0.0f;
	}

_____

	/* (triangle counts, 12 vs 17):
	palace: 1466 vs 1130. tpt: 232 vs 150.
	pyramid: 816 vs 542. maze: 5796 vs 6114.
	terrain: 150620 vs 86588. */

_____

	////////////////////

	// TWEAK_REALTIME_VALUE(zs, 0.0f, 0.0f, 100.0f, 0.1f, T, Y, U);

	////////////////////

_____

	// TODO: test shadows while rotating the camera

	mat4 light_view;

	if (keys[SDL_SCANCODE_C]) {
	vec3 light_eye;
	glm_vec3_add(camera_sub_frustum_center, (GLfloat*) shadow_context -> light_dir, light_eye);

	glm_lookat(light_eye, camera_sub_frustum_center, (vec3) {0.0f, 1.0f, 0.0f}, light_view);
	}

	else {
		vec3 a;
		// glm_vec3_sub(camera_sub_frustum_center, (GLfloat*) shadow_context -> light_dir, a);
		glm_vec3_copy((GLfloat*) shadow_context -> light_dir, a);
		glm_lookat(camera_sub_frustum_center, a, (vec3) {0.0f, 1.0f, 0.0f}, light_view);

		/*
		vec3 d;
		glm_vec3_copy((GLfloat*) shadow_context -> light_dir, d);
		glm_vec3_negate(d);

		// glm_look(camera_sub_frustum_center, (GLfloat*) shadow_context -> light_dir, (vec3) {0.0f, 1.0f, 0.0f}, light_view);
		*/
	}

	for (int y = 0; y < 4; y++) {
		for (int x = 0; x < 4; x++) {
			printf("%lf ", light_view[y][x]);
		}
		puts("");
	}
	puts("---");

_____

	/*
	const GLfloat z_scale = shadow_context -> z_scale;
	const GLfloat one_over_z_scale = 1.0f / z_scale;

	GLfloat
		*const min_z = &light_view_frustum_box[0][2],
		*const max_z = &light_view_frustum_box[1][2];

	*min_z *= (*min_z < 0.0f) ? z_scale : one_over_z_scale;
	*max_z *= (*max_z < 0.0f) ? one_over_z_scale : z_scale;

	if (keys[SDL_SCANCODE_C]) {
		GLfloat s = 2.0f;
		GLfloat one_over_s = 1.0f / s;

	GLfloat
		*const min_x = &light_view_frustum_box[0][1],
		*const max_x = &light_view_frustum_box[1][1];

	*min_x *= (*min_x < 0.0f) ? s : one_over_s;
	*max_x *= (*max_x < 0.0f) ? one_over_s : s;
	}
	*/

_____

	////

	ON_FIRST_CALL(puts("x = TYU, y = GHJ, z = BNM"););

	TWEAK_REALTIME_VALUE(x, 1.0f, 1.0f, 50.0f, 0.005f, T, Y, U);
	TWEAK_REALTIME_VALUE(z, 5.0f, 1.0f, 20.0f, 0.005f, B, N, M);

	vec3 light_view_frustum_box_scale = {x, x, z};

	////

_____

	/* To try:
	- With and without anisotropic filtering (done)
	- Different combos of border modes
	- Setting the border mode for R
	- A static ESM exponent (edge problem still persists, done)

	Notes:
	- Anisotropic filtering causes the little stitch
	*/

_____

	/*
	const GLfloat cx = billboard.pos[0], cy = billboard.pos[1], cz = billboard.pos[2];
	const GLfloat half_height = billboard.size[0] * 0.5f, half_xz_extent = billboard.size[1] * 0.5f;
	*/

_____

typedef struct {
	const vec3 center;
	const GLfloat radius;
} Sphere;

// https://stackoverflow.com/questions/25572337/frustum-and-sphere-intersection
static bool is_inside_plane(const Sphere sphere, const vec4 plane) {
	const GLfloat dist_btwn_plane_and_sphere = glm_vec3_dot((GLfloat*) sphere.center, (GLfloat*) plane) + plane[3];
	return dist_btwn_plane_and_sphere > -sphere.radius;
}

_____

			if (billboard == (Billboard*) cpu_billboards.data + 6) found_needed = true;
_____

	const Billboard* const billboards = billboard_context -> draw_context.buffers.cpu.data;

_____

	/*
	const bool chosen = glm_vec3_eqv((GLfloat*) billboard.pos, (vec3) {4.5f, 4.0f, 12.5f});
	puts(chosen ? "Yah" : "Nah");
	*/

_____


////////// This part concerns computing the convex hull of a sector list (for determining the far clip distance)

static GLfloat convex_hull_of_sectors(const List* const sectors) {

}

_____

// Returns the number of visible faces
static buffer_size_t fill_sector_vertex_buffer_with_visible_faces(
	const BatchDrawContext* const draw_context,
	const List sectors, const Camera* const camera) {

	use_vertex_buffer(draw_context -> buffers.gpu);

	const Sector* const out_of_bounds_sector = (Sector*) sectors.data + sectors.length;

	/* Each vec4 plane in `frustum_planes` is composed of a vec3 surface
	normal and the closest distance to the origin in the fourth component */
	const vec4* const frustum_planes = camera -> frustum_planes;

	const face_mesh_t* const face_meshes_cpu = draw_context -> buffers.cpu.data;
	face_mesh_t* const face_meshes_gpu = init_mapping_for_culled_batching(draw_context);

	buffer_size_t num_visible_faces = 0;

	for (const Sector* sector = sectors.data; sector < out_of_bounds_sector; sector++) {
		buffer_size_t num_visible_faces_in_group = 0;
		const buffer_size_t initial_face_index = sector -> face_range.start;

		while (sector < out_of_bounds_sector && sector_in_view_frustum(*sector, frustum_planes))
			num_visible_faces_in_group += sector++ -> face_range.length;

		if (num_visible_faces_in_group != 0) {
			memcpy(face_meshes_gpu + num_visible_faces,
				face_meshes_cpu + initial_face_index,
				num_visible_faces_in_group * sizeof(face_mesh_t));

			num_visible_faces += num_visible_faces_in_group;
		}
	}

	deinit_current_mapping_for_culled_batching();
	return num_visible_faces;
}

_____

static bool sector_in_view_frustum(const Sector sector, const vec4 frustum_planes[planes_per_frustum]) {
	// First corner is bottom left (if looking top-down, top left), and second is top right
	vec3 aabb_corners[2] = {{sector.origin[0], sector.visible_heights.min, sector.origin[1]}};

	aabb_corners[1][0] = aabb_corners[0][0] + sector.size[0];
	aabb_corners[1][1] = aabb_corners[0][1] + sector.visible_heights.max - sector.visible_heights.min;
	aabb_corners[1][2] = aabb_corners[0][2] + sector.size[1];

	return glm_aabb_frustum(aabb_corners, (vec4*) frustum_planes);
}

_____

	/*
	-1, 1, -1,
	-1, -1, -1,
	1, -1, -1,
	1, -1, -1,
	1, 1, -1,
	-1, 1, -1,

	-1, -1, 1,
	-1, -1, -1,
	-1, 1, -1,
	-1, 1, -1,
	-1, 1, 1,
	-1, -1, 1,

	1, -1, -1,
	1, -1, 1,
	1, 1, 1,
	1, 1, 1,
	1, 1, -1,
	1, -1, -1,

	-1, -1, 1,
	-1, 1, 1,
	1, 1, 1,
	1, 1, 1,
	1, -1, 1,
	-1, -1, 1,

	-1, 1, -1,
	1, 1, -1,
	1, 1, 1,
	1, 1, 1,
	-1, 1, 1,
	-1, 1, -1,

	-1, -1, -1,
	-1, -1, 1,
	1, -1, -1,
	1, -1, -1,
	-1, -1, 1,
	1, -1, 1
	*/

_____

	GLint bytes_for_vertices;
	glGetBufferParameteriv(GL_ARRAY_BUFFER, GL_BUFFER_SIZE, &bytes_for_vertices);

_____

	/*
	const vec4 projectedCenter = XMVector4Transform(XMVectorSetW(center, 1.0f), cascadeViewProjection);

	const float w = proj_center.w;
	const float x = floor((proj_center.x) / w) * inv_texel_scale) * texel_scale;
	const float y = floor((proj_center.y) / w) * inv_texel_scale) * texel_scale;
	const float z = proj_center.z / w;

	vec4 correctedCenter = vec4(x, y, x, 1.0f) * inverse(view_projection);
	vec4 finalCenter = correctedCenter / XMVectorGetW(correctedCente
	*/

_____


	GLfloat size = 1024.0f;

	GLfloat *const min = light_view_frustum_box[0], *const max = light_view_frustum_box[1];

	GLfloat quant_step = 2.0f / size;
	GLfloat qx = remainderf(min[0], quant_step);
	GLfloat qy = remainderf(min[1], quant_step);

	min[0] += qx;
	min[1] += qy;

	/*
	max[0] += size;
	max[1] += size;
	*/

	/*
	var quantizationStep = 1.0f / shadowMapSize;
	var qx = (float)Math.IEEERemainder(min.X, quantizationStep);
	var qy = (float)Math.IEEERemainder(min.Y, quantizationStep);
 
	min.X -= qx;
	min.Y -= qy;
 
	max.X += shadowMapSize;
	max.Y += shadowMapSize;
	*/

_____

	for (byte i = 0; i < 4; i++) column[i] = roundf(column[i]);

_____

static void model_stuff(mat4 model, vec4 world_corners[corners_per_quad]) {
	////////// Scale, then translate, then rotate

	glm_mat4_copy(GLM_MAT4_IDENTITY, model);

	// This moves the weapon in the positive x direction
	// TWEAK_REALTIME_VALUE(o, 0.0f, 0.0f, 2.0f, 0.01f, T, Y, U); glm_translate_z(model, o);

	// Try to tilt the front of the weapon up when the player tilts down
	// TWEAK_REALTIME_VALUE(o, 0.0f, 0.0f, 2.0f, 0.01f, T, Y, U); glm_rotate_z(GLM_MAT4_IDENTITY, glm_rad(o), model);
	// TWEAK_REALTIME_VALUE(o, 0.0f, 0.0f, 2.0f, 0.01f, T, Y, U); glm_rotate_x(GLM_MAT4_IDENTITY, glm_rad(o), model);

	// incr/scale front world corners
}

_____

	// GLfloat* const third = world_corners[2];
	// third[0] += o;

	// glm_vec3_copy(third, (vec3) {0.0f, 0.0f, 0.0f});
	// glm_vec3_copy((vec3) {2.320565f, 0.500023f, 2.041909f}, third);

	// TWEAK_REALTIME_VALUE(o, 0.0f, 0.0f, 2.0f, 0.01f, T, Y, U); glm_rotate_y(GLM_MAT4_IDENTITY, glm_rad(o), m);

	// vec3 axis = {1.0f, 0.0f, 0.0f};
	// TWEAK_REALTIME_VALUE(o, 0.0f, 0.0f, 2.0f, 0.05f, T, Y, U);

	glm_mat4_copy(GLM_MAT4_IDENTITY, m);
	// glm_rotate_at(m, axis, glm_rad(o), center);

_____

	vec3 in_front;
	glm_vec3_add(camera -> pos, dir, in_front);

	glm_vec3_copy(in_front, top_left);
	glm_vec3_copy(in_front, top_left);

_____

	change[0] = TWO_PI - change[0];
	change[1] = TWO_PI - change[1];
	change[2] = TWO_PI - change[2];

_____

	// Corner order: bl, br, tl, tr

_____

	if (!keys[SDL_SCANCODE_G]) {
		glm_vec3_scale((GLfloat*) camera -> right, -tilt_amount, change);
		glm_vec3_abs(change, change);

		// Perhaps tilt by the up vector?
		GLfloat *const bl = world_corners[0], *const br = world_corners[1];
		glm_vec3_add(bl, change, bl);
		glm_vec3_add(br, change, br);
	}

_____

glm_quat_rotatev

_____

	TWEAK_REALTIME_VALUE(o, 0.0f, -2.0f, 2.0f, 0.005f, T, Y, U); camera -> angles.tilt = o;

_____ An attempt at texel snapping:

	const GLfloat texel_scale = 2.0f / 1024.0f;
	const GLfloat inv_texel_scale = 1.0f / texel_scale;

	vec4 projected_center;
	glm_mat4_mulv(light_view_projection, camera_sub_frustum_center, projected_center);
	const GLfloat w = projected_center[3];

	DEBUG_VEC4(projected_center);

	const vec4 projected_corrected_center = {
		floorf((projected_center[0] / w) * inv_texel_scale) * texel_scale,
		floorf((projected_center[1] / w) * inv_texel_scale) * texel_scale,
		projected_center[2] / w, 1.0f
	};

	DEBUG_VEC4(projected_corrected_center);

	mat4 inv_light_view_projection;
	glm_mat4_inv(light_view_projection, inv_light_view_projection);

	vec4 corrected_world_space_center;
	glm_mat4_mulv(inv_light_view_projection, (GLfloat*) projected_corrected_center, corrected_world_space_center);
	glm_vec4_scale(corrected_world_space_center, 1.0f / corrected_world_space_center[3], corrected_world_space_center);

	DEBUG_VEC4(camera_sub_frustum_center);
	DEBUG_VEC4(corrected_world_space_center);
	puts("---");

	vec4 c[8];
	glm_frustum_corners(inv_light_view_projection, c);

	////////// Now this

	get_light_view(corrected_world_space_center, shadow_context -> light_dir, light_view);
	get_light_projection(camera_sub_frustum_corners, shadow_context -> sub_frustum_scale, light_view, light_projection);
	glm_mul(light_projection, light_view, light_view_projection);

_____

typedef struct {
	GLuint face_normal_map_set;
	BatchDrawContext draw_context;
	List sectors;
} SectorContext;

_____

static void erase_version_strings_from_dependency_list(const List* const dependency_list) {
	const GLchar *const base_version_string = "#version", *const full_version_string = "#version ___ core\n";
	const GLsizei full_version_string_length = strlen(full_version_string);

	// Not erasing the version string from the first one because it's the only one that should keep #version in it
	LIST_FOR_EACH(1, dependency_list, untyped_dependency, _,
		const GLchar* const dependency = *((GLchar**) untyped_dependency);

		/*
		ON_FIRST_CALL(
			DEBUG(dependency, s);
			DEBUG(count_num_lines_in_string(dependency), u);
		);
		*/

		GLchar* const version_string_pos = strstr(dependency, base_version_string);
		if (version_string_pos != NULL) {
			memset(version_string_pos, ' ', full_version_string_length);
			// in w/ a #line stmt
			// TODO: avoid some of the unnecessary memset

			// Only need to set the line number for the include string

			/*
			const buffer_size_t dependency_line_count = count_num_lines_in_string(dependency) + 1;

			char line_stmt[100];
			sprintf(line_stmt, "#line %d", dependency_line_count);
			strncpy(version_string_pos, line_stmt, strlen(line_stmt) - 1);

			ON_FIRST_CALL(
				puts("----------");
				DEBUG(dependency, s);
				puts("----------");
				DEBUG(dependency_line_count, u);
				DEBUG(line_stmt, s);
				puts("<---------->");
				DEBUG(version_string_pos, s);
				puts("<---------->");
			);
			*/
		}
	);
}

_____

	/*
	if (*string == '\0') return 0;

	buffer_size_t num_lines = 0;

	while (true) {
		string = strchr(string + 1, '\n');
		if (string == NULL) break;
		num_lines++;
	}

	return num_lines;
	*/

_____


	/*
	- perhaps before each include, get the so-far line count, and then specify the line number after
	- or put #line 0 at the end of each shader - but no that wouldn't work b/c don't want to fully reset it then
	*/

_____

// This is done so that the GLSL compiler can report errors with correct line numbers
static void replace_include_directive_with_line_directive( // The `consts` in front here indicate read-only; not that of `restrict`
	const GLchar* const sub_shader_path, const GLchar* const sub_shader_start,
	GLchar* const include_string_start, const GLchar* const after_include_string) {
	
	////////// Calculating the number of lines before + with the include string

	buffer_size_t line_number_after_include_string = 2;

	const GLchar* copy_sub_shader_start = sub_shader_start;
	for (GLchar c = *copy_sub_shader_start; c != '\0'; c = *(++copy_sub_shader_start)) {
		if (c == '\n') line_number_after_include_string++;
	}

	////////// Calculating the number of bytes needed for the include string

	const buffer_size_t num_bytes_for_include_string = (buffer_size_t) (after_include_string - include_string_start);

	////////// Calculating the number of bytes needed for the line directive

	const GLchar* const line_directive_format = "#line %u";

	// One more byte for the null terminator
	const buffer_size_t num_bytes_for_line_directive = (buffer_size_t) snprintf(NULL, 0, 
		line_directive_format, line_number_after_include_string) + 1;
	
	if (num_bytes_for_line_directive > num_bytes_for_include_string) // Too many bytes for the line number then
		FAIL(CreateShader, "The shader '%s' is too long", sub_shader_path);

	////////// Replacing the bytes of the include string with the line directive, and filling the rest with blank spaces

	sprintf(include_string_start, line_directive_format, line_number_after_include_string);

	const buffer_size_t num_remaining_bytes = num_bytes_for_include_string - num_bytes_for_line_directive;

	/* - 1 for the dest because the early null terminator from `sprintf` should be erased too.
	+ 1 for the amount to erase the null terminator from the previous #include. */
	memset(include_string_start + num_bytes_for_line_directive - 1, ' ', num_remaining_bytes + 1);

	// TODO: make line numbers correct in included files
}

_____

	////////// Fetching the included code, and replacing the #include region with whitespace

	GLchar* const included_code = get_source_for_included_file(dependency_list, sub_shader_path, after_include_string + 1);
	push_ptr_to_list(dependency_list, &included_code); // The included code is freed by `init_shader`

	replace_include_directive_with_line_directive(sub_shader_path, sub_shader_code, include_string, curr_path_substring);

	return true;
}

_____

	if (!strcmp(vertex_shader_path, "../assets/shaders/weapon.vert")) {
		List dep = dependency_lists[0];
		char* first = ((GLchar**) dep.data)[dep.length - 1];
		DEBUG(first, s);
	}

_____

	typedef struct {
		struct {
			List cpu; - done
			GLuint gpu; - done
		} buffers;

		GLuint
			vertex_spec, - done
			texture_set, - done
			shader; - done
	} BatchDrawContext;

	typedef struct {
		GLuint face_normal_map_set; - done
		BatchDrawContext draw_context; - done
		List sectors; - done
	} SectorContext;

_____

GLfloat compute_world_far_clip_dist(const byte* const heightmap, const byte map_size[2]) {
	/* The far clip distance, ideally, would be equal to the diameter of
	the convex hull of all points in the heightmap. If I had more time,
	I would implement that, but a simple method that works reasonably well is this:

	- First, find the smallest and tallest points in the map.
	- Then, the far clip distance equals the length of
		the `<map_width, map_height, (tallest_point - smallest_point) + additional_camera_height>` vector.

	To compute the maximum jump height, use the kinematics equation `v^2 = v0^2 + 2aΔy`.
	Given that `v` equals 0, rearrange the equation like this:

	0 = v0^2 + 2aΔy
	-(v0^2) = 2aΔy
	-(v0^2)/2a = Δy

	And since downward acceleration is positive in `constants`, to not get a negative result,
	remove the negative sign of the left term.

	Then, `additional_camera_height` equals `max_jump_height + eye_height`. */

	const byte map_size_x = map_size[0], map_size_z = map_size[1];

	byte min_point_height = constants.max_byte_value, max_point_height = 0;

	for (byte y = 0; y < map_size_z; y++) {
		for (byte x = 0; x < map_size_x; x++) {
			const byte height = sample_map_point(heightmap, x, y, map_size_x);
			if (height < min_point_height) min_point_height = height;
			if (height > max_point_height) max_point_height = height;
		}
	}

	const GLfloat max_jump_height = (constants.speeds.jump * constants.speeds.jump) / (2.0f * constants.accel.g);
	const GLfloat additional_camera_height = max_jump_height + constants.camera.eye_height;

	const GLfloat max_z_difference = (max_point_height - min_point_height) + additional_camera_height;
	return glm_vec3_norm((vec3) {map_size_x, map_size_z, max_z_difference});
}

_____

	const byte map_size_x = map_size[0], map_size_z = map_size[1];

	GLfloat max_dist_between_points = 0.0f;

	vec3 src, dest;

	for (src[2] = 0.0f; src[2] < map_size_z; src[2]++) {
		for (src[0] = 0.0f; src[0] < map_size_x; src[0]++) {
			src[1] = sample_map_point(heightmap, src[0], src[1], map_size_x);

			for (dest[2] = 0.0f; dest[2] < map_size_z; dest[2]++) {
				for (dest[0] = 0.0f; dest[0] < map_size_x; dest[0]++) {

					dest[1] = sample_map_point(heightmap, dest[0], dest[1], map_size_x);

					const GLfloat dist = glm_vec3_distance(src, dest); // TODO: no sqrt
					if (dist > max_dist_between_points) {
						printf("Set to %lf\n", dist);
						max_dist_between_points = dist;
					}
				}
			}

		}
	}

	return max_dist_between_points;

_____

	GLfloat max_dist_squared_between_points = 0.0f;
	// is 55.190578f with floats. 55.154327f with ints (actually, same now with ints).

	/*
	vec3 src, dest, final_from, final_to;

	for (src[2] = 0; src[2] < map_size_z; src[2]++) {
		for (src[0] = 0; src[0] < map_size_x; src[0]++) {
			src[1] = sample_map_point(heightmap, (byte) src[0], (byte) src[1], map_size_x);

			for (dest[2] = 0; dest[2] < map_size_z; dest[2]++) {
				for (dest[0] = 0; dest[0] < map_size_x; dest[0]++) {

					dest[1] = sample_map_point(heightmap, (byte) dest[0], (byte) dest[1], map_size_x);

					const GLfloat dist_squared = glm_vec3_distance2(src, dest);
					if (dist_squared > max_dist_squared_between_points) {
						max_dist_squared_between_points = dist_squared;
						glm_vec3_copy(src, final_from);
						glm_vec3_copy(dest, final_to);
					}
				}
			}

		}
	}

	// from {0, 3, 0} to {39, 5, 39} with ints, with max squared = 3046.000000f.
	// from {0.000000, 3.000000, 0.000000} to {39.000000, 5.000000, 39.000000} with floats, with max squared = 3046.000000f.

	printf("final_from = {%lf, %lf, %lf}\n", final_from[0], final_from[1], final_from[2]);
	printf("final_to = {%lf, %lf, %lf}\n", final_to[0], final_to[1], final_to[2]);
	DEBUG_FLOAT(max_dist_squared_between_points);

	return sqrtf(max_dist_squared_between_points);
	*/

_____

	/*
	const byte map_size_x = map_size[0], map_size_z = map_size[1];

	GLfloat max_dist_squared_between_points = 0.0f;

	ivec3 src, dest, final_from, final_to;

	for (src[2] = 0; src[2] < map_size_z; src[2]++) {
		for (src[0] = 0; src[0] < map_size_x; src[0]++) {
			src[1] = sample_map_point(heightmap, (byte) src[0], (byte) src[1], map_size_x);

			for (dest[2] = 0; dest[2] < map_size_z; dest[2]++) {
				for (dest[0] = 0; dest[0] < map_size_x; dest[0]++) {

					dest[1] = sample_map_point(heightmap, (byte) dest[0], (byte) dest[1], map_size_x);

					const GLfloat dist_squared = glm_ivec3_distance2(src, dest);
					if (dist_squared > max_dist_squared_between_points) {
						max_dist_squared_between_points = dist_squared;
						glm_ivec3_copy(src, final_from);
						glm_ivec3_copy(dest, final_to);
						glm_ivec2_copy;
					}
				}
			}

		}
	}

	// from {0, 3, 0} to {39, 5, 39} with ints.

	printf("final_from = {%d, %d, %d}\n", final_from[0], final_from[1], final_from[2]);
	printf("final_to = {%d, %d, %d}\n", final_to[0], final_to[1], final_to[2]);
	DEBUG_FLOAT(max_dist_squared_between_points);

	return sqrtf(max_dist_squared_between_points);
	*/

_____ The brute-force optimal solution for the far clip dist:

// This works by finding the two points that have the longest distace between them (consider fact that dist must be at least hypotenuse of map size?)
GLfloat compute_world_far_clip_dist(const byte* const heightmap, const byte map_size[2]) {	
	// TODO: speed this up by finding the diameter of the convex hull of all sectors

	typedef int32_t map_dist_t; // 255 * 255 * 255 = 16,581,375. That needs a 32-bit number.

	const byte map_size_x = map_size[0], map_size_z = map_size[1];

	byte src_x, src_z, dest_x, dest_z;
	map_dist_t max_dist_squared_between_points = 0;

	for (byte z_src = 0; z_src < map_size_z; z_src++) {
		const byte* const row_src = heightmap + z_src * map_size_x;

		for (byte x_src = 0; x_src < map_size_x; x_src++) {
				const byte height_src = row_src[x_src];

				////////// Checking all other points for each point

				for (byte z_dest = 0; z_dest < map_size_z; z_dest++) {
					const byte* const row_dest = heightmap + z_dest * map_size_x;
					const map_dist_t dz = z_dest - z_src;
					const map_dist_t dz_squared = dz * dz;

					for (byte x_dest = 0; x_dest < map_size_x; x_dest++) {
						const map_dist_t dx = x_dest - x_src, dy = row_dest[x_dest] - height_src;
						const map_dist_t curr_dist_squared = dx * dx + dy * dy + dz_squared;

						// Doing >= and not > because otherwise, src and dest could be uninitialized for a height-zero map
						if (curr_dist_squared >= max_dist_squared_between_points) {
							max_dist_squared_between_points = curr_dist_squared;
							src_x = x_src; src_z = z_src; dest_x = x_dest; dest_z = z_dest;
						}
				}

				//////////
			}
		}
	}

	////////// Accounting for the max jump height + additional camera height. From `v^2 = v0^2 + 2aΔy`, `(v0^2)/2a = Δy`.

	const GLfloat max_jump_height = (constants.speeds.jump * constants.speeds.jump) / (2.0f * constants.accel.g);
	const GLfloat additional_camera_height = max_jump_height + constants.camera.eye_height;

	return glm_vec3_distance(
		(vec3) {src_x, sample_map_point(heightmap, src_x, src_z, map_size_x) + additional_camera_height, src_z},
		(vec3) {dest_x, sample_map_point(heightmap, dest_x, dest_z, map_size_x), dest_z}
	);
}

_____

// https://github.com/dmnsgn/glsl-tone-map/blob/master/uchimura.glsl (but with better variable names)
vec3 uchimura_tone_mapping(vec3 color) {
	float L0 = ((tm_max_brightness - tm_linear_start) * tm_linear_length) / tm_linear_contrast;
	float S0 = tm_linear_start + L0, S1 = tm_linear_start + tm_linear_contrast * L0;
	float C2 = (tm_linear_contrast * tm_max_brightness) / (tm_max_brightness - S1);
	float CM = -C2 / tm_max_brightness;

	vec3
		W0 = vec3(1.0f - smoothstep(0.0f, tm_linear_start, color)),
		W2 = vec3(step(tm_linear_start + L0, color));

	vec3
		W1 = vec3(1.0f - W0 - W2),
		T = vec3(tm_linear_start * pow(color / tm_linear_start, vec3(tm_black)) + tm_pedestal),
		L = vec3(tm_linear_start + tm_linear_contrast * (color - tm_linear_start)),
		S = vec3(tm_max_brightness - (tm_max_brightness - S1) * exp(CM * (color - S0)));

	return (T * W0) + (L * W1) + (S * W2);
}

_____

	tm_max_brightness, tm_linear_contrast, tm_linear_start, // `tm` = tone mapping
	tm_linear_length, tm_black, tm_pedestal;

_____

	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glVertexAttribIPointer(0, vertices_per_triangle, GL_UNSIGNED_BYTE, sizeof(face_vertex_t), 0);
	glVertexAttribIPointer(1, 1,                     GL_UNSIGNED_BYTE, sizeof(face_vertex_t), sizeof(face_mesh_component_t[vertices_per_triangle]));

_____

	const byte component = 0;
	screen_corners[component][0] = -1.0f; screen_corners[component][1] = -1.0f;

	// bottom left, _, _, _

_____

layout(pixel_center_integer) in vec4 gl_FragCoord;

_____

	const GLfloat* const screen_corner = screen_corners[i]; // put in screen space

		vec4 viewport = {-constants.window.size[0] / 2, -constants.window.size[1] / 2, constants.window.size[0], constants.window.size[1]};

		vec2 upscaled = {screen_corner[0] * 0.5f + 0.0f, screen_corner[1] * 0.5f + 0.0f};
		upscaled[0] *= constants.window.size[0];
		upscaled[1] *= constants.window.size[1];

		DEBUG_VEC2(screen_corner);
		DEBUG_VEC2(upscaled);

		glm_unprojecti((vec3) {upscaled[0], upscaled[1], 0.0f}, inv_view_projection, viewport, world_corners[i]);

_____

	// Corner order: bl, br, tl, tr
	// printf("bottom = {%f, %f}, {%f, %f}\n", screen_corners[0][0], screen_corners[0][1], screen_corners[1][0], screen_corners[1][1]);
	GLfloat* const bl = screen_corners[0];
	const GLfloat y_precision_loss = -bl[1];
	DEBUG_FLOAT(y_precision_loss);

_____

const vec2 poisson_disk[16] = vec2[16]( 
   vec2(-0.94201624, -0.39906216 ), 
   vec2(0.94558609, -0.76890725 ), 
   vec2(-0.094184101, -0.92938870 ), 
   vec2(0.34495938, 0.29387760 ), 
   vec2(-0.91588581, 0.45771432 ), 
   vec2(-0.81544232, -0.87912464 ), 
   vec2(-0.38277543, 0.27676845 ), 
   vec2(0.97484398, 0.75648379 ), 
   vec2(0.44323325, -0.97511554 ), 
   vec2(0.53742981, -0.47373420 ), 
   vec2(-0.26496911, -0.41893023 ), 
   vec2(0.79197514, 0.19090188 ), 
   vec2(-0.24188840, 0.99706507 ), 
   vec2(-0.81409955, 0.91437590 ), 
   vec2(0.19984126, 0.78641367 ), 
   vec2(0.14383161, -0.14100790 ) 
);

float random(vec3 seed, int i){
	vec4 seed4 = vec4(seed,i);
	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
	return fract(sin(dot_product) * 43758.5453);
}

float get_average_occluder_depth(const vec2 UV, const uint layer_index, const int sample_radius, const vec3 fragment_pos_world_space) {
	float average_occluder_depth = 0.0f;
	vec2 texel_size = 1.0f / textureSize(shadow_cascade_sampler, 0).xy;

	//////////

	if (branch) {
		return texture(shadow_cascade_sampler, vec3(UV, layer_index)).r;
	}

	//////////

	const int num_samples = 16;

	for (int i = 0; i < num_samples; i++) {
		// visibility -= 0.2f * (1.0f - texture(shadowMap, vec3(UV.xy + poisson_disk[i]/700.0f, (ShadowCoord.z-bias)/ShadowCoord.w) ));

		// int index = i;
		// int index = int(16.0f * random(floor(fragment_pos_world_space * 1000.0f), i)) % 16;
		int index = i;

		vec2 UV_shift = poisson_disk[i] * 5.0f; // / 700.0f;
		vec3 sample_UV = vec3(texel_size * UV_shift + UV.xy, layer_index);
		average_occluder_depth += texture(shadow_cascade_sampler, sample_UV).r;
	}

	return average_occluder_depth / num_samples;

_____ Vogel things:

vec2 vogel_disk_sample(const int sample_index, const int num_samples, const float phi) {
	const float golden_angle = 2.4f;

	float r = sqrt(sample_index + 0.5f) / sqrt(num_samples);
	float theta = sample_index * golden_angle + phi;
  
	return vec2(r, r) * vec2(sin(theta), cos(theta));
}

float interleaved_gradient_noise(const vec2 seed) {
	const vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
	return fract(magic.z * fract(dot(seed, magic.xy)));
}

/////////////////////////////////////

// TODO: perhaps use Vogel disk or stratified Poisson sampling instead
float get_average_occluder_depth(const vec2 UV, const uint layer_index, const int sample_radius, const vec3 fragment_pos_world_space) {
	const int num_samples = 20, penumbra_width = 5;

	float average_occluder_depth = 0.0f;
	vec2 texel_size = 1.0f / textureSize(shadow_cascade_sampler, 0).xy;

	for (int i = 0; i < num_samples; i++) {
		float gradient_noise = interleaved_gradient_noise(UV * i);
		vec2 jitter = vogel_disk_sample(i, num_samples, gradient_noise) * penumbra_width;
		vec3 sample_UV = vec3(texel_size * jitter + UV.xy, layer_index);
		average_occluder_depth += texture(shadow_cascade_sampler, sample_UV).r;
	}

	return average_occluder_depth / num_samples;
}

_____

	/*
	struct {
		vec2 right_xz; // This is used for billboards
		vec3 pos, dir, right, up, velocities;
	} vectors;
	*/

_____

	/*
	// TODO: use a library function instead
	const GLfloat hori_angle = angles -> hori, vert_angle = angles -> vert;
	const GLfloat cos_vert = cosf(angles -> vert);
	const vec2 dir_xz = {sinf(hori_angle), cosf(hori_angle)};
	const vec3 dir = {cos_vert * dir_xz[0], sinf(vert_angle), cos_vert * dir_xz[1]};
	*/

_____

		GLfloat velocity = constants.speeds.xz_max * delta_time;
		const GLfloat* movement_dir = GLM_VEC3_ZERO;

		if (CHECK_BITMASK(event.movement_bits, BIT_MOVE_FORWARD)) movement_dir = dir;
		if (CHECK_BITMASK(event.movement_bits, BIT_MOVE_BACKWARD)) {movement_dir = dir; velocity = -velocity;}
		if (CHECK_BITMASK(event.movement_bits, BIT_STRAFE_LEFT)) {movement_dir = right; velocity = -velocity;}
		if (CHECK_BITMASK(event.movement_bits, BIT_STRAFE_RIGHT)) movement_dir = right;

		glm_vec3_muladds(movement_dir, velocity, pos);

_____

	/*
	glm_vec2_copy((vec2) {sin_hori, cos_hori}, dir_xz);
	glm_vec2_copy((vec2) {-cos_hori, sin_hori}, right_xz);

	glm_vec3_copy((vec3) {cos_vert * sin_hori, sin_vert, cos_vert * cos_hori}, dir);
	glm_vec3_copy((vec3) {-cos_hori, 0.0f, sin_hori}, right);
	*/

_____

GLfloat get_hi_res_time_delta(const Uint64 last_time) {
	const Uint64 curr_time = SDL_GetPerformanceCounter();
	const GLfloat delta_time = (GLfloat) (hi_res_curr_time - hi_res_last_time) * one_over_performance_freq;
	hi_res_last_time = hi_res_curr_time;
}

_____


		/*
		const GLfloat ms_elapsed = (GLfloat) (SDL_GetPerformanceCounter() - hi_res_counter_before_tick) * (1000.0f / SDL_GetPerformanceFrequency());
		const GLfloat wait_for_exact_fps = max_delay - ms_elapsed;
		if (wait_for_exact_fps > 0.0f) SDL_Delay((Uint32) wait_for_exact_fps);
		*/

_____

	////////////////////

	static Uint64 hi_res_last_time;

	ON_FIRST_CALL(
		hi_res_last_time = SDL_GetPerformanceCounter();
	);

	const Uint64 hi_res_curr_time = SDL_GetPerformanceCounter();
	const GLfloat hi_res_delta_time = (GLfloat) (hi_res_curr_time - hi_res_last_time) / SDL_GetPerformanceFrequency();
	hi_res_last_time = hi_res_curr_time;

	DEBUG_FLOAT(hi_res_delta_time * 1000.0f);
	DEBUG_FLOAT(secs_elapsed_for_frame * 1000.0f);
	DEBUG_FLOAT(hi_res_delta_time);
	DEBUG_FLOAT(secs_elapsed_for_frame);
	puts("---"); // There is some mismatch here

_____

		// This works super najs
		/*
		.curr_time_secs = curr_time_ms / 1000.0f,
		.delta_time = hi_res_delta_time
		*/

		// This too
		/*
		.curr_time_secs = SDL_GetTicks() / 1000.0f,
		.delta_time = hi_res_delta_time
		*/

		// But not this
		.curr_time_secs = curr_time_ms / 1000.0f,
		.delta_time = secs_elapsed_for_frame

_____

	mat4 local_view = {
		{right[0], up[0], back[0], eye[0]},
		{right[1], up[1], back[1], eye[1]},
		{right[2], up[2], back[2], eye[2]},
		{0.0f, 0.0f, 0.0f, 1.0f}
	};

_____

	mat4 step_1_local_view = {
		{right[0], up[0], back[0], eye[0]},
		{right[1], up[1], back[1], eye[1]},
		{right[2], up[2], back[2], eye[2]},
		{0.0f, 0.0f, 0.0f, 1.0f}

		/*
		{right[0], right[1], right[2], 0.0f},
		{up[0],    up[1],    up[2],    0.0f},
		{back[0],  back[1],  back[2],  0.0f},
		{eye[0],   eye[1],   eye[2],   0.0f},
		*/
	}, local_view;

_____

	/*
	mat4 step_1_local_view = {
		{right[0], up[0], back[0], eye[0]},
		{right[1], up[1], back[1], eye[1]},
		{right[2], up[2], back[2], eye[2]},
		{0.0f, 0.0f, 0.0f, 1.0f}
	}, local_view;

	glm_mat4_inv(step_1_local_view, local_view);
	*/

_____

	/*
	mat4 local_view = {
		{0, 0, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0}
	};
	*/

_____

	mat4 local_view = {
		{ right[0], right[1], right[2], -glm_dot(pos, right)},
		{ up[0],    up[1],    up[2],    -glm_dot(pos, up   )},
		{-dir[0],  -dir[1],  -dir[2],    glm_dot(pos, dir   )},
		{0.0f,     0.0f,     0.0f,     1.0f}
	};

	glm_mat4_transpose(local_view);

	/*

	- note: when speaking about rows, it's of the transposed rows.
	-- first row, third entry flipped.
	-- second row, third entry flipped.
	-- third row, third entry flipped.
	- fourth row, third entry flipped.
	*/

_____

// TODO: to excluded
static void get_view_in_new_way(vec3 pos, vec3 dir, vec3 right, vec3 up, mat4 view) {
	(void) pos; (void) dir; (void) right; (void) up;

	/*
	mat4 local_view = {
		{ right[0], right[1], right[2], -glm_dot(pos, right)},
		{ up[0],    up[1],    up[2],    -glm_dot(pos, up   )},
		{-dir[0],  -dir[1],  -dir[2],    glm_dot(pos, dir   )},
		{0.0f,     0.0f,     0.0f,     1.0f}
	};

	glm_mat4_transpose(local_view);
	*/

	/*
	- note: when speaking about rows, it's of the transposed rows.
	-- first row, third entry flipped.
	-- second row, third entry flipped.
	-- third row, third entry flipped.
	- fourth row, third entry flipped.
	*/

	mat4 local_view = {
		{right[0], up[0], -dir[0], 0.0f},
		{right[1], up[1], -dir[1], 0.0f},
		{right[2], up[2], -dir[2], 0.0f},
		{-glm_dot(pos, right), -glm_dot(pos, up), glm_dot(pos, dir), 1.0f}
	};

	print_mat4("local view", local_view);

	glm_mat4_copy(local_view, view);

	mat4 cmp_view;
	glm_look((GLfloat*) pos, (GLfloat*) dir, (GLfloat*) up, cmp_view);

	print_mat4("reference view", cmp_view);

	puts("-------");
}

_____


// TODO: remove
static void print_mat4(const GLchar* const name, const mat4 m) {
	printf("%s =\n---\n", name);

	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++)
			printf("%f ", (double) m[y][x]);
		putchar('\n');
	}
	puts("---");
}

_____

	//
	vec2 upscaled_UV = UV * 1024.0f; // in pixel coordinates
	vec2 texel_fraction = fract(upscaled_UV);

	upscaled_UV -= texel_fraction;

	UV = upscaled_UV / 1024.0f;
	//

_____

	const int flt = 0, right = 1, bottom = 2, left = 3, top = 4;

_____ Recalculating the linear filter weight:

vec2 semistep_UV_fraction(const int num_iters, const vec2 UV) {
	vec2 texel_size = textureSize(texture_sampler, 0).xy;
	vec2 upscaled = UV.xy * texel_size;
	vec2 texel_percent = fract(upscaled);

	for (int i = 0; i < num_iters; i++)
		texel_percent = smoothstep(0.0f, 1.0f, texel_percent);
	
	vec2 upscaled_reweighted = floor(upscaled) + texel_percent;
	return upscaled_reweighted / texel_size;
}

void main(void) {
	vec2 clamped = semistep_UV_fraction(5, UV.xy);
	vec3 new = branch ? vec3(clamped, UV.z) : UV;

_____ Plain normals:

vec3 get_fragment_normal(const vec3 UV) {
	/*
	// `t` = tangent space normal. Normalized b/c linear filtering may unnormalize it.
	vec3 t = normalize(texture(normal_map_sampler, UV).rgb * 2.0f - 1.0f);

	// No matrix multiplication here! :)
	vec3 rotated_vectors[5] = vec3[5](
		vec3(t.xz, -t.y), // Flat
		vec3(t.zy, -t.x), // Right
		t, // Bottom (equal to tangent space)
		vec3(-t.z, t.yx), // Left
		vec3(-t.x, t.y, -t.z) // Top (opposite of tangent space)
	);

	return rotated_vectors[face_id];
	*/

	// const int flt = 0, right = 1, bottom = 2, left = 3, top = 4;

	normal_map_sampler;

	const vec3 normals[] = vec3[](vec3(0, 1, 0), vec3(1, 0, 0), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(0, 0, -1));
	return normals[face_id];
}

_____

		GLfloat
			*minx = &light_view_sub_frustum_box[0][0], 
			*miny = &light_view_sub_frustum_box[0][1], 
			*minz = &light_view_sub_frustum_box[0][2], 
			*maxx = &light_view_sub_frustum_box[1][0],
			*maxy = &light_view_sub_frustum_box[1][0],
			*maxz = &light_view_sub_frustum_box[1][0];
		
		for (int y = 0; y < 2; y++) {
			for (int x = 0; x < 3; x++) {
				light_view_sub_frustum_box[y][x] = floorf(light_view_sub_frustum_box[y][x]);
			}
		}

_____

	const GLfloat half_resolution = resolution * 0.5f;

	GLfloat* const col = light_view_projection[3];

	vec3 shadow_origin = {
		col[0] * half_resolution,
		col[1] * half_resolution,
		col[2] * half_resolution
	};

	GLfloat* const c = col;

	vec3 b = {
		floorf(shadow_origin[0]) - shadow_origin[0],
		floorf(shadow_origin[1]) - shadow_origin[1],
		floorf(shadow_origin[2]) - shadow_origin[2],
	};

	vec3 rounding_offset = {
		b[0] / half_resolution,
		b[1] / half_resolution,
		b[2] / half_resolution
	};

	GLfloat* const col_2 = light_projection[3];
	glm_vec3_add(col_2, rounding_offset, col_2);

	glm_vec3_scale(col_2, 1.0f / col_2[3], col_2);

	/*
	vec3 shadow_origin, rounding_offset;

	glm_vec3_scale((GLfloat*) light_view_projection[3], half_resolution, shadow_origin);
	glm_vec3_sub((vec3) {roundf(shadow_origin[0]), roundf(shadow_origin[1]), roundf(shadow_origin[2])}, shadow_origin, rounding_offset);
	glm_vec3_scale(rounding_offset, 1.0f / half_resolution, rounding_offset);

	GLfloat* const column = light_projection[3];
	glm_vec3_add(column, rounding_offset, column);
	*/

_____

Shared:
	- First, update billboards on the CPU
	- Then, cull billboards into the GPU buffer

- Some transform feedback system for shadowing that works like this:
	- After that, generate 4 instanced corners per visible billboard using transform feedback into a new buffer
	- Following, draw those four instanced corner sets into a shadow buffer
	- After that, draw the billboards normally with the billboard shader
- Other idea:
	- Make a function `transform_billboard_vertex` that can be shared across shaders
	- Then, find some way to inject that into _

_____

	const Uint8* const keys = event -> keys;
	const bool
		a = keys[SDL_SCANCODE_7],
		b = keys[SDL_SCANCODE_8],
		c = keys[SDL_SCANCODE_9];
	
	if (a) {
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
	}
	else if (b) {
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	}
	else if (c) {
		glBlendFuncSeparate(GL_ONE,       GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	}

	/*
	if (event -> keys[SDL_SCANCODE_C]) {
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
	}
	else {
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	}
	*/

	/*
	std from opengl page: 			glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
	std 2 from opengl page: 		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	premultiplied from opengl page: glBlendFuncSeparate(GL_ONE,       GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	premultiplied from article:		glBlendFuncSeparate(GL_ONE,       GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	*/

_____

	const GLsizei num_samples = 8;
	const bool doing_fixed_sample_locations = true;
	const TextureType type = TexSetMultisampled;
	const TextureFilterMode filter_mode = TexLinear;
	const TextureWrapMode wrap_mode = TexNonRepeating;

	GLuint depth_layers;
	glGenTextures(1, &depth_layers);
	glBindTexture(type, depth_layers);

	// The mag/min filter line is messing up somehow

	GL_ERR_CHECK;

	glTexParameteri(type, GL_TEXTURE_MAG_FILTER, filter_mode);
	glTexParameteri(type, GL_TEXTURE_MIN_FILTER, filter_mode);

	GL_ERR_CHECK;

	glTexParameteri(type, GL_TEXTURE_WRAP_S, wrap_mode);
	glTexParameteri(type, GL_TEXTURE_WRAP_T, wrap_mode);

	glTexImage3DMultisample(
		type,
		num_samples,
		OPENGL_SIZED_SHADOW_MAP_PIXEL_FORMAT,
		resolution,
		resolution,
		num_cascades,
		doing_fixed_sample_locations
	);

_____

#define TEST_CODE_FOR_GL_ERROR(...)\
	puts("Begin testing block of code");\
	__VA_ARGS__\
	do {\
		const GLchar* const GL_error = get_GL_error();\
		DEBUG(GL_error, s);\
		if (!strcmp("GL_NO_ERROR", GL_error)) puts("Bad news bears");\
		else puts("Nice in the neighborhood");\
		puts("---\nEnd testing block of code");\
	} while (false)

_____

		/*
		{12.162462f, 6.001378f, 6.951277f},
		{16.795578f, 2.635072f, 8.632238f},
		{11.629292f, 2.307998f, 7.210117f}
		*/

_____

		// Point defining left leg bck
		// {left_leg_bottom[0] + leg_l}
		
		// {-1.0f, 0.0f, 0.0f}, // Leg point bottom, on the left
		/*
		{-1.2f, leg_h, 0.0f}, // Left leg, top left side of it
		{-0.8f, leg_h, 0.0f}, // Left leg, top right side of it
		*/

		// {1.0f, 0.0f, 0.0f} // Left leg, front side of it

_____ 3D character vertex shader:

#version 400 core

layout(location = 0) in vec3 vertex_pos_world_space;

uniform mat4 view_projection;

out float vertex_id;

void main(void) {
	gl_Position = view_projection * vec4(vertex_pos_world_space, 1.0f);
	vertex_id = gl_VertexID;
}

_____ 3D character fragment shader:

#version 400 core

in float vertex_id;
out vec3 color;

void main(void) {
	color = vec3(0.0f, vertex_id / 20.0f, 1.0f); // Blue
}

_____ Old character model functions (init/render/deinit):

/* Having the character model rigged in a way
so that it fits seamlessly with the weapon sprite
in world space would look nice */
static CharacterModel init_character_model(void) {
	const GLfloat foot_w = 0.2f, foot_l = 0.8f;

	// These are defined in model space
	vec3 vertices[] = {
		// Left foot sole
		{-1, 0, 0},
		{-1, 0, foot_l},
		{-1 - foot_w, 0, foot_l},
		{-1 - foot_w, 0, 0}
	};

	/*
	- Next, make a leg
	- Or, start designing a basic character model in Blender
		- The hands are always forward and holding the weapon
		- For the legs, I'm not sure
	
	- Animation would be easier with a flat character model, hm
	- It would also fit the theme of flatness better
	*/

	const GLubyte indices[] = {
		0, 1, 2,
		0, 2, 3
	};

	//////////

	const vec3 world_center = {5.2f, 1.01f, 7.5f};

	const buffer_size_t num_vertices = ARRAY_LENGTH(vertices);
	for (byte i = 0; i < num_vertices; i++) {
		GLfloat* const vertex = vertices[i];
		glm_vec3_add((GLfloat*) world_center, vertex, vertex);
	}

	//////////

	const GLuint vertex_buffer = init_gpu_buffer();
	use_vertex_buffer(vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	const GLuint vertex_spec = init_vertex_spec();
	use_vertex_spec(vertex_spec);
	define_vertex_spec_index(false, true, 0, 3, 0, 0, GL_FLOAT);

	const GLuint index_buffer = init_gpu_buffer();
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

	return (CharacterModel) {
		.num_vertices = num_vertices, .num_indices = ARRAY_LENGTH(indices),
		.vertex_buffer = vertex_buffer, .vertex_spec = vertex_spec,
		.index_buffer = index_buffer,
		.shader = init_shader(ASSET_PATH("shaders/character.vert"), NULL, ASSET_PATH("shaders/character.frag"))
	};
}

static void draw_character_model(const CharacterModel c, const mat4 view_projection, const bool to_shadow_map) {
	WITHOUT_BINARY_RENDER_STATE(GL_CULL_FACE,

		glBindBuffer(GL_ARRAY_BUFFER, c.vertex_buffer);
		glBindVertexArray(c.vertex_spec);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, c.index_buffer);

		if (!to_shadow_map) {
			glUseProgram(c.shader);

			static GLint view_projection_id;
			ON_FIRST_CALL(INIT_UNIFORM(view_projection, c.shader););
			UPDATE_UNIFORM(view_projection, Matrix4fv, 1, GL_FALSE, &view_projection[0][0]);
		}

		glDrawElements(GL_TRIANGLES, (GLsizei) c.num_indices, GL_UNSIGNED_BYTE, (void*) 0);
	);
}

static void deinit_character_model(const CharacterModel c) {
	deinit_gpu_buffer(c.index_buffer);
	deinit_gpu_buffer(c.vertex_buffer);
	deinit_vertex_spec(c.vertex_spec);
	deinit_shader(c.shader);
}

_____ Character stuff in the main drawing loop:

	////////// Rendering to the shadow context

	const vec4* const view_projection = camera -> view_projection;
	draw_character_model(scene_context -> character_model, view_projection, false);

	enable_rendering_to_shadow_context(shadow_context, camera);

	draw_all_sectors_to_shadow_context(&sector_context -> draw_context);
	draw_character_model(scene_context -> character_model, view_projection, true);

	disable_rendering_to_shadow_context(event -> screen_size);

	////////// The main drawing code

_____ The character model struct:

typedef struct {
	const buffer_size_t num_vertices, num_indices;
	const GLuint vertex_buffer, vertex_spec, index_buffer, shader;
} CharacterModel;

_____

/*
Details on weapon coordinate space transformations:
- Certain parameters define how the weapon swings back and forth

- Screen-space coordinates are generated from those
- Then, those coordinates are unprojected into world-space, tilted, and copied over to the vbo
- In the fragment shader, the world-space coordinates are then reprojected to screen-space to get gl_Position

- This screen -> world -> screen process is done, instead of doing screen -> screen, for a few reasons:
	1. World-space coordinates are needed for lighting calculations
	2. Getting world coordinates, and then going to screen-space after that
		(in the fragment shader), works better with the shadow mapping pipeline
	3. Tilting can't be done in screen-space
*/

_____

		const Uint8* const keys = event -> keys;
		TWEAK_REALTIME_VALUE(at, 0.0f, 0.0f, 1.0f, 0.002f, T, Y, U);

_____

	/*
	- How do I get the 2D UV here?
	- So, I can get the world-space position from the vertex shader
	- And I have the light-space position at hand with gl_FragCoord
	- Tricky tricky

	- I will need to set some UVs that I can test against
	- Input from depth vertex shader first
	*/

_____

	/*
	float alpha = mix(color.a, 1.0f, color.a == 0.0f); // Done to avoid a division by zero
	color.rgb /= alpha; // Unassociating alpha from the rgb components (not a problem since alpha blending is not used)
	*/

_____

		/*
		matrix[0][2] * vector_4D[0] +
		matrix[1][2] * vector_4D[1] +
		matrix[2][2] * vector_4D[2] +
		matrix[3][2] * vector_4D[3]
		*/

_____


	*fast_result = -(
		matrix_row[0] * vector_4D[0] +
		matrix_row[1] * vector_4D[1] +
		matrix_row[2] * vector_4D[2] +
		matrix_row[3] * vector_4D[3]
	);

_____

	/*
	A 4x4 matrix:
	| a b c d |
	| e f g h |
	| i j k l |
	| m n o p |

	A 4d vector:
	< x y z w >

	multiplying a 4d vector by a 4x4 matrix:

	<
	ax + by + cz + d
	ex + fy + gz + h
	ix + jy + kz + l
	mx + ny + oz + p
	>

	d = 0, h = 0, l = 0, p = 1
	So, that equals this:

	<
	ax + by + cz
	ex + fy + gz
	ix + jy + kz
	mx + ny + oz + pw
	>

	w = 1

	So, that equals this:

	<
	ax + by + cz
	ex + fy + gz
	ix + jy + kz
	mx + ny + oz + p
	>

	Since I only want the z component of the output vector, all I really need is ix + jy + kz
	*/

_____

// TODO: remove
static void matrix_test(GLfloat* const fast_result, GLfloat* const reference_result) {
	////////// Defining the input variables

	const mat4 matrix = {
		{1.9f, -2.3f, 4.5f, 20.4f},
		{4.6f, 3.2f, -1.7f, 1.8f},
		{-4.9f, 5.0f, 5.1f, 5.2f},
		{5.3f, -5.4f, 5.5f, 5.6f}
	};

	const vec3 vector = {5.4f, 2.2f, 3.1f};

	//////////

	// Now this is the actual logic test

	const vec4 matrix_row = {matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2]};
	DEBUG_VEC4(matrix_row);
	*fast_result = -(glm_vec3_dot(matrix_row, vector) + matrix_row[3]);

	vec4 dest; glm_mat4_mulv((vec4*) matrix, (vec4) {vector[0], vector[1], vector[2], 1.0f}, dest);
	*reference_result = -dest[2];
}

_____

	GLfloat fast, reference;
	matrix_test(&fast, &reference);
	DEBUG_FLOAT(fast);
	DEBUG_FLOAT(reference);
	puts("---");

	//////////

_____

	////////// Filling in the static billboards beforehand (the dynamic ones that change position + texture id are updated later)

	for (buffer_size_t i = 0; i < num_billboard_animation_instances; i++) {
		const BillboardAnimationInstance* const animation_instance = billboard_animation_instances + i;
	}

	//////////

_____

// TODO: remove
static int cmp_ints(const void* const a_untyped, const void* const b_untyped) {
	const int a = *(int*) a_untyped, b = *(int*) b_untyped;

	if (a > b) return 1;
	else if (a < b) return -1;
	else return 0;
}

// TODO: to excluded
static void sort_billboard_indices(const BillboardContext* const billboard_context) {
		GL_ERR_CHECK;

	//////////////////// A little sorting test

	#define print_arr(a) do {printf("arr = { "); for (unsigned i = 0; i < ARRAY_LENGTH(a); i++) printf("%d ", a[i]); puts("}\n---");} while (false)
	int arr[] = {4, 5, 7, 3, 2};
	qsort(arr, ARRAY_LENGTH(arr), sizeof(int), cmp_ints);
	print_arr(arr);

	////////////////////
	
	/*
	- On the first round, initialize the array with a bunch of indices ranging from 0 to num_billboards - 1

	- During sorting, use each index to get billboards from a passed-in billboard array
	- Then, compare the billboards based on their distance to the camera
	- Or, generate a `dist_from_camera` list, to avoid repeated calls to `sqrt`

	- Next goal: find a way to pass another param into a `qsort`-like function
	*/

	billboard_index_t* const index_buffer_ptr = glMapBufferRange(GL_ELEMENT_ARRAY_BUFFER, 0,
		num_billboards * sizeof(billboard_index_t), GL_MAP_READ_BIT | GL_MAP_WRITE_BIT);

	DEBUG((void*) index_buffer_ptr, p);

	GL_ERR_CHECK;
	GL_ERR_CHECK;
	puts("---");

	glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);

	/////

_____

	vec3 v = {28.000000f, 2.500000f, 31.000000f};
	DEBUG_VEC3(v);
	DEBUG_VEC3(camera_pos);

_____

	// Initializing the sort ref indices in a range of [0, `num_billboards`)
	billboard_context.distance_sort_refs.length = num_billboards;
	for (billboard_index_t i = 0; i < num_billboards; i++)
		((BillboardDistanceSortRef*) billboard_context.distance_sort_refs.data)[i].index = i;

_____

	////////// Some troubleshooting

	// The buffer binding (`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`) is correct; 3

	GLint index_binding;
	glGetVertexAttribiv(0, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, &index_binding);
	DEBUG(index_binding, d);

	// TODO: test element array buffer binding too

_____


	///////////////////////////////// Important check

	puts("Indices before:");
	for (int i = 0; i < num_billboards; i++) printf("%d, ", sort_ref_data[i].index);

	// Sorting from back to front
	qsort(sort_ref_data, num_billboards, sizeof(BillboardDistanceSortRef), compare_billboard_sort_refs);

	puts("\nIndices after:");
	for (int i = 0; i < num_billboards; i++) printf("%d, ", sort_ref_data[i].index);
	putchar('\n');

	/*
	if (exists_in_array(sort_ref_data, num_billboards, 16)) puts("Problem of 16");

	for (int i = 0; i < num_billboards; i++) {
		// Why doesn't this shit work
		if (!exists_in_array(sort_ref_data, num_billboards, i)) printf("Failure for %d\n", i);
	}
	*/

	puts("---");

	/////////////////////////////////

_____

// TODO: remove
bool exists_in_array(const BillboardDistanceSortRef* const array, const billboard_index_t length, const billboard_index_t value) {
	for (billboard_index_t i = 0; i < length; i++) {
		if (value == array[i].index) return true;
	}
	return false;
}

_____


	/*
	// TODO: as a test, try swapping two indices outside the loop
	if (keys[SDL_SCANCODE_C]) {
		#define SWAP_INDICES(array, a, b) do {\
			const billboard_index_t temp = array[a];\
			array[a] = array[b]; array[b] = temp;\
		} while (false)
		// const billboard_index_t health_kit_1 = 0, 

		// SWAP_INDICES(billboard_indices, 0, 1);
	}
	*/

_____

/* Note: the index buffer is used for sorting billboards
from back to front (for the sake of blending). Indices,
and not billboards, are sorted for two reasons:

1. It may be expensive to copy around billboards when sorting them.

2. Billboard animation instances keep track of the billboard that they're
	associated with by an index into the billboard CPU buffer, so shuffling
	that buffer around would definitely cause a problem.
	
`distance_sort_references` is used for sorting. Inside it, it contains a struct
(private to `billboard.c`) that contains a billboard index and a distance from the camera,
and then those are sorted from farthest to closest to the camera. After that, the indices
in that are used to populate the billboard index buffer.

Ideally, I would use `qsort_r` to sort the index buffer (accessed via mapping the contents
of the index buffer), accessing billboards via the extra parameter passed in (compared to `qsort`),
but it is not standard in C99, so I'm using this way of doing things instead. */

_____

	/*
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, billboard_context -> index_buffer);

	// TODO: add `GL_MAP_UNSYNCHRONIZED_BIT` with `glMapBufferRange` if possible
	billboard_index_t* const billboard_indices = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_READ_WRITE);

	// const billboard_index_t inds[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
	for (billboard_index_t i = 0; i < num_billboards; i++) {

		const billboard_index_t index =
			// inds[i];
			sort_ref_data[i].index;

		billboard_indices[i] = index; // Only setting this to `i` works, for some reason
	}

	glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);
	*/

_____

	////////// Initializing the index buffer

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, billboard_context.index_buffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, num_billboards * sizeof(billboard_index_t), NULL, GL_DYNAMIC_DRAW);

_____

	//////////

	// GL_ERR_CHECK;

	// Will this actually render all billboards back to front?
	/*
	glDrawElementsInstanced(GL_TRIANGLE_STRIP,
		4, BILLBOARD_INDEX_TYPENAME, (void*) 0,
		(GLsizei) billboard_context -> billboards.length);
		// 2); // Trying only one billboard for the time being, for the sake of debugging
	*/

	use_vertex_spec(billboard_context -> vertex_spec);
	glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, corners_per_quad, (GLsizei) billboard_context -> billboards.length);

	/*
	okay, so 
	- One problem is that gl_VertexID is getting too large
	- Ok, so for indexed commands, gl_VertexID becomes the value of the index
	*/

	// GL_ERR_CHECK;

	/*
	- Perhaps instead of indexed rendering, just first sort a set of indices for the array, and then do this process:

		for (int i = 0; i < num_billboards; i++) {
			int billboard_index = sorted_index_array[i]; // indices of back-to-front billboards
			mapped_gpu_buffer[i] = billboards[billboard_index];
		}

		for index i in sorted_index_array: mapped_gl_buffer[i]

		and then load those indices into 
	*/

_____

	vec3 dest;
	glm_vec3_copy(camera -> pos, dest);
	dest[0] -= 0.01f;
	glm_vec3_copy(dest, ((Billboard*) billboard_context -> billboards.data)[6].pos);

_____

			char filename[] = "_.bmp";
			filename[0] = i + '0';
			DEBUG(filename, s);
			SDL_SaveBMP(face_surface, filename);

_____

// TODO: to included
// This assumes that the texture is already bound
void init_texture_data(const bool mipmapped, const bool of_array, const byte num_dimensions, const GLsizei size[], const GLenum format, const GLint internal_format, const GLenum pixel_type, const void* const pixels) {
	const GLenum
		plain_targets[3] = {GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D},
		array_targets[3] = {GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_ARRAY};

	if (num_dimensions == 0 || num_dimensions > 3) FAIL(InitializeTextureData,
		"Number of dimensions is not 1, 2, or 3: %d\n", num_dimensions
	);

	///////////

	const GLenum target = of_array ? array_targets[num_dimensions] : plain_targets[num_dimensions];

	const GLint level = 0, border = 0;

	///////////

	switch (num_dimensions) {
		#define DIMENSION_CASE(dimensions, ...) case dimensions: glTexImage##dimensions##D(\
			target, level, internal_format, __VA_ARGS__, border, format, pixel_type, pixels\
		); break

		DIMENSION_CASE(1, size[0]);
		DIMENSION_CASE(2, size[0], size[1]);
		DIMENSION_CASE(3, size[0], size[1], size[2]);

		#undef DIMENSION_CASE
	}

	if (mipmapped) glGenerateMipmap(target);
}

_____ A simple SDL test app:

// If SDL2/SDL.h isn't found, try SDL.h
#if __has_include("SDL2/SDL.h")
	#include <SDL2/SDL.h>
#else
	#include <SDL.h>
#endif

#include <stdbool.h>

int main(void) {
	SDL_Window* window;
	SDL_Renderer* renderer;

	SDL_CreateWindowAndRenderer(800, 600, 0, &window, &renderer);

	const Uint8* const keys = SDL_GetKeyboardState(NULL);

	SDL_Event event;

	bool running = true;

	while (running) {
		while (SDL_PollEvent(&event)) {
			if (event.type == SDL_QUIT) running = false;
		}

		SDL_RenderPresent(renderer);
	}

	printf("Here it is: %d\n", SDL_GetNumAllocations());

	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);

	SDL_Quit();

	printf("After: %d\n", SDL_GetNumAllocations());
}

_____

	//////////

	/* TODO:
	1. Query the buffer size
	2. Assign data on a per-member level */

	/* In order to get the size of a uniform block in bytes, you need to pass in a shader that contains the uniform block,
	along with a block index for it. Since a uniform block will never have a size of zero, this part gets the size of the
	uniform block in bytes when the size has not been initialized. This means that in order to allocate data for the uniform
	block, you must know the size of it, and thus, call `init_uniform_buffer_for_shader` before `init_uniform_buffer_data`. */

	/*
	GLint* const size_in_bytes = &buffer.size_in_bytes;
	if (*size_in_bytes == 0) glGetActiveUniformBlockiv(shader, block_index, GL_UNIFORM_BLOCK_DATA_SIZE, size_in_bytes);
	DEBUG(*size_in_bytes, d);
	*/

_____

		/*
		const GLchar* const subvar_names[] = {"foo"};
		UniformBuffer ubo = init_uniform_buffer(false, "LightParams", 0, shader, subvar_names, ARRAY_LENGTH(subvar_names));

		enable_uniform_buffer_writing_batch(&ubo);
		int value = 1; write_to_uniform_buffer(&ubo, "foo", &value, sizeof(value));
		disable_uniform_buffer_writing_batch(&ubo);
		bind_uniform_buffer_to_shader(&ubo, shader);
		*/

_____

	/*
	vec3 fragment_normal = vec3(1.0f, 0.0f, 0.0f); // TODO: set this to something useful
	color = calculate_light(texture(texture_sampler, UV), fragment_normal);
	color = postprocess_light(UV.xy, color);
	*/

_____

	const Uint32 b4 = SDL_GetTicks();
	const GLuint nm = init_normal_map_set_from_texture_set(scene_context.billboard_context.diffuse_texture_set, true);
	const Uint32 after = SDL_GetTicks();
	DEBUG(after - b4, u);

_____

const vec3 vertices[][3] = {
	vec3(-1, 1, 1), vec3(1, 1, 1), vec3(-1, -1, 1), vec3(1, -1, 1),
	vec3(1, -1, -1), vec3(1, 1, 1), vec3(1, 1, -1), vec3(-1, 1, 1), vec3(-1, 1, -1),
	vec3(-1, -1, 1), vec3(-1, -1, -1), vec3(1, -1, -1), vec3(-1, 1, -1), vec3(1, 1, -1)
};

_____

	/* Figuring out predistortion:
	https://tf2maps.net/threads/how-would-you-make-a-skybox-look-sphearical.30830/
		- "You need to pre-distort them. There must be Photoshop helper files for that on this forum."
	
	https://community.adobe.com/t5/photoshop-ecosystem-discussions/trying-to-distort-a-cubemap-to-look-like-a-sphere-but-having-no-idea-how/td-p/8734850
	https://docs.imgtec.com/Graphics_Techniques/PBR_with_IBL_for_PVR/topics/Assets/pbr_ibl__converting_to_a_cubemap.html
	https://github.com/greg-kennedy/GradientSkybox
	https://www.youtube.com/watch?v=4uGIeej4WFw
	*/

_____

	const GLchar* const paths[faces_per_cubemap] = {
		ASSET_PATH("../bob/right.bmp"),
		ASSET_PATH("../bob/left.bmp"),
		ASSET_PATH("../bob/top.bmp"),
		ASSET_PATH("../bob/down.bmp"),
		ASSET_PATH("../bob/forward.bmp"),
		ASSET_PATH("../bob/backward.bmp"),
	};
	DEBUG(cube_size, d);

	WITH_SURFACE_PIXEL_ACCESS(face_surface,
		for (byte i = 0; i < faces_per_cubemap; i++) {
			const GLint* const src_origin = src_origins[i];

			/*
			DEBUG(paths[i], s);
			SDL_Surface* src = SDL_LoadBMP(paths[i]);
			DEBUG(src -> w, d);
			DEBUG(src, p);
			SDL_ERR_CHECK;
			puts("---");
			*/

_____

	vec3 _____d;
	glm_vec3_negate_to((GLfloat*) dir, _____d);
	DEBUG_VEC3(_____d);

_____

			if (!strcmp(subvar_name, "csd")) {
				printf("Found resolution for %s; byte offset is %d. Writing %zu bytes.\n", subvar_name, buffer -> subvar_byte_offsets[i], size);
			}

_____

const float csd_local[7] = float[](2.634605f, 5.187578f, 8.074060f, 11.621183f, 16.476944f, 23.924938f, 36.507793f);

_____

	for (int i = 0; i < 7; i++) {
		DEBUG_FLOAT(((GLfloat*) shadow_context -> split_dists.data)[i]);
	}

_____

	write_to_uniform_buffer(shading_params, "csd", shadow_context -> split_dists.data, sizeof(GLfloat[7]));

_____

	/*
	- It seems like the overarching problem is that I can't write to arrays in UBOs, for some reason.
	- The problem doesn't happen with one-size arrays though, for some reason.
	- Actually, it seems like it can only read the first element of any array, but nothing more.
	- With an array of 3 vec3s, inputted with {{1, 0, 0}, {0, 1, 1}, {1, 1, 1}}, [0] becomes red (correct),
		[1] becomes white (should be teal), and [2] becomes red (should be white).
	
	- Test on Intel to see what happens there.
	- Same problem on Intel; super weird.
	- Look up `array in ubo`, OpenGL, and try to find some example code.
	*/

	const vec3 data[] = {{1, 0, 0}, {0, 1, 1}, {1, 1, 1}};

_____

	/*
	const byte padding = 8;

	memcpy(offset + rel_offset, data + 0, sizeof(int));
	rel_offset += sizeof(int) + padding;

	memcpy(offset + rel_offset, data + 1, sizeof(int));
	rel_offset += sizeof(int) + padding;

	memcpy(offset + rel_offset, data + 2, sizeof(int));
	rel_offset += sizeof(int) + padding;

	DEBUG(rel_offset, d);
	*/

	/*
	unsigned unos = 1;
	DEBUG_BITS(unos);
	memset(offset, unos, 48);
	*/

	/*
	memcpy(shading_params -> gpu_memory_mapping + 12, data + 1, sizeof(int));
	memcpy(shading_params -> gpu_memory_mapping + 16, data + 2, sizeof(int));
	*/
	// write_to_uniform_buffer(shading_params, "bob", data, sizeof(data));

	/* The offset for `ambient_strength` (which comes after) is 48.
	So, it seems that there's this layout:

	4 bytes for int
	8 bytes padding
	4 bytes for int
	8 bytes padding
	4 bytes for int
	8 bytes padding
	and then some more
	*/

_____

	/*
	const byte padding = 8;

	memcpy(offset + rel_offset, data + 0, sizeof(int));
	rel_offset += sizeof(int) + padding;

	memcpy(offset + rel_offset, data + 1, sizeof(int));
	rel_offset += sizeof(int) + padding;

	memcpy(offset + rel_offset, data + 2, sizeof(int));
	rel_offset += sizeof(int) + padding;

	DEBUG(rel_offset, d);
	*/

	/*
	unsigned unos = 1;
	DEBUG_BITS(unos);
	memset(offset, unos, 48);
	*/

	/*
	memcpy(shading_params -> gpu_memory_mapping + 12, data + 1, sizeof(int));
	memcpy(shading_params -> gpu_memory_mapping + 16, data + 2, sizeof(int));
	*/
	// write_to_uniform_buffer(shading_params, "bob", data, sizeof(data));

	/* The offset for `ambient_strength` (which comes after) is 48.
	So, it seems that there's this layout:

	4 bytes for int
	8 bytes padding
	4 bytes for int
	8 bytes padding
	4 bytes for int
	8 bytes padding
	and then some more
	*/

_____

	/* Assessment of the problem:
	- Array stride is 0 with -O1. Segfault with -O2. It seems like it fails on returning.
	- Test homebrew clang (it should be more recent) to see if it behaves in the same way.
	- Hm, trouble with `softwareupdate --list`; no new updates
	- Maybe I ran out of stack space? Probably not, but it could be.
	*/

_____


// TODO: to excluded
static void query_info_about_uniform_buffer(
	const GLuint shader_using_uniform_block, const buffer_size_t num_subvars, const GLuint* const subvar_indices,

	GLint* const subvar_byte_offsets, GLint* const array_stride, GLint* const matrix_stride) {

	glGetActiveUniformsiv(shader_using_uniform_block, (GLsizei) num_subvars, subvar_indices, GL_UNIFORM_OFFSET, subvar_byte_offsets);
	glGetActiveUniformsiv(shader_using_uniform_block, (GLsizei) num_subvars, subvar_indices, GL_UNIFORM_ARRAY_STRIDE, array_stride);
	glGetActiveUniformsiv(shader_using_uniform_block, (GLsizei) num_subvars, subvar_indices, GL_UNIFORM_MATRIX_STRIDE, matrix_stride);
}

_____

// TODO: to excluded
static void copy_array_of_strings(const GLchar* const* const ptrs_to_strings, const buffer_size_t num_strings) {
	buffer_size_t total_length = 0;
	for (buffer_size_t i = 0; i < num_strings; i++) total_length += strlen(ptrs_to_strings[i]);

	DEBUG(total_length, u);

	GLchar* const char_buffer = malloc(sizeof(total_length));

	GLchar* curr_dest = char_buffer;
	for (buffer_size_t i = 0; i < num_strings; i++) {
		// strcpy(char_buffer)
		const GLchar* const curr_string = ptrs_to_strings[i];
		const buffer_size_t string_length = strlen(curr_string);
	}
}

_____

	/*
	- Awesome, this works now, mostly
	- 1. Figure out how to handle bigger types, like structs, too (and arrays of matrices)
	- 2. I can now write a function for arrays
	- 3. Find out if the matrix padding is only for 4x4 matrices
	- 3. Write a function for matrices too (`write_matrix_to_uniform_buffer`)
	- 4. Write a function for an array of matrices

	- For structs with possible sub-structs and matrices in them, the problem becomes infinitely complex
	- Actually, with structs, it should be okay, since they're only filled in by their components
	- Perhaps just return a pointer to the start of the memory, so that the client can copy over their data if needed
	*/

	/*
	const vec3 data[] = {{1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}};

	byte* const gpu_data = shading_params -> gpu_memory_mapping;

	const GLint array_stride = shading_params -> array_stride;
	DEBUG(array_stride, d);

	byte dest_offset = 0;
	for (int i = 0; i < (int) ARRAY_LENGTH(data); i++) {
		printf("Copying to dest byte offset of %u\n", dest_offset);
		memcpy(gpu_data + dest_offset, data + i, sizeof(*data));
		dest_offset += array_stride;
	}
	*/

	// gpu_data[8] = 1; // This made it work

_____ For debugging:

DEBUG = -O2 -g -fsanitize=address,undefined

_____

/* Given an array of strings, along with a string count, this copies that buffer like this:
	1. It finds the total number of char bytes in the string array.
	2. It creates a contiguous buffer to store all of those bytes.
	3. It creates a pointer buffer that stores the beginning of each string in that buffer.
	4. It fills up the character buffer and the character pointer buffer.

To free this string array, you just have to 1. free the byte buffer by saying `free(*string_array)`,
and then 2. saying `free(string_array)` to free the pointer buffer.  */
static GLchar** copy_array_of_strings(const GLchar* const* const string_array, const buffer_size_t num_strings) {
	buffer_size_t total_char_count = 0;

	for (buffer_size_t i = 0; i < num_strings; i++)
		total_char_count += strlen(string_array[i]) + 1; // 1 extra for the null terminator

	GLchar
		*const char_buffer = malloc(total_char_count * sizeof(GLchar)),
		**const char_ptr_buffer = malloc(num_strings * sizeof(GLchar*));

	GLchar* curr_dest = char_buffer;
	for (buffer_size_t i = 0; i < num_strings; i++) {
		const GLchar* const curr_string = string_array[i];

		strcpy(curr_dest, curr_string);
		char_ptr_buffer[i] = curr_dest;
		curr_dest += strlen(curr_string) + 1;
	}

	return char_ptr_buffer;
}

_____

	GLchar** subvar_names = buffer -> subvar_names;
	free(*subvar_names);
	free(subvar_names);

_____

// TODO: from excluded
static buffer_size_t get_subvar_index(const UniformBuffer* const buffer, const GLchar* const subvar_name) {
	byte* const gpu_memory_mapping = buffer -> gpu_memory_mapping;

	if (gpu_memory_mapping == NULL) FAIL(InitializeShaderUniform, "Cannot write subvar '%s'"
		" to uniform buffer because writing batch is not enabled", subvar_name
	);

	const buffer_size_t num_subvars = buffer -> num_subvars;
	const GLchar* const* const subvar_names = buffer -> subvar_names;

	for (buffer_size_t i = 0; i < num_subvars; i++) {
		if (!strcmp(subvar_name, subvar_names[i])) return i;
	}

	FAIL(InitializeShaderUniform,
		"Could not locate subvar '%s' within uniform block '%s'",
		subvar_name, buffer -> block_name
	);
}

_____

	const vec3 test_colors[5] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}, {1, 1, 1}};

	write_array_of_primitives_to_uniform_buffer(shading_params, "test_colors", (List) {
		.data = (void*) test_colors, .item_size = sizeof(vec3), .length = ARRAY_LENGTH(test_colors)
	});

_____

	// TODO: try initing/writing to/deiniting another uniform buffer to test if state changes are encapsulated correctly
	UniformBuffer u2 = init_uniform_buffer(false, "UBO2", 1, scene_context.sector_context.draw_context.shader, (const GLchar* const[]) {"colors"}, 1);

	enable_uniform_buffer_writing_batch(&u2);
	const vec3 colors[3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
	write_array_of_primitives_to_uniform_buffer(&u2, "colors", (List) {.data = (void*) colors, .item_size = sizeof(vec3), .length = ARRAY_LENGTH(colors)});
	disable_uniform_buffer_writing_batch(&u2);

	bind_uniform_buffer_to_shader(&u2, scene_context.sector_context.draw_context.shader);

_____

void init_batch_draw_context_gpu_buffer(BatchDrawContext* const draw_context,
	const buffer_size_t num_drawable_things, const buffer_size_t drawable_thing_size) {

	const GLuint gpu_buffer = init_gpu_buffer();
	use_vertex_buffer(gpu_buffer);
	glBufferData(GL_ARRAY_BUFFER, num_drawable_things * drawable_thing_size, NULL, GL_DYNAMIC_DRAW);
	draw_context -> buffers.gpu = gpu_buffer;
}

_____

/*
static buffer_size_t fill_sector_vertex_buffer_with_visible_faces(
	const BatchDrawContext* const draw_context,
	const List* const sectors, const vec4* const frustum_planes) {

	use_vertex_buffer(draw_context -> buffers.gpu);

	const Sector* const sector_data = sectors -> data;
	const Sector* const out_of_bounds_sector = sector_data + sectors -> length;

	const face_mesh_component_t* const face_meshes_cpu = draw_context -> buffers.cpu.data;
	face_mesh_component_t* const face_meshes_gpu = init_mapping_for_culled_batching(draw_context);
	buffer_size_t num_visible_faces = 0;

	const buffer_size_t components_per_face = 24; // TODO: make this a constant
	const buffer_size_t bytes_per_face = 24; // TODO: make this a constant

	for (const Sector* sector = sector_data; sector < out_of_bounds_sector; sector++) {
		buffer_size_t num_visible_faces_in_group = 0;
		const buffer_size_t cpu_buffer_start_index = sector -> face_range.start * components_per_face;

		while (sector < out_of_bounds_sector && sector_in_view_frustum(*sector, frustum_planes))
			num_visible_faces_in_group += sector++ -> face_range.length;
		
		if (num_visible_faces_in_group != 0) {
			printf("Copying over %u faces\n", num_visible_faces_in_group);

			memcpy(face_meshes_gpu + num_visible_faces * components_per_face,
				face_meshes_cpu + cpu_buffer_start_index,
				num_visible_faces_in_group * bytes_per_face);

			num_visible_faces += num_visible_faces_in_group;
		}
	}

	glUnmapBuffer(GL_ARRAY_BUFFER); // If looking out at the distance with no sectors, why do any state switching at all?
	return num_visible_faces;
}
*/

_____

typedef void (*const aabb_creator_t) (const byte* const cullable, vec3 aabb[2]);
typedef buffer_size_t (*const renderable_index_getter_t) (const byte* const cullable, const byte* const first_cullable);
typedef buffer_size_t (*const num_renderable_getter_t) (const byte* const cullable);

_____

////////// These functions are for frustum culling

static void make_aabb(const byte* const typeless_sector, vec3 aabb[2]) {
	const Sector sector = *(Sector*) typeless_sector;

	GLfloat *const min = aabb[0], *const max = aabb[1];

	min[0] = sector.origin[0];
	min[1] = sector.visible_heights.min;
	min[2] = sector.origin[1];

	max[0] = min[0] + sector.size[0];
	max[1] = min[1] + sector.visible_heights.max - sector.visible_heights.min;
	max[2] = min[2] + sector.size[1];
}

static buffer_size_t get_renderable_index_from_cullable(const byte* const typeless_sector, const byte* const typeless_first_sector) {
	(void) typeless_first_sector;
	return ((Sector*) typeless_sector) -> face_range.start;
}

static buffer_size_t get_num_renderable_from_cullable(const byte* const typeless_sector) {
	return ((Sector*) typeless_sector) -> face_range.length;
}

_____

void* init_mapping_for_culled_batching(const BatchDrawContext* const draw_context) {
	const List* const cpu_buffer = &draw_context -> buffers.cpu;
	const GLsizeiptr num_bytes = cpu_buffer -> length * cpu_buffer -> item_size;
	const GLbitfield access_flags = GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT;

	/* Flags, explained:
	1. Write only (only writing from cpu to gpu buffer, no other operations).
	2. Whole previous contents of buffer can be discarded, since the batch is written from scratch each time.
	Note: GL_MAP_UNSYNCHRONIZED_BIT is not used because previous GPU commands may depend on the buffer contents. */

	return glMapBufferRange(GL_ARRAY_BUFFER, 0, num_bytes, access_flags);
}

_____

	/*
	vec3 test_vec = {0.0f, 1.0f, 0.0f};
	test_vec[0] = 
	*/

	/*
	vec3 test_vec = {0.0f, 1.0f, 0.0f};
	glm_vec3_rotate(test_vec, camera -> angles.hori, (vec3) {1.0f, 0.0f, 0.0f});
	DEBUG_VEC3(test_vec);
	*/

_____

	vec3 face_normal;
	glm_vec3_cross(GLM_YUP, (vec3) {right_xz[0], 0.0f, right_xz[1]}, face_normal);
	glm_vec3_negate(face_normal);

_____

	////////// A little rotation test

	/*
	const vec2 dir_xz = {right_xz[1], -right_xz[0]};
	DEBUG_VEC2(dir_xz);
	*/

	//////////

_____

	float theta = -hori_angle;
	// vec3 v = tangent_space_normal;

	vec2 v = ts_normal.xz;

	float x_prime = v.x * cos(theta) - v.y * sin(theta);
	float z_prime = v.x * sin(theta) + v.y * cos(theta);

	vec3 result = vec3(-x_prime, ts_normal.y, -z_prime);

	//////////

	vec3 cmp = vec3(
		ts_normal.x * right_xz.x - ts_normal.z * right_xz.y,
		ts_normal.y,
		ts_normal.x * right_xz.y + ts_normal.z * right_xz.x
	);
	// if (branch) return cmp;

	branch;
	float diff = length(cmp - result);
	if (diff < 0.000001f) equivalent = true;
	else equivalent = false;

_____

	vec3 face_normal = vec3(-right_xz.y, 0.0f, right_xz.x);

_____

sdl_pixel_component_t r, g, b, a; SDL_GetRGBA(*(sdl_pixel_t*) read_surface_pixel(src, x, y), format, &r, &g, &b, &a); if (a == 0) continue;

_____

	/*
	const struct {
		const struct {const bool apply; const signed_byte radius; const GLfloat std_dev;} blur;
		const GLfloat intensity;
	} normal_mapping;
	*/

	// .normal_mapping = {.blur = {.apply = true, .radius = 2, .std_dev = 0.8f}, .intensity = 1.1f /* 0.25f before */},

_____

	DEBUG(diffuse_texture_set, u);
	if (diffuse_texture_set == 1) SDL_SaveBMP(general_purpose_surface_2, "../out.bmp");

_____

	/*
	- hm I don't have a model matrix
	- perhaps calculate them on the cpu
	- face order: 

	bl, br, tl, tr

	tangents across a face will always be the same, like with the normal
	(perhaps compute the tbn on the cpu later)
	*/

	col = cols[gl_VertexID];

	/*
	vec3 tangent = tangents[gl_VertexID];
	vec3 bitangent = cross(tangent, face_normal);
	tbn = mat3(tangent, cross(tangent, face_normal), face_normal);
	*/

_____

// tangent goes in the direction of uv coordinates
/*
const vec3 tangents[CORNERS_PER_QUAD] = vec3[CORNERS_PER_QUAD](
	vec3(1, 0, 0), vec3(1, 0, 0), vec3(1, 0, 0), vec3(1, 0, 0)
);
*/

/*
bl = red, br = green, tl = blue, tr = black
*/

_____

out vec3 col;
const vec3 cols[4] = vec3[](vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), vec3(1,1,1));

_____

	const vec3* const world_corners = typed_params.weapon_sprite -> appearance_context.world_space.corners;

	#define vset(index, a, b, c) glm_vec3_copy((vec3) {a, b, c}, (GLfloat*) world_corners[index])
	// vset(0, 5.0f, 0.0, 4.0f); vset(2, 5.0f, 1.0, 4.0f); vset(1, 4.0f, 0.0, 4.0f); vset(3, 4.0f, 1.0, 4.0f);

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	// int inds[] = {3, 2, 0, 1};
	// int* inds = keys[SDL_SCANCODE_C] ? (int[]) {3, 2, 0, 1} : (int[]) {1, 0, 2, 3};
	// int* inds = keys[SDL_SCANCODE_C] ? (int[]) {3, 1, 2, 0} : (int[]) {1, 0, 2, 3};
	/*
	int inds[] = {1, 0, 2, 3};
	// int inds[] = {3, 0, 2, 1};

	// int inds[] = {0, 3, 1, 2};

	if (keys[SDL_SCANCODE_C]) swap(inds + 0, inds + 3);

	vset(inds[0], 4.0f, 3.0, 4.0f); vset(inds[1], 5.0f, 3.0, 4.0f); vset(inds[2], 5.0f, 3.0, 5.0f); vset(inds[3], 4.0f, 3.0, 5.0f);
	#undef vset
	*/

	///// Tangent stuff

	// order: bl, br, tl, tr.

_____

	vec3 bl_br, br_tl, tl_tr, tr_bl;

	#define TAN_DEF(name, from, to)\
		glm_vec3_sub((GLfloat*) world_corners[to], (GLfloat*) world_corners[from], name);\
		glm_vec3_normalize(name);
	
	// test in one more orientation
	
	// triangles drawn: <bl, br, tl>, <br, tl, tr>

	TAN_DEF(bl_br, 0, 1);
	TAN_DEF(br_tl, 1, 2);
	TAN_DEF(tl_tr, 2, 3);
	TAN_DEF(tr_bl, 3, 0);

	vec3 all_of_em[corners_per_quad];
	glm_vec3_copy(bl_br, all_of_em[0]); glm_vec3_copy(br_tl, all_of_em[1]);
	glm_vec3_copy(tl_tr, all_of_em[2]); glm_vec3_copy(tr_bl, all_of_em[3]);

	/*
	7: yes.
	8: no.
	_: _.
	_: _.
	*/
	glm_vec3_negate(all_of_em[0]);
	const SDL_Scancode k[] = {SDL_SCANCODE_8, SDL_SCANCODE_9, SDL_SCANCODE_0};
	for (int i = 0; i < ARRAY_LENGTH(k); i++) {
		if (keys[k[i]]) {glm_vec3_negate(all_of_em[i]);} // do neg
	}

	UPDATE_UNIFORM(tangents, 3fv, corners_per_quad, (GLfloat*) all_of_em);

	#undef TAN_DEF

	/////

_____

	// order: bl, br, tl, tr.

_____

	if (!SDL_GetKeyboardState(NULL)[SDL_SCANCODE_M]) return;

_____

	const int p = 1, n = 0;
	INIT_UNIFORM_VALUE(signs, shader, 3fv, 1,
		(vec3) {keys[SDL_SCANCODE_8] ? p : n, keys[SDL_SCANCODE_9] ? p : n, keys[SDL_SCANCODE_0] ? p : n}	
	);

_____

	// Check that the tbn converted normal equals the same thing
	// if (branch) normal = face_normal;

	/*
	float diff = distance(normal, face_normal);
	if (diff > 0.000001f) {
		color.rgb = vec3(1,0,0);
		color.a = texture_color.a;
		return;
	}
	*/

_____

	/*
	int next_ind = (gl_VertexID == 3) ? 0 : (gl_VertexID + 1);
	vec3 tangent = normalize(world_corners[next_ind] - world_corners[gl_VertexID]);
	*/
	// if (gl_VertexID == 0) tangent = -tangent;

	// currently: top left flipped, bottom left flipped, 

_____

vset(0, 5.0f, 3.0, 5.0f); vset(2, 5.0f, 3.0, 4.0f); vset(1, 4.0f, 0.0, 4.0f); vset(3, 4.0f, 1.0, 4.0f); // first vertical case

_____

	/*
	#define vset(index, a, b, c) glm_vec3_copy((vec3) {a, b, c}, (GLfloat*) world_corners[index])
	vset(0, 5.0f, 0.0, 4.0f); vset(2, 5.0f, 1.0, 4.0f); vset(1, 4.0f, 0.0, 4.0f); vset(3, 4.0f, 1.0, 4.0f); // first vertical case
	#undef vset
	*/

_____

	const GLfloat rot_angle = camera -> angles.vert;
	GLfloat* const axis = GLM_ZUP; // TODO: add back the const qualifier

	GLfloat *const top_left = world_corners[2], *const top_right = world_corners[3];
	glm_vec3_rotate(top_left, rot_angle, axis);
	glm_vec3_rotate(top_right, rot_angle, axis);

	/////
	const GLfloat the_size = glm_vec3_distance(world_corners[0], world_corners[2]);
	DEBUG_FLOAT(the_size);

_____


	// bl, br, tl, tr
	// const GLfloat the_size = glm_vec3_distance(world_corners[0], world_corners[2]);

	/*
	const GLfloat rot_angle = camera -> angles.vert;
	GLfloat* const axis = GLM_ZUP; // TODO: add back the const qualifier

	GLfloat *const top_left = world_corners[2], *const top_right = world_corners[3];
	glm_vec3_rotate(top_left, rot_angle, axis);
	glm_vec3_rotate(top_right, rot_angle, axis);

	/////
	const GLfloat the_size = glm_vec3_distance(world_corners[0], world_corners[2]);
	DEBUG_FLOAT(the_size);
	*/

_____

	if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_C]) return;

_____

float get_average_occluder_depth(const int sample_radius, const uint layer_index, const vec3 UV) {
	float average_occluder_depth = 0.0f;
	vec2 texel_size = 1.0f / textureSize(shadow_cascade_sampler, 0).xy;

	int ao_accum = 0;
	float center_depth = texture(shadow_cascade_sampler, vec3(UV.xy, layer_index)).r;

	for (int y = -sample_radius; y <= sample_radius; y++) {
		for (int x = -sample_radius; x <= sample_radius; x++) {
			vec3 sample_UV = vec3(texel_size * vec2(x, y) + UV.xy, layer_index);
			float occluder_depth = texture(shadow_cascade_sampler, sample_UV).r;

			average_occluder_depth += occluder_depth;

			ao += float(occluder_depth - 0.01f >= center_depth);
		}
	}

	int samples_across = (sample_radius << 1) + 1;
	float one_over_num_samples = 1.0f / (samples_across * samples_across);

	ao *= one_over_num_samples;

	return average_occluder_depth * one_over_num_samples;
}

_____

float get_average_occluder_depth(const int sample_radius, const uint layer_index, const vec2 UV) {
	float average_occluder_depth = 0.0f;
	vec2 texel_size = 1.0f / textureSize(shadow_cascade_sampler, 0).xy;

	for (int y = -sample_radius; y <= sample_radius; y++) {
		for (int x = -sample_radius; x <= sample_radius; x++) {
			vec3 sample_UV = vec3(fma(texel_size, vec2(x, y), UV), layer_index);
			average_occluder_depth += texture(shadow_cascade_sampler, sample_UV).r;
		}
	}

	int samples_across = (sample_radius << 1) + 1;
	return average_occluder_depth / (samples_across * samples_across);
}

//////////

bool bad = false;

_____


	// TODO: accomplish this same task using some swizzle and sign masks

	/*
	flat:
		index mask: (0, 2, 1)
	right:
		index mask: (2, 1, 0)
	bottom:
		index mask: (0, 1, 2)
	left:
		index mask: ()
	top:
	*/


_____ LSAO without blending:

float ao(const float world_depth_value) {
	const int sample_radius = 15;
	const float bias = 0.05f;

	uint layer_index = 0;
	while (layer_index < NUM_CASCADE_SPLITS && cascade_split_distances[layer_index] <= world_depth_value) layer_index++;

	vec3 fragment_pos_light_space = (light_view_projection_matrices[layer_index] * vec4(fragment_pos_world_space, 1.0f)).xyz * 0.5f + 0.5f;

	float center_depth = texture(shadow_cascade_sampler, vec3(fragment_pos_light_space.xy, layer_index)).r;
	vec2 texel_size = 1.0f / textureSize(shadow_cascade_sampler, 0).xy;

	float ao_term = 0.0f;

	for (int y = -sample_radius; y <= sample_radius; y++) {
		for (int x = -sample_radius; x <= sample_radius; x++) {
			vec3 sample_UV = vec3(fma(texel_size, vec2(x, y), fragment_pos_light_space.xy), layer_index);
			float sample_depth = texture(shadow_cascade_sampler, sample_UV).r;
			ao_term += float(sample_depth + bias > center_depth);
		}
	}

	int samples_across = (sample_radius << 1) + 1;
	return ao_term / (samples_across * samples_across);
}

//////////

void main(void) {
	face_id; UV; UV_translation; UV_translation_area; environment_map_sampler; diffuse_sampler; normal_map_sampler;

	vec3 t = texture(diffuse_sampler, UV).rgb;
	color.rgb = vec3(ao(world_depth_value) * get_csm_shadow(world_depth_value, fragment_pos_world_space)) * t;

	/*
	vec3 translated_UV = retranslate_UV(UV);

	vec3
		texture_color = texture(diffuse_sampler, translated_UV).rgb,
		fragment_normal = get_face_fragment_normal(translated_UV);

	color = calculate_light(world_depth_value, texture_color, fragment_normal);
	color = postprocess_light(translated_UV.xy, color);
	*/
}

_____

// `TC` = texture creation
typedef enum {
	TC_Nearest = 1,
	TC_Linear = 2,
	TC_LinearMipmapped = 4,
	TC_Trilinear = 8,

	TC_2D = 16,
	TC_Array2D = 32,
	TC_Skybox = 64,

	TC_Repeating = 128,
	TC_EdgeClamped = 256
} TextureCreationParam;

_____

	#define LIGHTING_UNIFORM(param, prefix) INIT_UNIFORM_VALUE(param, shader, prefix, constants.lighting.param)
	#define ARRAY_LIGHTING_UNIFORM(param, prefix) INIT_UNIFORM_VALUE(param, shader, prefix, 1, constants.lighting.param)

_____

leak_track: $(BIN_DIR)/$(OUT)
	cd bin && leaks -atExit -- ./dungeon_dave && cd ..

_____

	ON_FIRST_CALL(atexit(memory_report););

	//////////

	bool keep_it = false;
	for (int i = 0; i < ARRAY_LENGTH(keep); i++) {
		if (!strcmp(function, keep[i])) {keep_it = true; break;}
	}
	if (!keep_it) return malloc(num_bytes);

_____

	bool keep_it = false;
	for (int i = 0; i < ARRAY_LENGTH(keep); i++) {
		if (!strcmp(function, keep[i])) {keep_it = true; break;}
	}
	if (!keep_it) {free(memory); return;}

_____

static const char* const keep[] = {"init_shader"};

_____

#ifdef TRACK_MEMORY

#undef malloc
#undef free

/* Narrowing it down:
pair: init_uniform_buffer, deinit_uniform buffer. Good.
*/

static unsigned num_mallocs = 0, num_frees = 0;

static void memory_report(void) {
	printf("Memory report: %u mallocs, and %u frees.\n", num_mallocs, num_frees);
}

#define streq(a, b) !strcmp(a, b)

void* tracking_malloc(const size_t num_bytes, const char* const file, const char* const function, const unsigned line) {
	ON_FIRST_CALL(atexit(memory_report););

	// if (!streq(function, "init_uniform_buffer")) return malloc(num_bytes);
	if (!streq(function, "init_list")) return malloc(num_bytes);

	void* const memory = malloc(num_bytes);
	printf("Allocating %zu bytes in `%s` (line %u in %s), at address %p\n", num_bytes, function, line, file, memory);
	num_mallocs++;
	return memory;
}

void tracking_free(void* const memory, const char* const file, const char* const function, const unsigned line) {
	// if (!streq(function, "deinit_uniform_buffer") && !streq(function, "init_uniform_buffer")) {free(memory); return;}
	if (!streq(function, "deinit_list")) {free(memory); return;}

	printf("Freeing %p in `%s` (line %u in %s)\n", memory, function, line, file);
	num_frees++;
	free(memory);
}

#endif

_____

void* tracking_malloc(const size_t num_bytes, const char* const file, const char* const function, const unsigned line);
void tracking_free(void* const memory, const char* const file, const char* const function, const unsigned line);

#define malloc(num_bytes) tracking_malloc((num_bytes), __FILE__, __FUNCTION__, __LINE__)
#define free(memory) tracking_free((memory), __FILE__, __FUNCTION__, __LINE__)

#endif

_____

########## Defining various compiler details, like optimization, debug mode, and warnings

CC = clang

OPTIMIZE = -Ofast
DEBUG = -O0 -g -fsanitize=address,undefined,float-divide-by-zero,unsigned-integer-overflow,implicit-conversion
BUILD_TYPE = $(OPTIMIZE)

CONVERSION_WARNINGS = -Wfloat-conversion -Wdouble-promotion -Wsign-conversion\
	-Wimplicit-int-conversion -Wshorten-64-to-32 -Wincompatible-pointer-types

WARNINGS = -Wall -Wextra -Wpedantic -Wformat $(CONVERSION_WARNINGS)

CFLAGS := `pkg-config --cflags sdl2` -std=c99 $(WARNINGS)
NON_GL_LDFLAGS := -lm -ldl `pkg-config --libs sdl2`

##########

ifeq ($(shell uname), Darwin) # If on MacOS
	GL_LDFLAGS = -framework OpenGL
else
	GL_LDFLAGS = -lGL
endif

########## Rules

.PHONY: all clean

OUT = dungeon_dave

SRC_DIR = src
HEADER_DIR = $(SRC_DIR)/headers
OBJ_DIR = obj
BIN_DIR = bin
GLAD_DIR = include/glad

OBJS := $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(wildcard $(SRC_DIR)/*.c))

########## Rules for the main project

all: $(BIN_DIR)/$(OUT)
	cd bin && ./$(OUT) && cd ..

$(BIN_DIR)/$(OUT): $(OBJS) $(OBJ_DIR)/glad.o
	$(CC) $(BUILD_TYPE) $(NON_GL_LDFLAGS) $(GL_LDFLAGS) -o $@ $^

$(OBJ_DIR)/glad.o: $(GLAD_DIR)/*
	$(CC) -c $(BUILD_TYPE) $(CFLAGS) -o $@ $(GLAD_DIR)/glad.c

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c $(HEADER_DIR)/%.h
	$(CC) -c $(BUILD_TYPE) $(CFLAGS) -o $@ $(SRC_DIR)/$*.c

########## The rule for the editor + the clean rule

editor:
	$(CC) $(BUILD_TYPE) $(CFLAGS) $(NON_GL_LDFLAGS) -o $(BIN_DIR)/editor $(SRC_DIR)/editor/editor.c
	cd $(BIN_DIR) && ./editor

clean:
	rm $(OBJ_DIR)/*.o $(BIN_DIR)/*

_____

	/*
	alloc_count_t memory_status_number;
	const char* memory_status;

	if (total_allocations > num_deallocs) {
		memory_status_number = total_allocations - num_deallocs;
		final_status = (memory_status_number == 1) ? "memory block was leaked" : "memory blocks were leaked";
	}
	else if (num_deallocs > total_allocations) {
		memory_status_number = num_deallocs - total_allocations;
		final_status = (memory_status_number == 1) ? "memory block was mistakenly freed" : "memory blocks were mistakenly freed";
	}
	*/

_____

	/*
	mat4 view_projection;
	glm_mat4_copy((vec4*) param, view_projection);
	glm_vec4_zero(view_projection[3]); // This clears x, y, z, and w

	UPDATE_UNIFORM(view_projection, Matrix4fv, 1, GL_FALSE, &view_projection[0][0]);
	*/

_____

// TODO: remove this once Drawable is done
GLuint init_vertex_spec(void) {
	GLuint vertex_spec;
	glGenVertexArrays(1, &vertex_spec);
	return vertex_spec;
}

// TODO: remove this too once Drawable is done
GLuint init_gpu_buffer(void) {
	GLuint gpu_buffer;
	glGenBuffers(1, &gpu_buffer);
	return gpu_buffer;
}

_____

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	INIT_SHADER_BRANCH(shader, branch, G);

_____

	const struct {const GLfloat brightness_repeat_secs, min_brightness;} title_screen;
	.title_screen = {.brightness_repeat_secs = 0.5f, .min_brightness = 0.7f},

_____

const GLfloat
		min = constants.title_screen.min_brightness,
		time_seed = typed_params.curr_time_secs / constants.title_screen.brightness_repeat_secs;

	const GLfloat brightness = (sinf(time_seed * PI) * 0.5f + 0.5f) * (1.0f - min) + min;

	ON_FIRST_CALL(UPDATE_UNIFORM(brightness, 1f, brightness););

	if (keys[SDL_SCANCODE_C]) UPDATE_UNIFORM(brightness, 1f, brightness);

_____

	GLint palace_city_size[2];
	glGetTexLevelParameteriv(TexPlain, 0, GL_TEXTURE_WIDTH, palace_city_size);
	glGetTexLevelParameteriv(TexPlain, 0, GL_TEXTURE_HEIGHT, palace_city_size + 1);
	const GLfloat ratio = (GLfloat) palace_city_size[0] / palace_city_size[1];
	DEBUG_FLOAT(ratio);

_____

// TODO: define these as macros
const float edge_threshold_min = 0.0312f, edge_threshold_max = 0.125f;

float rgb2luma(vec3 rgb) {
	return sqrt(dot(rgb, vec3(0.299f, 0.587f, 0.114f)));
}

_____

	// color = texture(frame_texture, UV);

	vec3 colorCenter = texture(frame_texture,UV).rgb;

	// Luma at the current fragment
	float lumaCenter = rgb2luma(colorCenter);

	// Luma at the four direct neighbours of the current fragment.
	float lumaDown = rgb2luma(textureOffset(frame_texture,UV,ivec2(0,-1)).rgb);
	float lumaUp = rgb2luma(textureOffset(frame_texture,UV,ivec2(0,1)).rgb);
	float lumaLeft = rgb2luma(textureOffset(frame_texture,UV,ivec2(-1,0)).rgb);
	float lumaRight = rgb2luma(textureOffset(frame_texture,UV,ivec2(1,0)).rgb);

	// Find the maximum and minimum luma around the current fragment.
	float lumaMin = min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));
	float lumaMax = max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));

	// Compute the delta.
	float lumaRange = lumaMax - lumaMin;

	// If the luma variation is lower that a threshold (or if we are in a really dark area), we are not on an edge, don't perform any AA.
	if(lumaRange < max(edge_threshold_min,lumaMax*edge_threshold_max)){
	    color = colorCenter;
	    return;
	}

_____ A box filter:

	const int sample_radius = 10;

	vec3 sum = vec3(0.0f);
	vec2 ts = 1.0f / textureSize(frame_texture, 0);

	for (int y = -sample_radius; y <= sample_radius; y++) {
		for (int x = -sample_radius; x <= sample_radius; x++) {
			vec2 sample_offset = ts * vec2(x, y);
			sum += texture(frame_texture, UV + sample_offset).rgb;
		}
	}

	const int samples_per_row = (sample_radius << 1) + 1;
	color = sum / (samples_per_row * samples_per_row);
	return;

_____

vec2 uv = UV * textureSize(frame_texture, 0);
#define tex frame_texture

#if 1
vec2 border = .5 * fwidth(uv);
#else
vec2 border = vec2(.5 * small_screen_size / big_screen_size);
#endif

vec2 uvf = fract(uv);

// the main color of the texel, assuming we're not at a border
vec4 col = texelFetch(tex, ivec2(uv), 0);

vec4 xcol = col;
if (uvf.x < border.x)
    xcol = mix(texelFetchOffset(tex, ivec2(uv), 0, ivec2(-1, 0)), col, uvf.x / border.x);
else if (1. - uvf.x < border.x)
    xcol = mix(texelFetchOffset(tex, ivec2(uv), 0, ivec2(1, 0)), col, (1. - uvf.x) / border.x);

vec4 ycol = col;
if (uvf.y < border.y)
    ycol = mix(texelFetchOffset(tex, ivec2(uv), 0, ivec2(0, -1)), col, uvf.y / border.y);
else if (1. - uvf.y < border.y)
    ycol = mix(texelFetchOffset(tex,  ivec2(uv), 0, ivec2(0, 1)), col, (1. - uvf.y) / border.y);

color = vec3(mix(xcol, ycol, .5));
return;

_____ Some older, sorta-working FXAA code:

	#define u_colorTexture frame_texture
	#define v_texCoord UV
	#define u_fxaaOn true
	#define fragColor color
	#define u_lumaThreshold 0.5f
	#define u_mulReduce (1.0f / 8.0f)
	#define u_minReduce (1.0f / 128.0f)
	#define u_maxSpan 8.0f
	vec2 u_texelStep = 1.0f / textureSize(frame_texture, 0);
	#define u_showEdges false

	vec3 rgbM = texture(u_colorTexture, v_texCoord).rgb;

	// Possibility to toggle FXAA on and off.
	if (!u_fxaaOn) {
		fragColor = rgbM;
		return;
	}

	// Sampling neighbour texels. Offsets are adapted to OpenGL texture coordinates. 
	vec3
		rgbNW = textureOffset(u_colorTexture, v_texCoord, ivec2(-1, 1)).rgb,
		rgbNE = textureOffset(u_colorTexture, v_texCoord, ivec2(1, 1)).rgb,
		rgbSW = textureOffset(u_colorTexture, v_texCoord, ivec2(-1, -1)).rgb,
		rgbSE = textureOffset(u_colorTexture, v_texCoord, ivec2(1, -1)).rgb;

	// see http://en.wikipedia.org/wiki/Grayscale
	const vec3 toLuma = vec3(0.299f, 0.587f, 0.114f);
	
	// Convert from RGB to luma.
	float
		lumaNW = dot(rgbNW, toLuma), lumaNE = dot(rgbNE, toLuma),
		lumaSW = dot(rgbSW, toLuma), lumaSE = dot(rgbSE, toLuma),
		lumaM = dot(rgbM, toLuma);

	// Gather minimum and maximum luma.
	float
		lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE))),
		lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
	
	// If contrast is lower than a maximum threshold ...
	if (lumaMax - lumaMin <= lumaMax * u_lumaThreshold) {
		// ... do no AA and return.
		color = rgbM;
		return;
	}  
	
	// Sampling is done along the gradient.
	vec2 samplingDirection = vec2(
		-((lumaNW + lumaNE) - (lumaSW + lumaSE)),
		((lumaNW + lumaSW) - (lumaNE + lumaSE))
	);
	
	// Sampling step distance depends on the luma: The brighter the sampled texels, the smaller the final sampling step direction.
	// This results, that brighter areas are less blurred/more sharper than dark areas.  
	float samplingDirectionReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25f * u_mulReduce, u_minReduce);

	// Factor for norming the sampling direction plus adding the brightness influence. 
	float minSamplingDirectionFactor = 1.0 / (min(abs(samplingDirection.x), abs(samplingDirection.y)) + samplingDirectionReduce);
	
	// Calculate final sampling direction vector by reducing, clamping to a range and finally adapting to the texture size. 
	samplingDirection = clamp(samplingDirection * minSamplingDirectionFactor, vec2(-u_maxSpan), vec2(u_maxSpan)) * u_texelStep;
	
	// Inner samples on the tab.
	vec3
		rgbSampleNeg = texture(u_colorTexture, v_texCoord + samplingDirection * (1.0f / 3.0f - 0.5f)).rgb,
		rgbSamplePos = texture(u_colorTexture, v_texCoord + samplingDirection * (2.0f / 3.0f - 0.5f)).rgb;

	// Outer samples on the tab.
	vec3
		rgbSampleNegOuter = texture(u_colorTexture, v_texCoord + samplingDirection * -0.5f).rgb,
		rgbSamplePosOuter = texture(u_colorTexture, v_texCoord + samplingDirection * 0.5f).rgb;

	vec3 rgbTwoTab = (rgbSamplePos + rgbSampleNeg) * 0.5f;  
	vec3 rgbFourTab = (rgbSamplePosOuter + rgbSampleNegOuter) * 0.25f + rgbTwoTab * 0.5f;   
	
	float lumaFourTab = dot(rgbFourTab, toLuma);
	
	// Are outer samples of the tab beyond the edge ... 
	if (lumaFourTab < lumaMin || lumaFourTab > lumaMax) fragColor = rgbTwoTab; // ... yes, so use only two samples.
	else fragColor = rgbFourTab; // ... no, so use four samples. 

	// Show edges for debug purposes.	
	if (u_showEdges) fragColor.r = 1.0f;

_____

	vUV = UV.xy * textureSize(diffuse_sampler, 0).xy;

_____

	/*
	vec2 va = UV.xy * ts;
	if (distance(vUV, va) > 0.01f) {
		color = vec4(1,0,0,1);
		return;
	}

	// const float k = 0.8f;
	vec2 alpha = k * vec2(dFdx(vUV.x), dFdy(vUV.y));

	vec2 x = fract(vUV);
	vec2 x_ = clamp(0.5f / alpha * x, 0.0f, 0.5f) + clamp(0.5f / alpha * (x - 1.0f) + 0.5f, 0.0f, 0.5f);
	vec2 texCoord = (floor(vUV) + x_) / ts;
	vec3 result = vec3(texCoord, UV.z);

	if (branch) result = UV;
	*/
	vUV; k; branch;
	vec3 result = UV;

	//////////

_____ Some code that didn't really work:

	const float EDGE_THRESHOLD_MIN = 0.0312;
	const float EDGE_THRESHOLD_MAX = 0.125;

	#define ITERATIONS 12
	#define SUBPIXEL_QUALITY 0.75

	#define screenTexture frame_texture

vec3 colorCenter = texture(screenTexture,UV).rgb;

// Luma at the current fragment
float lumaCenter = rgb2luma(colorCenter);

// Luma at the four direct neighbours of the current fragment.
float lumaDown = rgb2luma(textureOffset(screenTexture,UV,ivec2(0,-1)).rgb);
float lumaUp = rgb2luma(textureOffset(screenTexture,UV,ivec2(0,1)).rgb);
float lumaLeft = rgb2luma(textureOffset(screenTexture,UV,ivec2(-1,0)).rgb);
float lumaRight = rgb2luma(textureOffset(screenTexture,UV,ivec2(1,0)).rgb);

// Find the maximum and minimum luma around the current fragment.
float lumaMin = min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));
float lumaMax = max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));

// Compute the delta.
float lumaRange = lumaMax - lumaMin;

// If the luma variation is lower that a threshold (or if we are in a really dark area), we are not on an edge, don't perform any AA.
if(lumaRange < max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){
    color = colorCenter;
    return;
}

//////////////

// Query the 4 remaining corners lumas.
float lumaDownLeft = rgb2luma(textureOffset(screenTexture,UV,ivec2(-1,-1)).rgb);
float lumaUpRight = rgb2luma(textureOffset(screenTexture,UV,ivec2(1,1)).rgb);
float lumaUpLeft = rgb2luma(textureOffset(screenTexture,UV,ivec2(-1,1)).rgb);
float lumaDownRight = rgb2luma(textureOffset(screenTexture,UV,ivec2(1,-1)).rgb);

// Combine the four edges lumas (using intermediary variables for future computations with the same values).
float lumaDownUp = lumaDown + lumaUp;
float lumaLeftRight = lumaLeft + lumaRight;

// Same for corners
float lumaLeftCorners = lumaDownLeft + lumaUpLeft;
float lumaDownCorners = lumaDownLeft + lumaDownRight;
float lumaRightCorners = lumaDownRight + lumaUpRight;
float lumaUpCorners = lumaUpRight + lumaUpLeft;

// Compute an estimation of the gradient along the horizontal and vertical axis.
float edgeHorizontal =  abs(-2.0 * lumaLeft + lumaLeftCorners)  + abs(-2.0 * lumaCenter + lumaDownUp ) * 2.0    + abs(-2.0 * lumaRight + lumaRightCorners);
float edgeVertical =    abs(-2.0 * lumaUp + lumaUpCorners)      + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0  + abs(-2.0 * lumaDown + lumaDownCorners);

// Is the local edge horizontal or vertical ?
bool isHorizontal = (edgeHorizontal >= edgeVertical);

//////////////

// Select the two neighboring texels lumas in the opposite direction to the local edge.
float luma1 = isHorizontal ? lumaDown : lumaLeft;
float luma2 = isHorizontal ? lumaUp : lumaRight;
// Compute gradients in this direction.
float gradient1 = luma1 - lumaCenter;
float gradient2 = luma2 - lumaCenter;

// Which direction is the steepest ?
bool is1Steepest = abs(gradient1) >= abs(gradient2);

// Gradient in the corresponding direction, normalized.
float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2)); 

///////////////////////////

vec2 inverseScreenSize = 1.0f / textureSize(frame_texture, 0);
// Choose the step size (one pixel) according to the edge direction.
float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

// Average luma in the correct direction.
float lumaLocalAverage = 0.0;

if(is1Steepest){
    // Switch the direction
    stepLength = - stepLength;
    lumaLocalAverage = 0.5*(luma1 + lumaCenter);
} else {
    lumaLocalAverage = 0.5*(luma2 + lumaCenter);
}

// Shift UV in the correct direction by half a pixel.
vec2 currentUv = UV;
if(isHorizontal){
    currentUv.y += stepLength * 0.5;
} else {
    currentUv.x += stepLength * 0.5;
}

/////////////////////////////////

// Compute offset (for each iteration step) in the right direction.
vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);
// Compute UVs to explore on each side of the edge, orthogonally. The QUALITY allows us to step faster.
vec2 uv1 = currentUv - offset;
vec2 uv2 = currentUv + offset;

// Read the lumas at both current extremities of the exploration segment, and compute the delta wrt to the local average luma.
float lumaEnd1 = rgb2luma(texture(screenTexture,uv1).rgb);
float lumaEnd2 = rgb2luma(texture(screenTexture,uv2).rgb);
lumaEnd1 -= lumaLocalAverage;
lumaEnd2 -= lumaLocalAverage;

// If the luma deltas at the current extremities are larger than the local gradient, we have reached the side of the edge.
bool reached1 = abs(lumaEnd1) >= gradientScaled;
bool reached2 = abs(lumaEnd2) >= gradientScaled;
bool reachedBoth = reached1 && reached2;

// If the side is not reached, we continue to explore in this direction.
if(!reached1){
    uv1 -= offset;
}
if(!reached2){
    uv2 += offset;
}

/////////////////////////////

// If both sides have not been reached, continue to explore.
if(!reachedBoth){
	float q[12] = float[12](
		// 0.0, 0.0, 0.0, 0.0, 0.0,
		1.0, 1.0, 1.0, 1.0, 1.0,
		1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);
	#define QUALITY(i) q[i]

    for(int i = 2; i < ITERATIONS; i++){
        // If needed, read luma in 1st direction, compute delta.
        if(!reached1){
            lumaEnd1 = rgb2luma(texture(screenTexture, uv1).rgb);
            lumaEnd1 = lumaEnd1 - lumaLocalAverage;
        }
        // If needed, read luma in opposite direction, compute delta.
        if(!reached2){
            lumaEnd2 = rgb2luma(texture(screenTexture, uv2).rgb);
            lumaEnd2 = lumaEnd2 - lumaLocalAverage;
        }
        // If the luma deltas at the current extremities is larger than the local gradient, we have reached the side of the edge.
        reached1 = abs(lumaEnd1) >= gradientScaled;
        reached2 = abs(lumaEnd2) >= gradientScaled;
        reachedBoth = reached1 && reached2;

        // If the side is not reached, we continue to explore in this direction, with a variable quality.
        if(!reached1){
            uv1 -= offset * QUALITY(i);
        }
        if(!reached2){
            uv2 += offset * QUALITY(i);
        }

        // If both sides have been reached, stop the exploration.
        if(reachedBoth){ break;}
    }
}

/////////////////////////////

// Compute the distances to each extremity of the edge.
float distance1 = isHorizontal ? (UV.x - uv1.x) : (UV.y - uv1.y);
float distance2 = isHorizontal ? (uv2.x - UV.x) : (uv2.y - UV.y);

// In which direction is the extremity of the edge closer ?
bool isDirection1 = distance1 < distance2;
float distanceFinal = min(distance1, distance2);

// Length of the edge.
float edgeThickness = (distance1 + distance2);

// UV offset: read in the direction of the closest side of the edge.
float pixelOffset = - distanceFinal / edgeThickness + 0.5;

/////////////////////////////

// Is the luma at center smaller than the local average ?
bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;

// If the luma at center is smaller than at its neighbour, the delta luma at each end should be positive (same variation).
// (in the direction of the closer side of the edge.)
bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) < 0.0) != isLumaCenterSmaller;

// If the luma variation is incorrect, do not offset.
float finalOffset = correctVariation ? pixelOffset : 0.0;

////////////////////////////////

// Sub-pixel shifting
// Full weighted average of the luma over the 3x3 neighborhood.
float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
// Ratio of the delta between the global average and the center luma, over the luma range in the 3x3 neighborhood.
float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);
float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
// Compute a sub-pixel offset based on this delta.
float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;

// Pick the biggest of the two offsets.
finalOffset = max(finalOffset,subPixelOffsetFinal);

////////////////////////////////

// Compute the final UV coordinates.
vec2 finalUv = UV;
if(isHorizontal){
    finalUv.y += finalOffset * stepLength;
} else {
    finalUv.x += finalOffset * stepLength;
}

// Read the color at the new UV coordinates, and use it.
vec3 finalColor = texture(screenTexture,finalUv).rgb;
color = finalColor;

_____ The .c postprocessing code:

#include "rendering/postprocess.h"
#include "data/constants.h"
#include "utils/utils.h"
#include "utils/texture.h"
#include "utils/shader.h"

static const GLenum framebuffer_target = GL_DRAW_FRAMEBUFFER;

////////// Rendering

void begin_postprocessing_capture(const PostprocessBuffer* const buffer) {
	glBindFramebuffer(framebuffer_target, buffer -> framebuffer);
	glClear(GL_DEPTH_BUFFER_BIT); // No color buffer clearing needed
}

void apply_postprocessing_from_capture(const PostprocessBuffer* const buffer) {
	glBindFramebuffer(framebuffer_target, 0);
	glUseProgram(buffer -> postprocess_shader);
	glDrawArrays(GL_TRIANGLE_STRIP, 0, corners_per_quad);
}

////////// Initialization and deinitialization

PostprocessBuffer init_postprocess_buffer(void) {
	// const GLint* const window_size = constants.window.size;
	// const GLint window_size[2] = {1728, 1117};
	const GLint window_size[2] = {1000, 1000};

	/* TODO:
	- Rescale buffers when the window size changes
	- Perhaps don't use a standard OpenGL depth buffer, and just use the one here
	- Put the internal depth format for the depth render buffer in some `constants` struct somewhere, if it's defined
	- See if I can use the default framebuffer's depth buffer, instead of the one right here
	*/

	////////// Making a depth render buffer

	GLuint depth_render_buffer;
	glGenRenderbuffers(1, &depth_render_buffer);
	glBindRenderbuffer(GL_RENDERBUFFER, depth_render_buffer);
	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, window_size[0], window_size[1]);

	////////// Making a frame texture

	const GLuint frame_texture = preinit_texture(TexPlain, TexNonRepeating, TexNearest, TexNearest, true);
	glTexImage2D(TexPlain, 0, OPENGL_FRAMEBUFFER_PIXEL_FORMAT, window_size[0], window_size[1], 0, OPENGL_FRAMEBUFFER_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	////////// Making a framebuffer

	GLuint framebuffer;
	glGenFramebuffers(1, &framebuffer);
	glBindFramebuffer(framebuffer_target, framebuffer);

	glFramebufferRenderbuffer(framebuffer_target, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depth_render_buffer);
	glFramebufferTexture(framebuffer_target, GL_COLOR_ATTACHMENT0, frame_texture, 0);

	glReadBuffer(GL_NONE);

	check_framebuffer_completeness();
	glBindFramebuffer(framebuffer_target, 0);

	////////// Binding the frame texture to the shader

	const GLuint shader = init_shader(ASSET_PATH("shaders/postprocess.vert"), NULL, ASSET_PATH("shaders/postprocess.frag"));
	glUseProgram(shader);
	use_texture(frame_texture, shader, "frame_texture", TexPlain, TU_PostProcessBuffer);

	return (PostprocessBuffer) {framebuffer, depth_render_buffer, frame_texture, shader};
}

void deinit_postprocess_buffer(const PostprocessBuffer* const buffer) {
	glDeleteProgram(buffer -> postprocess_shader);
	glDeleteRenderbuffers(1, &buffer -> depth_render_buffer);
	glDeleteTextures(1, &buffer -> frame_texture);
	glDeleteFramebuffers(1, &buffer -> framebuffer);
}

_____ The .h postprocessing code:

#ifndef POSTPROCESS_H
#define POSTPROCESS_H

#include "utils/buffer_defs.h"

typedef struct {
	const GLuint framebuffer, depth_render_buffer, frame_texture, postprocess_shader;
} PostprocessBuffer;


void begin_postprocessing_capture(const PostprocessBuffer* const buffer);
void apply_postprocessing_from_capture(const PostprocessBuffer* const buffer);

PostprocessBuffer init_postprocess_buffer(void);
void deinit_postprocess_buffer(const PostprocessBuffer* const buffer);

#endif

_____ The postprocessing vertex shader:

#version 400 core

#include "common/quad_utils.vert"

noperspective out vec2 UV;

out vec4 vTexCoord[4];

uniform sampler2D frame_sampler;

void main(void) {
	UV = get_quad_UV();
	UV.y = 1.0f - UV.y;
	gl_Position = vec4(quad_corners[gl_VertexID], 0.0f, 1.0f);
}

_____ The postprocessing fragment shader at the end:

#version 400 core

noperspective in vec2 UV;
in vec4 vTexCoord[4];

out vec3 color;

uniform sampler2D frame_texture;

float rgb2luma(vec3 rgb){
    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));
}

void main(void) {
	/*
	color = texture(frame_texture, UV).rgb;
	return;
	*/

	///////////////////

	/*
	TODO:
	- Only do FXAA here to start, and apply other postprocessing effects after.
	- Or keep those effects in the world shader, if they can create aliasing artifacts

	- http://blog.simonrodriguez.fr/articles/2016/07/implementing_fxaa.html
	- https://github.com/McNopper/OpenGL/blob/master/Example42/shader/fxaa.frag.glsl
	- https://forum.unity.com/threads/retro-aa-antialiasing-for-pixel-art-and-voxel-games.412287/ (this + MSAA)
	- https://vegard.wiki/w/Texture_magnification_antialiasing
	- https://csantosbh.wordpress.com/2014/01/25/manual-texture-filtering-for-pixelated-games-in-webgl/
	- https://csantosbh.wordpress.com/2014/02/05/automatically-detecting-the-texture-filter-threshold-for-pixelated-magnifications/
	*/

	///////////////////

	vec2 frameBufSize = textureSize(frame_texture, 0);
	#define buf0 frame_texture
	#define texCoords UV
	#define texture2D texture

    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 1.0/8.0;
    float FXAA_REDUCE_MIN = 1.0/128.0;

    vec3 rgbNW=texture2D(buf0,texCoords+(vec2(-1.0,-1.0)/frameBufSize)).xyz;
    vec3 rgbNE=texture2D(buf0,texCoords+(vec2(1.0,-1.0)/frameBufSize)).xyz;
    vec3 rgbSW=texture2D(buf0,texCoords+(vec2(-1.0,1.0)/frameBufSize)).xyz;
    vec3 rgbSE=texture2D(buf0,texCoords+(vec2(1.0,1.0)/frameBufSize)).xyz;
    vec3 rgbM=texture2D(buf0,texCoords).xyz;

    vec3 luma=vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max(
        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
        FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
          dir * rcpDirMin)) / frameBufSize;

    vec3 rgbA = (1.0/2.0) * (
        texture2D(buf0, texCoords.xy + dir * (1.0/3.0 - 0.5)).xyz +
        texture2D(buf0, texCoords.xy + dir * (2.0/3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
        texture2D(buf0, texCoords.xy + dir * (0.0/3.0 - 0.5)).xyz +
        texture2D(buf0, texCoords.xy + dir * (3.0/3.0 - 0.5)).xyz);
    float lumaB = dot(rgbB, luma);

    if((lumaB < lumaMin) || (lumaB > lumaMax)){
        color.xyz=rgbA;
    }else{
        color.xyz=rgbB;
    }
}

_____

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	TWEAK_REALTIME_VALUE(bilinear_percent, 0.0f, 0.0f, 1.0f, 0.01f, T, Y, U);
	INIT_UNIFORM_VALUE(bilinear_percent, shader, 1f, bilinear_percent);

_____

typedef byte bvec3[3];
bool in_frustum(const bvec3 box[2], const vec4 planes[6]) {
  const float* plane;

  float dp;
  int    i;

  for (i = 0; i < 6; i++) {
    plane = planes[i];

	const bvec3 signs = {plane[0] > 0.0f, plane[1] > 0.0f, plane[2] > 0.0f};
	const bvec3 box_vals = {box[signs[0]][0], box[signs[1]][1], box[signs[2]][2]};
	dp = plane[0] * box_vals[0] + plane[1] * box_vals[1] + plane[2] * box_vals[2];

	/*
    dp = plane[0] * box[plane[0] > 0.0f][0]
       + plane[1] * box[plane[1] > 0.0f][1]
       + plane[2] * box[plane[2] > 0.0f][2];
	*/

    if (dp < -plane[3])
      return false;
  }

  return true;
}

_____


	////////// Rescaling the skybox if needed

	if (texture_rescale_factor != 1.0f) {
		SDL_Surface* const rescaled_skybox_surface = init_blank_surface(
			(GLsizei) (skybox_surface -> w * texture_rescale_factor),
			(GLsizei) (skybox_surface -> h * texture_rescale_factor),
			SDL_PIXEL_FORMAT);

		SDL_BlitScaled(skybox_surface, NULL, rescaled_skybox_surface, NULL);
		SDL_FreeSurface(skybox_surface);

		skybox_surface = rescaled_skybox_surface;
	}

_____

	vec3 bob = adjust_UV_for_pixel_art_filtering(vec3(34, 34, 34), UV);

_____

		const byte sampled_height = sample_map_point(heightmap, curr_tile[0], curr_tile[2], max_x);
		if (curr_tile[1] <= sampled_height) { // If the sampled height > 0, x and z are over, under, or inside this point
			/*
			- Would this work?
			- The point needs to be inside the iheightmap
			- So this indicates inside on x and z
			*/

			collided = true;
		}

_____

	if (dir[0] < 0.0f) {
		ray_step[0] = -1;
		ray_length_components[0] = 0.0f;
	}
	else {
		ray_step[0] = 1;
		ray_length_components[0] = unit_step_size[0];
	}

	//////////

	ray_step[1] = 1;
	ray_length_components[1] = unit_step_size[1];

	if (dir[2] < 0.0f) {
		ray_step[2] = -1;
		ray_length_components[2] = 0.0f;
	}
	else {
		ray_step[2] = 1;
		ray_length_components[2] = unit_step_size[2];
	}

_____

	/*
	printf("src curr tile = {%u, %u, %u}\n", curr_tile[0], curr_tile[1], curr_tile[2]);
	printf("ray step = {%d, %d, %d}\n", ray_step[0], ray_step[1], ray_step[2]);
	*/

_____

		byte maxes[3] = {max_x, max_y, max_z}, mins[3] = {1, 0, 1};

		bool s1 = (curr_tile[1] >= max_y) || (curr_tile[0] <= 1) || (curr_tile[0] >= max_x) || (curr_tile[2] <= 1 || curr_tile[2] >= max_z);
		bool s2 = curr_tile[index_of_shortest] >= maxes[index_of_shortest] || curr_tile[index_of_shortest] <= mins[index_of_shortest];
		// if (index_of_shortest == 1) s2 = curr_tile[index_of_shortest] >= maxes[index_of_shortest];
		DEBUG(index_of_shortest, u);
		DEBUG(s1, u);
		DEBUG(s2, u);
		assert(s1 == s2);
		puts("---");

_____

vec3 cmp = {sqrtf(1.0f + (dir[1] / dir[0]) * (dir[1] / dir[0])), sqrtf(1.0f + (dir[0] / dir[1]) * (dir[0] / dir[1])), 0.0f};
	DEBUG_VEC2(unit_step_size);
	DEBUG_VEC2(cmp);
	assert(glm_vec2_eqv((vec2) {unit_step_size[0], unit_step_size[2]}, cmp));

_____

	/*
	for (byte y = 0; y < max_y; y++) {
		const byte hval = (byte) ((GLfloat) y / max_y * 255);
		for (byte z = 0; z < max_z; z++) {
			for (byte x = 0; x < max_x; x++) {
				ao_map[y][z][x] = hval;
			}	
		}
	}
	*/

_____

	/*
	vec3 p = {origin_x, origin_y, origin_z}, step;
	glm_vec3_scale((GLfloat*) dir, 0.1f, step);

	bool first_iter = true;
	while (true) {
		glm_vec3_add(p, step, p);

		if (p[0] < 0.0f || p[0] > 39.0f ||
			p[1] > 16.0f ||
			p[2] < 0.0f || p[2] > 39.0f) return false;

		const byte sampled_height = sample_map_point(heightmap, (byte) p[0], (byte) p[2], max_x);
		const bool coll = p[1] <= sampled_height;
		if (coll && !first_iter) return true;
		first_iter = false;
	}
	*/

_____


	// Fix uploading before anything else
	const byte manual_map[2][9][9] = {
		{
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{100,0, 0, 0, 0, 0, 0, 0, 0},
			{150,0, 0, 0, 0, 0, 0, 0, 0},
			{200,0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 255, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 255, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0}
		},
		{
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 50, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 255, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0}
		}
	};

	memset(manual_map, 30, sizeof(manual_map));

	//////////////

	glTexImage3D(TexVolumetric, 0, GL_RED,
		9, 2, 9,
		0, GL_RED, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	for (int i = 0; i < 2; i++) glTexSubImage3D(
		TexVolumetric, 0, 0, 0, 0,
		9, i, 9,
		GL_RED, OPENGL_COLOR_CHANNEL_TYPE, manual_map[i]
	);

	/*
	glTexImage3D(TexVolumetric, 0, GL_RED,
		// map_size[0], map_size[1], ao_height_diff,
		// 9, 9, 1,
		// 1, 9, 9,
		// 9, 1, 9,
		// 9, 9, 1,
		// 1, 9, 9,
		9, 1, 9,
		0, GL_RED, OPENGL_COLOR_CHANNEL_TYPE, manual_map);
	*/

_____

	/* const vec3 color_volume[1][3][4] = {
		{
			{{1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 0.0f}}, // red, _, green
			{{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}}, // _, _, _
			{{0.0f, 0.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 0.0f}} // blue, _, _
		}
		/*
	};
	*/

_____

		// 3, 1, 4,
		3, 4, 1,

		/*
		1, 4, 3, - no
		1, 3, 4, - no

		4, 3, 1, - no, just red
		4, 1, 3,

		3, 4, 1,
		3, 1, 4,

		4, 3, 1,
		3, 4, 1
		*/

_____

	const Uint32 color_volume[1][2][2] = {
		{
			{c(255, 0, 0), c(0, 255, 0)}, // Red, green
			{c(0, 0, 255), c(0, 0, 0)} // Blue, black
		},
	};

_____

	// SDL_Surface* const s = init_surface(ASSET_PATH("spritesheets/trooper.bmp")); // Works with {64, 33, 64} and a normal `ao_map_UV`

_____

	/*
	SDL_PixelFormat* const fmt = SDL_AllocFormat(SDL_PIXEL_FORMAT);
	#define c(r, g, b) SDL_MapRGB(fmt, r, g, b)
	*/

	// TODO: test different dimensions, and more layers

	// TODO: get a spritesheet up in here to test this in a better way
	/*
	GLuint t = init_texture_set(false, TexNonRepeating, TexLinear, TexTrilinear, 3, 0, 128, 128, (GLchar*[]) {ASSET_PATH("walls/dial.bmp"), ASSET_PATH("walls/alkadhib.bmp"), ASSET_PATH("walls/eye_of_evil.bmp")}, NULL);
		SDL_Surface* const s = init_blank_surface(128, 128 * 3, SDL_PIXEL_FORMAT);
		glGetTexImage(TexSet, 0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, s -> pixels);
		SDL_SaveBMP(s, "../s.bmp");
	glDeleteTextures(1, &t);
	*/

_____

		// 64, 33, 64,
		// 40, 46, 8,

_____

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	TWEAK_REALTIME_VALUE(b, 0.0f, 0.0f, 2.0f, 0.01f, T, Y, U);
	INIT_UNIFORM_VALUE(b, shader, 1f, b);

_____

		const GLfloat A = rand() * one_over_rand_max, B = rand() * one_over_rand_max; // These are uniformly distributed
		const GLfloat radius = sqrtf(2.0f - logf(A));

_____

		const GLfloat vert_angle = rand() * two_over_rand_max - 1.0f; // Between -1 and 1
		const GLfloat hori_angle = rand() * two_over_rand_max - 1.0f; // Between -1 and 1

		const GLfloat
			sin_vert = sinf(vert_angle), cos_vert = cosf(vert_angle),
			sin_hori = sinf(hori_angle), cos_hori = cosf(hori_angle);

		v[0] = cos_vert * sin_hori;
		v[1] = sin_vert;
		v[2] = cos_vert * cos_hori;

_____

#include <math.h>
#include <stdlib.h>
#include <stdio.h>

void box_muller(const int num_dimensions, float* const vector) {
	float A, B; // uniform random variables
	float radius, angle;
	float sum;

	static const float
		one_over_rand_max = 1.0f / RAND_MAX,
		two_pi = 6.283185307179586;

	do {
		float sum = 0.0;
		for (int i = 0; i < num_dimensions; i += 2) {
			float radius = sqrt(-2.0f * log(A));
			float angle = two_pi * B;

			float* const vector_component = vector + i;
			*vector_component = radius * cos(angle);
			sum += *vector_component * *vector_component;

			const int next_i = i + 1;
			if (next_i < num_dimensions) {
				float* const next_vector_component = vector + next_i;
				*next_vector_component = radius * sin(angle);
				sum += *next_vector_component * *next_vector_component;
			}
		}
	} while (sum == 0.0); // While extremely unlikely, it is possible to pick a zero vector. AVOID!

	// Convert to a unit vector by dividing through by the length.
	float one_over_length = 1.0f / sqrt(sum);
	for (int i = 0; i < num_dimensions; i++)
		vector[i] *= one_over_length;

}

int main(void) {
	float big_vector[8];
	box_muller(8, big_vector);

	for (int i = 0; i < 8; i++) printf("%f, ", big_vector[i]);
	putchar('\n');
}

_____

static void cmp(GLdouble v[3], const GLint r1, const GLint r2) {
	static const GLdouble convert_to_cos_sin_period = (GLdouble) TWO_PI / RAND_MAX;

	const GLdouble
		vert_angle = r1 * convert_to_cos_sin_period,
		hori_angle = r2 * convert_to_cos_sin_period;

		const GLdouble cos_vert = cos(vert_angle);

		v[0] = (cos_vert * sin(hori_angle));
		v[1] = sin(vert_angle);
		v[2] = (cos_vert * cos(hori_angle));
}

_____

		printf("v = {%.10lf, %.10lf, %.10lf}\n", v[0], v[1], v[2]);

		/////////////////////////////

		GLdouble comparison[3];
		cmp(comparison, r1, r2);
		printf("cmp = {%.10lf, %.10lf, %.10lf}\n---\n", comparison[0], comparison[1], comparison[2]);

_____

	const GLfloat x = SDL_GetTicks() / 1000.0f;
	DEBUG_FLOAT(x);
	angles -> vert = x;

_____

		static const GLfloat two_over_rand_max = 2.0f / RAND_MAX;

		v[0] = rand() * two_over_rand_max - 1.0f; // Between -1 and 1
		v[1] = rand() * two_over_rand_max - 1.0f;
		v[2] = rand() * two_over_rand_max - 1.0f;

		glm_vec3_normalize(v);
		glm_vec3_adds(v, FLT_EPSILON, v); // This is to stop any divisions by zero	

_____

	with_trig = event -> keys[SDL_SCANCODE_G];
	if (event -> keys[SDL_SCANCODE_C]) {
		AmbientOcclusionMap ao_map = init_ao_map(scene_context -> heightmap, scene_context -> map_size, (byte[2]) {0, 16});
		memcpy(&scene_context -> ao_map, &ao_map, sizeof(ao_map));
	}
	t = scene_context -> ao_map;

_____

				uint16_t neu = rescaled_num_terms_to_reach_sky;
				if (do_new_thing) {
					/*
					neu <<= 1;
					neu = (neu > 255) ? 255 : neu;
					*/

					GLfloat hit_ratio = (GLfloat) num_collisions / num_trace_iters;
					hit_ratio *= 2;
					if (hit_ratio > 1) hit_ratio = 1;

					neu = 255 - (hit_ratio * 255);

					GLfloat cmp = rescaled_num_terms_to_reach_sky << 1;
					cmp = (cmp > 255) ? 255 : cmp;

					DEBUG_FLOAT(hit_ratio);
					printf("neu = %u, cmp = %lf\n", neu, cmp);

					neu = cmp;
				}
_____

	if (event -> keys[SDL_SCANCODE_C]) {
		a = init_ao_map(scene_context -> heightmap, scene_context -> map_size, (byte[2]) {0, 16});
		deinit_ao_map(scene_context -> ao_map);
		memcpy(&scene_context -> ao_map, &a, sizeof(GLuint));
	}

_____


	// const vec3 t = vec3(9.0f, 4.0f, 9.0f); // AO test
	// const vec3 t = vec3(40.0f, 16.0f, 40.0f); // Palace
	// const vec3 t = vec3(50.0f, 18.0f, 50.0f); // Fortress

	/*
	vec3 t = vec3(25.0f, 5.0f, 15.0f); // Level one

	vec3 t2 = textureSize(ao_map_sampler, 0);
	t.x = t2.x; // good
	t.z = t2.y;

	t = t2.xzy;
	if (t != t2.xzy) {
		bad = 1;
	}
	else bad = 0;
	*/

_____

	/*
	((a, b, c) / (d, e, f).xzy).xzy
	= ((a, b, c) / (d, f, e)).xzy
	= (a / d, b / f, c / e).xzy
	= (a / d, c / e, b / f)
	*/

_____

	ao_test_width = 9, ao_test_height = 9,

_____

ao_test_heightmap[ao_test_height][ao_test_width] = {
		{1, 1, 1, 2, 2, 2, 3, 3, 3},
		{1, 1, 1, 2, 2, 2, 3, 3, 3},
		{1, 1, 1, 2, 2, 2, 3, 3, 3},
		{0, 0, 0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 1, 1, 1, 1, 1, 0},
		{0, 0, 0, 1, 0, 0, 0, 1, 0},
		{0, 0, 0, 1, 0, 1, 1, 1, 0},
		{0, 0, 0, 1, 1, 1, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0, 0, 0},
},

ao_test_texture_id_map[ao_test_height][ao_test_width],

	/*
	*const heightmap = (const byte*) ao_test_heightmap,
	*const texture_id_map = (const byte*) ao_test_texture_id_map,
	map_size[2] = {ao_test_width, ao_test_height};
	*/

_____

	///////////// This is a 3D data format test

	/*
	// SDL_Surface* const s = init_surface(ASSET_PATH("spritesheets/trooper.bmp")); // Works with {64, 33, 64} and a normal `ao_map_UV`
	// SDL_Surface* const s = init_surface(ASSET_PATH("spritesheets/weapons/desecrator_cropped.bmp"));
	SDL_Surface* const s = init_surface(ASSET_PATH("../s.bmp"));
	const GLuint volume_texture = preinit_texture(TexVolumetric, TexNonRepeating, TexLinear, TexTrilinear, false);
	glTexImage3D(TexVolumetric, 0, GL_RGBA, 128, 128, 3, 0, GL_BGRA, OPENGL_COLOR_CHANNEL_TYPE, s -> pixels);
	glGenerateMipmap(TexVolumetric);
	SDL_FreeSurface(s);
	return volume_texture;
	*/

	/////////////

_____

				const GLfloat scaler_2 = (GLfloat) constants.max_byte_value / (num_trace_iters >> 1);
				const byte a = (byte) (num_collisions * scaler_2);
				const byte b = constants.max_byte_value - a;

				if (b == num_terms_for_hemisphere) puts("Nice");

_____

	/* For a given point, the illumination term for ambient occlusion term equals the number of rays that were
	able to each the sky divided by the total number of rays cast. Since the only rays that actually hit the surface
	from the surrounding environment form a hemisphere oriented around the surface normal, that then means that ideally,
	I would only consider cast rays within that area.

	So, rays that are cast outside of that area should then be ignored, which should then roughly equal half of the rays
	cast. Multiplying the final illumination term by 2 solves this problem of not sampling around strictly the hemisphere. */

	const byte rescaled_num_collisions = (byte) (num_collisions * collision_term_scaler);
				const byte rescaled_num_terms_to_reach_sky = constants.max_byte_value - rescaled_num_collisions;

				uint16_t num_terms_for_hemisphere = (uint16_t) (rescaled_num_terms_to_reach_sky << 1);
				num_terms_for_hemisphere = (num_terms_for_hemisphere > constants.max_byte_value)
					? constants.max_byte_value : num_terms_for_hemisphere;

_____

vec4 cubic(float v){
	vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;
	vec4 s = n * n * n;
	float x = s.x;
	float y = s.y - 4.0 * s.x;
	float z = s.z - 4.0 * s.y + 6.0 * s.x;
	float w = 6.0 - x - y - z;
	return vec4(x, y, z, w) * (1.0/6.0);
}

vec4 textureBicubic(sampler2DArray sampler, vec3 texCoords){

   vec2 texSize = textureSize(sampler, 0).xy;
   vec2 invTexSize = 1.0 / texSize;
   
	vec2 tc = texCoords.xy;
	tc = tc * texSize - 0.5f;
   
	vec2 fxy = fract(tc);
	tc -= fxy;

	vec4 xcubic = cubic(fxy.x);
	vec4 ycubic = cubic(fxy.y);

	vec4 c = tc.xxyy + vec2 (-0.5, +1.5).xyxy;
	
	vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);
	vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;
	
	offset *= invTexSize.xxyy;
	
	vec4 sample0 = texture(sampler, vec3(offset.xz, texCoords.z));
	vec4 sample1 = texture(sampler, vec3(offset.yz, texCoords.z));
	vec4 sample2 = texture(sampler, vec3(offset.xw, texCoords.z));
	vec4 sample3 = texture(sampler, vec3(offset.yw, texCoords.z));

	float sx = s.x / (s.x + s.y);
	float sy = s.z / (s.z + s.w);

	return mix(
	   mix(sample3, sample2, sx), mix(sample1, sample0, sx)
	, sy);
}

_____

	vec4 texture_color = textureBicubic(diffuse_sampler, adjusted_UV);

_____

static bool cmp(
	const vec3 inv_dir, const byte* const heightmap,
	const byte origin_x, const byte origin_y, const byte origin_z,
	const byte max_x, const byte max_y, const byte max_z) {

	vec3 p = {origin_x, origin_y, origin_z}, step;
	glm_vec3_scale((vec3) {1.0f / inv_dir[0], 1.0f / inv_dir[1], 1.0f / inv_dir[2]}, 0.01f, step);

	printf("origin = {%u, %u, %u}\n", origin_x, origin_y, origin_z);

	while (true) {
		glm_vec3_add(p, step, p);

		printf("Checking point {%f, %f, %f} in cmp\n", (double) p[0], (double) p[1], (double) p[2]);

		if ((p[1] > max_y) || (p[0] < 0.0f || p[0] > max_x + 1) || (p[2] < 0.0f || p[2] > max_z + 1)) {
			puts("Out of bounds in cmp");
			return false;
		}

		const byte sampled_height = sample_map_point(heightmap, (byte) p[0], (byte) p[2], max_x);

		if (p[1] < sampled_height || p[1] < 0.0f) {
			puts("Collided with voxel in cmp");
			return true;
		}
	}
}

_____

						// r2 = cmp(inv_rand_dir, heightmap, x, y, z, max_x, max_y, max_z),

_____

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>

float sign(const float x) {
	if (x > 0.0f) return 1.0f;
	else if (x == 0.0f) return 0.0f;
	else return -1.0f;
}

// https://github.com/cgyurgyik/fast-voxel-traversal-algorithm/blob/master/overview/FastVoxelTraversalOverview.md
// This returns if the ray collided with a point
bool traversal(float X, float Y, float Z, const float justOutX, const float justOutY, const float justOutZ, const float dir[3]) {
	float stepX = sign(dir[0]), stepY = sign(dir[1]), stepZ = sign(dir[2]);
	float tDeltaX = 1.0f / dir[0], tDeltaY = 1.0f / dir[1], tDeltaZ = 1.0f / dir[2];
	float tMaxX = tDeltaX * (dir[0] > 0.0f), tMaxY = tDeltaY * (dir[1] > 0.0f), tMaxZ = tDeltaZ * (dir[2] > 0.0f);

	bool collided = false;

	do { 
		if (tMaxX < tMaxY) { 
			if (tMaxX < tMaxZ) { 
				X += stepX; 
				if (X == justOutX) break; // Outside grid
				tMaxX = tMaxX + tDeltaX; 
		  	}
			else { 
				Z += stepZ; 
				if (Z == justOutZ) break;
				tMaxZ += tDeltaZ;
		  	} 
		}
		else { 
			if (tMaxY < tMaxZ) { 
				Y += stepY; 
				if (Y == justOutY) break;
				tMaxY += tDeltaY; 
			}
			else { 
				Z += stepZ; 
				if (Z == justOutZ) break;
				tMaxZ += tDeltaZ; 
		  } 
		}
		// list = ObjectList[X][Y][Z];
		// Now here, I have a X, Y, and Z position (and I can set `collided` accordingly)
		printf("XYZ = {%f, %f, %f}\n", X, Y, Z);

   } while (!collided);

	return collided;
}

int main(void) {

}

_____

		// TODO: do checks via increment indexing
		/*
		if (ray_length_components[1] < shortest_component) {
			shortest_component = ray_length_components[1];
			index_of_shortest++;
		}

		if (ray_length_components[2] < shortest_component) {
			shortest_component = ray_length_components[2];
			index_of_shortest++;
		}
		*/

_____

		printf("Curr DDA pos: {%d, %d, %d}; ray length components = {%f, %f, %f}\n",
			curr_tile[0], curr_tile[1], curr_tile[2],
			ray_length_components[0], ray_length_components[1], ray_length_components[2]);

_____

#define printf(...)
#define puts(_)

// https://github.com/cgyurgyik/fast-voxel-traversal-algorithm/blob/master/overview/FastVoxelTraversalOverview.md
bool traversal(float X, float Y, float Z, const float boundary[3], const float dir[3], const byte* const heightmap) {
	const float stepX = sign(dir[0]), stepY = sign(dir[1]), stepZ = sign(dir[2]);
	const float tDeltaX = 1.0f / fabsf(dir[0]), tDeltaY = 1.0f / fabsf(dir[1]), tDeltaZ = 1.0f / fabsf(dir[2]);
	float tMaxX = tDeltaX * (dir[0] > 0.0f), tMaxY = tDeltaY * (dir[1] > 0.0f), tMaxZ = tDeltaZ * (dir[2] > 0.0f);

	bool collided = false;

	do {
		if (tMaxX < tMaxY) {
			if (tMaxX < tMaxZ) {
				X += stepX;
				if (X == -1 || X > boundary[0]) break;
				tMaxX += tDeltaX;
		  	}
			else {
				Z += stepZ;
				if (Z == -1 || Z > boundary[2]) break;
				tMaxZ += tDeltaZ;
			}
		}
		else {
			if (tMaxY < tMaxZ) {
				Y += stepY;
				if (Y > boundary[1]) break;
				tMaxY += tDeltaY;
			}
			else {
				Z += stepZ;
				if (Z == -1 || Z > boundary[2]) break;
				tMaxZ += tDeltaZ;
			}
		}

		const byte sample_height = sample_map_point(heightmap, (byte) X, (byte) Z, (byte) boundary[0]);
		collided = Y < sample_height || Y == -1;

	} while (!collided);

	return collided;
}

_____

					/*
					if (r1 != r2) {
						printf("Mismatch: DDA = %d, and cmp = %d for vector {%f, %f, %f} from {%u, %u, %u}\n",
							r1, r2, (double) (1.0f / inv_rand_dir[0]), (double) (1.0f / inv_rand_dir[1]),
							(double) (1.0f / inv_rand_dir[2]), x, y, z);

						exit(0);
					}
					else puts("Good");
					*/

_____

static bool cmp(
	const vec3 inv_dir, const byte* const heightmap,
	const byte origin_x, const byte origin_y, const byte origin_z,
	const byte max_x, const byte max_y, const byte max_z) {

	vec3 p = {origin_x, origin_y, origin_z}, step;
	glm_vec3_scale((vec3) {1.0f / inv_dir[0], 1.0f / inv_dir[1], 1.0f / inv_dir[2]}, 0.0001f, step);

	// printf("origin = {%u, %u, %u}\n", origin_x, origin_y, origin_z);

	while (true) {
		glm_vec3_add(p, step, p);

		// printf("Checking point {%f, %f, %f} in cmp\n", (double) p[0], (double) p[1], (double) p[2]);

		if ((p[1] > max_y) || (p[0] < 0.0f || p[0] > max_x + 1) || (p[2] < 0.0f || p[2] > max_z + 1))
			return false;

		const byte sampled_height = sample_map_point(heightmap, (byte) p[0], (byte) p[2], max_x);

		if (p[1] < sampled_height || p[1] < 0.0f) {
			return true;
		}
	}
}

_____

	// num_collisions += ray_collides_with_heightmap(inv_rand_dir, heightmap, x, y, z, max_x, max_y, max_z);

					const bool r1 = ray_collides_with_heightmap(inv_dir, heightmap, x, y, z, max_x, max_y, max_z); // r1 has the tents
					const bool r2 = cmp(inv_dir, heightmap, x, y, z, max_x, max_y, max_z);
					
					if (r1 != r2) {
						// printf("Mismatch in states: DDA '%s', but the algorithm '%s'\n", r1 ? "collided" : "reached sky", r2 ? "collided" : "reached sky");
						// exit(0);
						bads++;
					}
					else goods++;

					num_collisions += r2;

_____

				byte val = constants.max_byte_value - (byte) (num_collisions * collision_term_scaler);
				GLfloat twice = val * 2;
				if (twice > 255) twice = 255;
				*dest = (byte) twice;

_____

	// return vec4(vec3(ambient / strengths.ambient), 1.0f);

_____

	vec3 cmp = (non_ambient * shadow_strength + strengths.ambient) * ao_strength;
	if (distance(light_strength, cmp) < 0.0000001f) return vec4(1.0f, 0.0f, 0.0f, 1.0f);

_____

	// vec3 light_strength = non_ambient * (shadow_strength * ao_strength) + (strengths.ambient * ao_strength);

_____

	DEBUG_FLOAT(glm_vec3_norm(face_normal));
	DEBUG_FLOAT(glm_vec3_norm(face_tangent));

	mat3 uniform_TBN;
	glm_vec3_copy(face_tangent, uniform_TBN[0]);
	glm_vec3_cross(face_tangent, face_normal, uniform_TBN[1]);
	glm_vec3_copy(face_normal, uniform_TBN[2]);

	mat3 without;
	glm_mat3_copy(uniform_TBN, without);

	for (int i = 0; i < 3; i++) glm_vec3_normalize(uniform_TBN[i]);

	// printf("With:\n{%f, %f, %f}\n{%f, %f, %f}\n")

	#define prm3(msg, m) do {\
		printf("%s:\n", msg);\
		for (int y=0;y<3;y++) {\
			for (int x=0;x<3;x++) printf("%lf ", (double) m[y][x]);\
		puts("");\
		}\
	} while (0)

	prm3("Normalized", uniform_TBN);
	prm3("Without", without);
	puts("---");

_____

	DEBUG_FLOAT(glm_vec3_norm(face_normal));
	DEBUG_FLOAT(glm_vec3_norm(face_tangent));

	mat3 uniform_TBN;
	glm_vec3_copy(face_tangent, uniform_TBN[0]);
	glm_vec3_cross(face_tangent, face_normal, uniform_TBN[1]);
	glm_vec3_copy(face_normal, uniform_TBN[2]);

	mat3 without;
	glm_mat3_copy(uniform_TBN, without);

	for (int i = 0; i < 3; i++) glm_vec3_normalize(uniform_TBN[i]);

	// printf("With:\n{%f, %f, %f}\n{%f, %f, %f}\n")

	#define prm3(msg, m) do {\
		printf("%s:\n", msg);\
		for (int y=0;y<3;y++) {\
			for (int x=0;x<3;x++) printf("%lf ", (double) m[y][x]);\
		puts("");\
		}\
	} while (0)

	prm3("Normalized", uniform_TBN);
	prm3("Without", without);
	puts("---");

	INIT_UNIFORM_VALUE(uniform_TBN, shader, Matrix3fv, 1, GL_FALSE, (GLfloat*) uniform_TBN);

_____

	/*
	typedef struct {float x, y;} svec2;
	typedef struct {float x, y, z;} svec3;

	#define svec2_sub(a, b) (svec2) {a.x - b.x, a.y - b.y};
	#define svec3_sub(a, b) (svec3) {a.x - b.x, a.y - b.y, a.z - b.z}

	svec3 pos1 = {-1.0f,  1.0f, 0.0f};
	svec3 pos2 = {-1.0f, -1.0f, 0.0f};
	svec3 pos3 = {1.0f, -1.0f, 0.0f};
	svec3 pos4 = {1.0f,  1.0f, 0.0f};
	// texture coordinates
	svec2 uv1 = {0.0f, 1.0f};
	svec2 uv2 = {0.0f, 0.0f};
	svec2 uv3 = {1.0f, 0.0f};  
	svec2 uv4 = {1.0f, 1.0f};
	// normal vector
	svec3 nm = {0.0f, 0.0f, 1.0f};

	// calculate tangent/bitangent vectors of both triangles
	svec3 tangent1, bitangent1;
	svec3 tangent2, bitangent2;
	// triangle 1
	// ----------
	svec3 edge1 = svec3_sub(pos2, pos1);
	svec3 edge2 = svec3_sub(pos3, pos1);
	svec2 deltaUV1 = svec2_sub(uv2, uv1);
	svec2 deltaUV2 = svec2_sub(uv3, uv1);

	float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

	tangent1.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
	tangent1.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
	tangent1.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);

	bitangent1.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
	bitangent1.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
	bitangent1.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);

	// triangle 2
	// ----------
	edge1 = svec3_sub(pos3, pos1);
	edge2 = svec3_sub(pos4, pos1);
	deltaUV1 = svec2_sub(uv3, uv1);
	deltaUV2 = svec2_sub(uv4, uv1);

	f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

	tangent2.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
	tangent2.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
	tangent2.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);

	bitangent2.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
	bitangent2.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
	bitangent2.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);

	printf("bitangent1 = {%f, %f, %f}\n", bitangent1.x, bitangent1.y, bitangent1.z);
	printf("bitangent2 = {%f, %f, %f}\n", bitangent2.x, bitangent2.y, bitangent2.z);
	printf("tangent1 = {%f, %f, %f}\n", tangent1.x, tangent1.y, tangent1.z);
	printf("tangent2 = {%f, %f, %f}\n", tangent2.x, tangent2.y, tangent2.z);
	puts("---");
	*/

_____

	/*
	vec3 normal, tangent;
	get_normal_and_tangent(world_corners, normal, tangent);

	vec3 bt;
	glm_vec3_cross(normal, tangent, bt);

	// printf("Normal: {%f, %f, %f}\n", normal[0], normal[1], normal[2]);
	// printf("Tangent: {%f, %f, %f}\n", tangent[0], tangent[1], tangent[2]);
	printf("Bitangent: {%f, %f, %f}\n", bt[0], bt[1], bt[2]);

	UPDATE_UNIFORM(face_normal, 3fv, 1, normal);
	UPDATE_UNIFORM(face_tangent, 3fv, 1, tangent);
	*/
	// Corner order: bl, br, tl, tr. Triangles formed: <bl, br, tl>, <br, tl, tr>.

	/*
	vec3 face_normal, face_tangent;
	get_normal_and_tangent(world_corners, face_normal, face_tangent);
	UPDATE_UNIFORM(face_normal, 3fv, 1, face_normal);
	UPDATE_UNIFORM(face_tangent, 3fv, 1, face_tangent);
	*/

_____

	/*
	mat3 final_TBN;
	if (branch) final_TBN = mat3(normalize(TBN[0]), normalize(TBN[1]), normalize(TBN[2]));
	else final_TBN = TBN;

	vec3 normal = normalize(final_TBN * get_tangent_space_normal(UV)); // TODO: see if this normalization is necessary
	*/

	branch;

	vec3 normal = TBN * get_tangent_space_normal(UV);

	/*
	mat3 new = mat3(normalize(TBN[0]), normalize(TBN[1]), normalize(TBN[2]));
	vec3 normal1 = (new * get_tangent_space_normal(UV));

	vec3 normal2 = normalize(TBN * get_tangent_space_normal(UV));

	if (distance(normal1, normal2) > 0.00001f) {
		color = vec4(0.0f, 1.0f, 0.0f, 1.0f);
		return;
	}
	*/

	// vec3 normal = branch ? normal2 : normal1;

	/*
	if (branch) {
		mat3 new = mat3(normalize(TBN[0]), normalize(TBN[1]), normalize(TBN[2]));
		normal = normalize(new * get_tangent_space_normal(UV));
	}
	else {
		normal = normalize(TBN * get_tangent_space_normal(UV));
	}
	*/

_____

	/*
	vec3 tangents[corners_per_quad], bitangents[corners_per_quad];

	// Corner order: bl, br, tl, tr. Triangles formed: <bl, br, tl>, <br, tl, tr>. Tangent points along S, and bitangent points along T.
	for (byte i = 0; i < corners_per_quad; i++) {
		// const byte next_i = (i == 3) ? 0
	}
	*/

	mat3 tbn;
	glm_vec3_sub(world_corners[1], world_corners[0], tbn[0]); // Tangent (flows along S), from bl to br
	glm_vec3_sub(world_corners[2], world_corners[0], tbn[1]); // Bitangent (flows along S)
	glm_vec3_cross(tbn[0], tbn[1], tbn[2]); // Normal
	
	for (int i = 0; i < 3; i++) glm_vec3_normalize(tbn[i]);

	vec3 test = {0.9f, 0.4f, -0.7f};
	glm_vec3_normalize(test);

	DEBUG_VEC3(test);
	DEBUG(glm_vec3_norm(test), lf);

	vec3 result;
	glm_mat3_mulv(tbn, test, result);

	DEBUG_VEC3(result);
	DEBUG(glm_vec3_norm(result), lf);
	puts("---");

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	INIT_SHADER_BRANCH(shader, branch, G);

	INIT_UNIFORM_VALUE(TBN, shader, Matrix3fv, 1, GL_FALSE, tbn);

_____

static void get_normal_and_tangent(const vec3 world_corners[corners_per_quad], vec3 normal, vec3 tangent) {
	const GLfloat
		*const corner_bl = world_corners[0],
		*const corner_br = world_corners[1],
		*const corner_tl = world_corners[2];

	vec3 edge_bl_br, edge_tl_br;
	glm_vec3_sub((GLfloat*) corner_bl, (GLfloat*) corner_br, edge_bl_br);
	glm_vec3_sub((GLfloat*) corner_tl, (GLfloat*) corner_br, edge_tl_br);
	glm_vec3_cross(edge_tl_br, edge_bl_br, normal);
	glm_vec3_normalize(normal); // Why wasn't it normalized before this?

	////////// The tangent calculation is from https://learnopengl.com/Advanced-Lighting/Normal-Mapping

	/* The corner order is bottom left, bottom right, top left, top right.
	These deltas are from bottom left -> bottom right, and bottom left -> top left. */
	const vec2 delta_UV_1 = {1.0, 0.0}, delta_UV_2 = {0.0, -1.0};

	vec3 edge_br_bl, edge_tl_bl;
	glm_vec3_sub((GLfloat*) corner_br, (GLfloat*) corner_bl, edge_br_bl);
	glm_vec3_sub((GLfloat*) corner_tl, (GLfloat*) corner_bl, edge_tl_bl);

	const GLfloat f = 1.0f / (delta_UV_1[0] * delta_UV_2[1] - delta_UV_2[0] * delta_UV_1[1]);

	tangent[0] = f * (delta_UV_2[1] * edge_br_bl[0] - delta_UV_1[1] * edge_tl_bl[0]);
	tangent[1] = f * (delta_UV_2[1] * edge_br_bl[1] - delta_UV_1[1] * edge_tl_bl[1]);
	tangent[2] = f * (delta_UV_2[1] * edge_br_bl[2] - delta_UV_1[1] * edge_tl_bl[2]);

	glm_vec3_normalize(tangent);
}

_____

	mat3 t = tbn;
	if (branch) {
		t[0] = normalize(t[0]);
		t[1] = normalize(t[1]);
		t[2] = normalize(t[2]);
	}

_____

		if (animation_layout.frames_across == 1) {
			puts("Yes");
			DEBUG(animation_layout.spritesheet_path, s);

			printf("spritesheet surface: {%d, %d}\n", spritesheet_surface -> w, spritesheet_surface -> h);

			WITH_SURFACE_PIXEL_ACCESS(spritesheet_surface,

			int fi = 0; // animation_frame_index
			glTexSubImage3D(TexSet, 0, 0, 0, fi,
				// spritesheet_surface -> w, spritesheet_surface -> h, 1,
				40, 368, 1,
				OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE,
				spritesheet_surface -> pixels);
			);

			puts("After calll");
			SDL_FreeSurface(spritesheet_surface);

			continue;
		}

_____

			/*
			char* str = malloc(2000);
			sprintf(str, "%d_%s", frame_index, strrchr(animation_layout.spritesheet_path, '/') + 1);
			DEBUG(str, s);
			SDL_SaveBMP(rescaled_surface, str);
			free(str);
			*/

_____

	vec2 lod = textureQueryLod(alpha_test_sampler, UV);
	UV = vec3(translucent_fragment_quad_UV, frame_ind / textureSize(alpha_test_sampler, int(lod.x)).z);

_____

	Billboard* const b = (Billboard*) billboard_context -> billboards.data + 14;
	b -> size[0] = 0.5f;
	glm_vec3_copy(camera -> pos, b -> pos);
	glm_vec3_muladds(camera -> dir, -0.1f, b -> pos);

_____

	/*
	- Only 1 animation id will ever be coupled to a billboard id. Maybe I can use that in some way.
	- For each animation instance, only one 
	*/


	/*
	4 billboard-related things:
	1. Animation layouts (asset path, frames across, frames down, total frames)
	2. Animations (id start, id end, seconds for frame)
	3. Animation instances (billboard id, animation id)
	4. Billboards (id, size, pos)
	5. Still billboard texture paths

	Goal: reduce the complexity by reducing the number of objects needed

	- Can everything be animated?
	*/

_____

	// char* first = (cshader_code[0].data[0];
	/*
	DEBUG(sub_shader_paths[0], s);
	if (!strcmp(sub_shader_paths[0], ASSET_PATH("shaders/ao_raytracer.vert"))) {
		puts("A raytracer");
	}
	*/

	/*
	List vert_code = shader_code[0];
	// if (vert_code.length == 1) {
		puts("len of 1");
	}
	*/

_____

	const GLuint shader = init_shader(ASSET_PATH("shaders/ao_raytracer.vert"), NULL, NULL, hook_before_linking);
	glUseProgram(shader);

	//////////

	const GLfloat data[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};
	GLuint vbo; glGenBuffers(1, &vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo); glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);

	GLuint vao; glGenVertexArrays(1, &vao); glBindVertexArray(vao);
	// define_vertex_spec_index(false, true, 0, 1, 0, 0, GL_FLOAT);

	GLint inputAttrib = glGetAttribLocation(shader, "in_val");
	DEBUG(inputAttrib, d);
	glEnableVertexAttribArray(inputAttrib);
	glVertexAttribPointer(inputAttrib, 1, GL_FLOAT, GL_FALSE, 0, 0);

	glUseProgram(0);
	glBindVertexArray(0);

	//////////

	/*
	glDeleteVertexArrays(1, &vao);
	glDeleteBuffers(1, &vbo);
	glDeleteProgram(shader);
	*/

_____

	const GLchar* vertexShaderSrc =
		"#version 400 core\n"

		"in float in_value;\n"
		"out float out_value;\n"

		"void main(void) {\n"
			"out_value = in_value * in_value;\n"
		"}\n";
	
	GLuint program = glCreateProgram();

	GLuint shader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(shader, 1, &vertexShaderSrc, NULL);
	glCompileShader(shader);

	/*
	GLint log_length;
	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
	DEBUG(log_length, d);
	if (log_length > 0) {
		char* error_msg = malloc(log_length + 1);
		glGetShaderInfoLog(shader, log_length, NULL, error_msg);
		DEBUG(error_msg, s);
		exit(1);
	}
	*/

	
	glAttachShader(program, shader);

		const GLchar* feedbackVaryings[] = {"out_value"};
		glTransformFeedbackVaryings(program, 1, feedbackVaryings, GL_INTERLEAVED_ATTRIBS);
		glLinkProgram(program);

	glDetachShader(program, shader);

	GLint log_length;
	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &log_length);
	DEBUG(log_length, d);
	if (log_length > 0) {
		char* error_msg = malloc(log_length + 1);
		glGetProgramInfoLog(program, log_length, NULL, error_msg);
		DEBUG(error_msg, s);
		exit(1);
	}

	// glDeleteProgram(program);

	GL_ERR_CHECK;

_____

		// if (textureLod(alpha_test_sampler, UV, 0).a < alpha_threshold) discard;

_____

	const GLchar* vertexShaderSrc =
    "#version 150 core\n"

    "in float inValue;"
    "out float geoValue;"

    "void main()"
    "{"
        "geoValue = sqrt(inValue);"
    "}";

	GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSrc, NULL);
    glCompileShader(vertexShader);

    // Create program and specify transform feedback variables
    GLuint program = glCreateProgram();
    glAttachShader(program, vertexShader);

    const GLchar* feedbackVaryings[] = { "outValue" };
    glTransformFeedbackVaryings(program, 1, feedbackVaryings, GL_INTERLEAVED_ATTRIBS);

    glLinkProgram(program);
    glUseProgram(program);

    // Create VAO
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    // Create input VBO and vertex format
    GLfloat data[] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f };

    GLuint vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);

    GLint inputAttrib = glGetAttribLocation(program, "inValue");
    glEnableVertexAttribArray(inputAttrib);
    glVertexAttribPointer(inputAttrib, 1, GL_FLOAT, GL_FALSE, 0, 0);

    // Create transform feedback buffer
    GLuint tbo;
    glGenBuffers(1, &tbo);
    glBindBuffer(GL_ARRAY_BUFFER, tbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(data) * 3, NULL, GL_STATIC_READ);

    // Create query object to collect info
    GLuint query;
    glGenQueries(1, &query);

    // Perform feedback transform
    glEnable(GL_RASTERIZER_DISCARD);

    glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, tbo);

    glBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, query);
        glBeginTransformFeedback(GL_TRIANGLES);
            glDrawArrays(GL_POINTS, 0, 5);
        glEndTransformFeedback();
    glEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);

    glDisable(GL_RASTERIZER_DISCARD);

    glFlush();

    // Fetch and print results
    GLuint primitives;
    glGetQueryObjectuiv(query, GL_QUERY_RESULT, &primitives);

    GLfloat feedback[15];
    glGetBufferSubData(GL_TRANSFORM_FEEDBACK_BUFFER, 0, sizeof(feedback), feedback);

    printf("%u primitives written!\n\n", primitives);

    for (int i = 0; i < 15; i++) {
        printf("%f\n", feedback[i]);
    }

    glDeleteQueries(1, &query);

_____

	/*
	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glBufferData(GL_ARRAY_BUFFER, input_size, input, GL_STATIC_DRAW);
	*/

_____

	const GLfloat input[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};
	const size_t input_size = sizeof(input);

	//////////

	const GLuint shader = init_shader(ASSET_PATH("shaders/ao_raytracer.vert"), NULL, NULL, hook_before_linking);
	glUseProgram(shader);

	GLuint vbo, tbo, vao;
	
	// Defining the input data
	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glBufferData(GL_ARRAY_BUFFER, input_size, input, GL_STATIC_DRAW);

	// Defining the input data format
	glGenVertexArrays(1, &vao); glBindVertexArray(vao);
	define_vertex_spec_index(false, true, 0, 1, 0, 0, GL_FLOAT);

	// Defining the output data
	glGenBuffers(1, &tbo);
	glBindBuffer(GL_ARRAY_BUFFER, tbo);
	glBufferData(GL_ARRAY_BUFFER, input_size, NULL, GL_STATIC_READ);
	glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, tbo);

	WITH_BINARY_RENDER_STATE(GL_RASTERIZER_DISCARD,
		// Generating the output data
		glBeginTransformFeedback(GL_POINTS);
		glDrawArrays(GL_POINTS, 0, ARRAY_LENGTH(input));
		glEndTransformFeedback();

		// glFlush(); // TODO: needed?

		// Getting the output data (TODO: get this as an output texture)
		GLfloat* const output = alloc(1, input_size);
		glGetBufferSubData(GL_TRANSFORM_FEEDBACK_BUFFER, 0, input_size, output);

		for (size_t i = 0; i < ARRAY_LENGTH(input); i++) printf("%f ", (double) output[i]);
		putchar('\n');

		dealloc(output);
	);

_____

	// const count_t inf_z = (total / (max_x)) % max_z;
	const count_t inf_z = (total / max_x) % max_z;
	const count_t inf_y = total / max_x * (1.0f / max_z);

_____

// const float in_vals[5] = float[5](1.0f, 2.0f, 3.0f, 4.0f, 5.0f);

_____

	GLint res;
	glGetIntegerv(GL_MAX_UNIFORM_LOCATIONS, 0, &res);
	DEBUG(res, d);

_____

	/*
	char* fmtstr = malloc(100);
	for (int i = 0; i < 255; i++) {
		sprintf(fmtstr, "inv_rand_dirs[%d]", i);

		const GLint uniform = glGetUniformLocation(shader, fmtstr);

		const GLfloat* const v = inv_rand_dirs[i];
		glUniform3f(uniform, v[0], v[1], v[2]);

	}
	free(fmtstr);
	*/


	// DEBUG_VEC3(inv_rand_dirs[0]);

	/*
	for (int i = 0; i < 255; i++) {
		const GLfloat* const v = inv_rand_dirs[i];
		printf("vec3(%f, %f, %f),", v[0], v[1], v[2]);
		if (i % 21 == 0) {
			printf("\t");
		}
	}
	*/

_____

/*
const vec3 values[] = vec3[](
	vec3(-1.195517, 4067.145996, -1.824717),
	vec3(5.925620, -1.015708, -21.265827),vec3(-3.458925, -1.166866, -2.344205),vec3(17.502363, 1.004326, -13.695759),vec3(1.417295, 1.651466, 2.716485),vec3(-2.009576, -2.018563, -1.404481),vec3(2.007464, 1.209968, 3.812299),vec3(11.467505, 1.005943, 15.475033),vec3(-6.771641, 1.270213, -1.670386),vec3(1.335624, -2.009006, -2.284178),vec3(2.904478, 1.915258, -1.281580),vec3(-1.301241, -2.946134, -1.843649),vec3(-11.119421, 1.007295, -12.555765),vec3(-1.040606, 4.003875, 8.409354),vec3(-30.515896, 2.075826, -1.141939),vec3(1.137474, -3.138858, -2.821514),vec3(-2.630820, 1.081732, -32.957939),vec3(3.046448, -1.103851, 3.738194),vec3(-1.967354, 1.169718, 9.636367),vec3(-1.174770, -3.598896, 2.246208),vec3(-20.656580, 1.004343, 12.613514),vec3(1.328162, -1.530757, -12.551250),
	vec3(-27.714727, 1.001139, 32.068657),vec3(3.966614, 1.193142, -2.067279),vec3(-1.678653, 1.322567, -3.690383),vec3(3.135470, -1.151129, -2.638705),vec3(3.763218, 1.078580, -3.785311),vec3(-4.012135, -1.043909, 7.030325),vec3(-14.911504, 2.432992, 1.099919),vec3(-1.103575, -3.505532, 3.202149),vec3(7.137601, -6.865238, 1.021071),vec3(2.037494, -2.041770, 1.387764),vec3(5.821417, -2.454342, -1.114914),vec3(-7.172434, 1.144020, 2.149211),vec3(-19.403763, -1.002472, 20.992086),vec3(2.093288, -45.020313, -1.138650),vec3(3.162578, 1.516572, 1.466102),vec3(-1.872518, -1.243275, 3.838808),vec3(-3.576607, -1.041539, 1355.540771),vec3(-3.509222, -1.069192, 4.765329),vec3(-2.178525, 1.304050, -2.229122),vec3(3.209132, 2.091580, -1.217782),vec3(-2.303269, 1.190274, -3.076397),
	vec3(3.329286, -1.101555, 3.416606),vec3(2.846564, -58.719234, -1.068253),vec3(-10.060977, 1.157619, -2.024868),vec3(-77.422493, -1.000509, -34.297085),vec3(1.048621, -3.628937, 8.262201),vec3(1.116070, 2.699182, 4.085032),vec3(-3.770884, 1.217378, -1.980624),vec3(-3.044630, -1.085181, 4.825207),vec3(1.726094, 2.557440, -1.398268),vec3(-11.032275, -1.006868, 13.634105),vec3(1.163953, 13.243942, 1.975745),vec3(-44.641090, -1.132468, 2.133166),vec3(-5.974533, -1.014351, -111.279396),vec3(24.287884, -1.010459, -7.274023),vec3(1.452758, 1.420957, 5.687492),vec3(8.489264, -1.049001, 3.595215),vec3(1.367703, -2.242889, 1.936624),vec3(-1.454126, 3.580603, 1.492250),vec3(2.313897, 10.627462, 1.114990),vec3(-4.958540, 1.337729, -1.580113),vec3(-2.835788, -1.076909, -8.645155),
	vec3(-2.314496, -1.770586, -1.422283),vec3(-1.092037, 2.516248, 16.861324),vec3(171.778534, -1.000055, -114.029198),vec3(-2.946398, -2.319974, 1.196071),vec3(1.003044, 122.916283, 12.916047),vec3(1.097461, -2.552583, 7.844795),vec3(-1.065652, -3.270433, 6.210892),vec3(-5.220143, -1.018935, -89.792648),vec3(4.248256, -1.996933, 1.200538),vec3(4.408532, -1.033955, -8.720737),vec3(-42.431999, 1.002236, 16.011549),vec3(2.493827, 1.105683, -6.862445),vec3(191.712418, -1.370556, -1.462370),vec3(-1.528449, -1.758849, -2.005249),vec3(-1.498016, -1.343905, 38.013096),vec3(13.338288, 1.591031, 1.291708),vec3(21.879620, 1.002303, -19.994776),vec3(10.390179, -3.035500, 1.064668),vec3(-30.287214, 1.285392, -1.593803),vec3(-1.533655, 1.352125, -5.989619),vec3(-39.825321, -1.003125, -13.374435),
	vec3(-4.118819, -1.204246, 1.994036),vec3(1.111644, 4.108416, -2.757313),vec3(1.836525, 1.267540, -3.511418),vec3(11.682436, 1.004631, 23.124146),vec3(1.174797, -1.980616, -6.980544),vec3(-67.070251, -1.000112, 926.538086),vec3(-1.240844, 3.605956, -1.911749),vec3(-41.972534, 1.001339, -21.800282),vec3(4.510581, 1.671969, 1.298451),vec3(-268.946625, 1.000008, 757.476990),vec3(8.679041, 1.273760, 1.643150),vec3(1.908017, 80.845047, 1.174310),vec3(5.909853, -1.017091, -14.597339),vec3(27.184891, -1.000924, 45.117699),vec3(4.340559, 1.058935, 4.258803),vec3(15.347030, 2.947228, 1.065623),vec3(-1.098021, -2.544861, 7.865767),vec3(-76.135010, 1.000796, 26.558962),vec3(5.931355, -1.083442, 2.890661),vec3(-2.357885, -9.287546, -1.112115),vec3(2.001142, -1.497089, -1.813360),
	vec3(-4.038395, 1.051048, -5.466718),vec3(3.724967, 1.215961, 1.993645),vec3(-4.906137, 44.193409, -1.021716),vec3(-6.884442, -1.034848, -4.707935),vec3(1.562867, 2.353525, 1.561630),vec3(-2.770056, 1.094474, 5.355649),vec3(-3.219591, -2.443261, 1.165622),vec3(-3.548023, 1.176904, 2.243971),vec3(-2.003770, -71.492981, -1.154128),vec3(-6.774895, 1.138853, 2.196901),vec3(5.611902, -1.018349, 15.892472),vec3(279.322693, 1.000060, -96.983543),vec3(1.141017, 2.133026, 9.085853),vec3(2.555943, -2.108059, 1.268059),vec3(-1.261493, 1.821777, -3.771523),vec3(-9.213096, 1.173546, -1.953237),vec3(6.161753, -1.125187, 2.332527),vec3(-1.006834, -36.039631, 8.853241),vec3(3.537464, 1.222587, 1.995754),vec3(36.223660, 53.496754, 1.000556),vec3(-1.972848, -1.346345, -2.285806),
	vec3(-2.296581, -1.764636, -1.429645),vec3(-2.045580, 1.913315, 1.431715),vec3(1.113642, 6.076995, 2.449984),vec3(-1.326449, -3.615392, -1.678029),vec3(-1.869757, 5.867909, 1.208318),vec3(2.931041, -1.105263, 3.922185),vec3(2.671128, 2.372070, 1.210791),vec3(3.510627, 1.784113, -1.285970),vec3(-14.794072, -1.002306, -191.441147),vec3(1.279103, -3.190932, -1.855098),vec3(-2.144487, 4.106029, 1.175869),vec3(-2.756396, -1.504963, 1.530578),vec3(2.470768, 1.542049, -1.551077),vec3(2.925377, -5.308282, 1.086149),vec3(-2.056936, -3.936291, 1.195990),vec3(9.271362, 1.017703, 6.614900),vec3(41.562683, -1.097912, -2.426583),vec3(-1.506497, 31.517759, 1.338251),vec3(-1.638425, 1.286060, 6.612586),vec3(1.104259, -2.702965, -4.820061),vec3(-39.469872, 1.149199, -2.032117),
	vec3(1.375365, 1.746096, 2.641083),vec3(6.161894, 7.993259, -1.021680),vec3(1.011319, 8.491735, -10.916665),vec3(-2.002807, 1.222828, -3.493397),vec3(88.864029, 1.020826, -4.983895),vec3(-2.718976, 1.332851, -1.820209),vec3(1.920118, 192.271072, 1.171424),vec3(-3.552675, -1.083392, -3.812698),vec3(-22.143229, -1.007597, 8.776042),vec3(17.884922, -1.245621, 1.684624),vec3(4.942977, -1.024353, -12.851492),vec3(-1.176775, 2.247874, 3.536226),vec3(-1.119316, 2.470386, 5.131744),vec3(6.123512, -1.062875, 3.368268),vec3(2.878090, -1.116450, 3.603630),vec3(2.906246, -3.021076, -1.138100),vec3(-1.439082, -1.858590, -2.095916),vec3(4.530697, 1.039868, -6.143646),vec3(1.029537, -4.595518, 10.422663),vec3(3.688581, 1.455774, -1.483082),vec3(-1.991430, 1.651237, 1.619905),
	vec3(1.733697, -1.228872, -13.998389),vec3(-2.329276, 1.290626, 2.154936),vec3(1.410953, -2.358657, 1.773496),vec3(1.275782, -1.647101, 7.669057),vec3(3.183149, 1.059256, 9.970302),vec3(-1.355461, -1.595622, 3.985855),vec3(-1.243220, -1.949448, 3.335806),vec3(5.683146, 17.376011, 1.017590),vec3(-1.097252, -2.430501, 88.666473),vec3(1.726566, 1.238856, 8.777350),vec3(5.913074, -1.034898, 5.149930),vec3(3.640125, 1.258291, 1.847621),vec3(-1.486693, 1.380372, -6.630418),vec3(15.531536, -1.007411, 9.752699),vec3(2.484260, 1.153586, -3.399784),vec3(9.938231, 1.005290, 51.879898),vec3(-1.034734, 5.357598, 5.664052),vec3(1.820298, 1.953969, 1.513961),vec3(-13.934628, -1.059857, -3.091764),vec3(-1.129023, -4.108448, -2.529791),vec3(-1.176312, -1.906178, 21.874281),
	vec3(7.658877, -3.804133, -1.046074),vec3(1.259409, 1.666319, -10.327133),vec3(12.157105, -1.271137, 1.634429),vec3(-1.710867, 7.409840, 1.249856),vec3(-24.180210, -1.090822, -2.516754),vec3(-1.168313, -1.963644, -11.157889),vec3(12.215133, 1.098370, 2.466340),vec3(-2.053378, -2.174211, -1.346825),vec3(2.015738, 1.158567, 10.607996),vec3(2.210679, -3.154266, 1.199632),vec3(1.484150, -2.313091, 1.668731),vec3(12.347451, 1.041857, 3.722205),vec3(-4.940486, -1.066982, 3.521405),vec3(-1.475842, 2.083832, 1.794327),vec3(3.513756, 2.364692, 1.162342),vec3(-8.778275, 3.454727, -1.052202),vec3(1.839629, -1.634213, -1.740587),vec3(1.273471, 1.652725, -7.608471),vec3(1.746346, 1.254495, -5.221380),vec3(-14.583526, -1.472499, 1.368326),vec3(-82.264473, 1.000179, 68.911293),
	vec3(7.629393, 1.025857, 5.538864),vec3(-9.086406, 1.006112, 928.377136),vec3(-1.269292, 2.339640, -2.255193),vec3(1.570346, 7.319230, -1.317826),vec3(1.451360, 1.792749, 2.161068),vec3(10.729997, 1.028224, -4.690188),vec3(-81.171242, -1.029250, -4.230350),vec3(-6.490640, 1.019227, -8.563469),vec3(4.111750, -1.542631, -1.385909),vec3(-1.451295, -1.469344, -4.014785),vec3(1.382133, 1.653911, 3.002237),vec3(-3.518876, 1.112055, -3.006722),vec3(-4.147465, -1.346483, 1.600669),vec3(56.235275, -1.000859, 26.733675),vec3(-1.414784, 4.222099, -1.500234),vec3(-11.226130, -1.004056, 88.228447),vec3(4.976660, -1.024141, 12.687828),vec3(1.508730, -1.382133, -5.184457),vec3(-30.114542, 1.001153, -28.883423),vec3(16.651508, 2.509211, -1.092674),vec3(-6.252684, 1.014640, 18.045324),
	vec3(-1.014915, 6.215506, 17.431259),vec3(-2.727015, 1.099092, 5.149081),vec3(-3.895455, -2.010469, -1.206750),vec3(1.104953, -2.400742, 11.591418),vec3(-1.486595, 5.267870, 1.398269),vec3(1.186789, -49.686378, 1.858224),vec3(-3.044626, 1.914523, 1.270718),vec3(1.543280, -1.428193, 3.335653),vec3(1.827186, -1.478856, -2.027645),vec3(2.894037, 1.246526, -2.053984),vec3(1.240812, 5.560914, -1.772901),vec3(-2.079396, -1.140553, 426.279846),vec3(-4.056658, -1.047863, 5.923423),vec3(1.000278, 712.634521, 42.537388),vec3(-2.890953, 1.294594, 1.877522),vec3(5.207606, -1.023053, 11.406842),vec3(2.772326, 1.220336, 2.245079),vec3(2.601891, -1.083837, -31.516344),vec3(-1.476791, 2.006142, 1.847407),vec3(1.612516, 1.423130, 2.866982),vec3(12.064325, 1.004493, -22.063740),
	vec3(5.695475, -1.017402, -17.993784),vec3(14.509955, 1.002758, -36.669807)
);
*/

_____

	// out_val = sample_heightmap(0, 0);

	/*
	const count_t count_over_max_x = total / max_x;

	const count_t
		inf_y = count_over_max_x / max_z,
		inf_z = count_over_max_x % max_z,
		inf_x = total % max_x;
	*/

_____

	/*
	char* fmtstr = malloc(100);
	for (int i = 0; i < 255; i++) {
		sprintf(fmtstr, "inv_rand_dirs[%d]", i);

		const GLint uniform = glGetUniformLocation(shader, fmtstr);

		const GLfloat* const v = inv_rand_dirs[i];
		glUniform3f(uniform, v[0], v[1], v[2]);

	}
	free(fmtstr);
	*/


	// DEBUG_VEC3(inv_rand_dirs[0]);

	/*
	for (int i = 0; i < 255; i++) {
		const GLfloat* const v = inv_rand_dirs[i];
		printf("vec3(%f, %f, %f),", v[0], v[1], v[2]);
		if (i % 21 == 0) {
			printf("\t");
		}
	}
	*/

_____

	INIT_UNIFORM_VALUE(test, shader, 3fv, 5, (vec3[5]) {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}, {13, 14, 15}});

_____

	INIT_UNIFORM_VALUE(inv_rand_dirs, shader, 3fv, num_trace_iters, inv_rand_dirs);

_____

	/* So, inputs and outputs:
	- Input: the heightmap, and the map size
	- Output: a 3D texture of occlusion values
	- No explicit per-vertex inputs; implied by the vertex id */

_____

	const GLuint ao_texture = preinit_texture(TexVolumetric, TexNonRepeating, TexLinear, TexTrilinear, false);
	init_texture_data(TexVolumetric, (GLsizei[]) {map_size[0], map_size[1], max_point_height}, GL_RED, GL_R8, GL_FLOAT, tf_output);
	glGenerateMipmap(TexVolumetric);

_____

	typedef uint64_t count_t;
	count_t vertex_id = 0;

	for (byte y = 0; y < max_y; y++) { // For each posible height
		for (byte z = 0; z < max_z; z++) { // For each map row
			for (byte x = 0; x < max_x; x++) { // For each map point
				byte* const dest = &ao_map[y][z][x];

				// Skipping points that are under the heightmap (TODO: add this back)
				/*
				if (y < sample_map_point(heightmap, x, z, max_x)) {
					*dest = 0;
					continue;
				}
				*/

				byte num_collisions = 0;

				for (byte i = 0; i < num_trace_iters; i++)
					num_collisions += ray_collides_with_heightmap(inv_rand_dirs[i], heightmap, x, y, z, max_x, max_y, max_z);
				
				const byte cpu_occlusion_value = constants.max_byte_value - (byte) (num_collisions * collision_term_scaler);
				(void) cpu_occlusion_value;

				//////////

				const GLuint gpu_num_colls = from_gpu[vertex_id];
				*dest = num_collisions;

				printf("CPU = %u, GPU = %u\n", num_collisions, gpu_num_colls);
				assert(num_collisions == gpu_num_colls);

				//////////

				/*
				const count_t count_over_max_x = vertex_id / max_x;

				const count_t inf_pos[3] = {vertex_id % max_x, count_over_max_x / max_z, count_over_max_x % max_z};
				assert(inf_pos[0] == x);
				assert(inf_pos[1] == y);
				assert(inf_pos[2] == z);
				*/

				vertex_id++;

				//////////
			}
		}
	}

	);

_____

		// for (GLsizei i = 0; i < num_inputs; i++) printf("%u ", tf_output[i]); putchar('\n');

_____

				const GLuint gpu_num_colls = (GLuint) calculated_with_the_gpu[vertex_id];
				assert(gpu_num_colls == sample_map_point(heightmap, x, z, max_x));
				continue;

_____

	/*
	const byte blank_width = 3, blank_height = 4;
	const byte blank_heightmap[blank_height][blank_width] = {
		{0, 0, 0},
		{0, 0, 0},
		{0, 0, 0},
		{0, 0, 0}
	};
	*/

_____

	bool cond = curr_tile[1] == -1 || curr_tile[1] < sample_height;

		bool cond2 = curr_tile[1] < sample_height;
		assert(cond == cond2);

		// TODO: the two checks here are unnecessary, since -1 is always smaller than the sample height

_____

	/*
	for (int i = 0; i < num_trace_iters; i++) {
		const GLfloat* const v = inv_rand_dirs[i];
		printf("\tvec3(%f, %f, %f),%s", v[0], v[1], v[2], (i % 20 == 0) ? "\n" : "");
	}
	puts("");
	*/

_____

vec3 bobs[] = vec3[](
	vec3(-1.195517, 4067.145996, -1.824717), vec3(5.925620, -1.015708, -21.265827),
	vec3(-3.458925, -1.166866, -2.344205),	vec3(17.502363, 1.004326, -13.695759),
	vec3(1.417295, 1.651466, 2.716485),	vec3(-2.009576, -2.018563, -1.404481)
);

_____

		/*
		the max extent y = 1
		the map width = 1
		the map height = 2
		*/

_____

				// const byte num_collisions = ray_collides_with_heightmap(inv_rand_dirs[1], heightmap, x, y, z, max_x, max_y, max_z);

_____

				// Skipping points that are under the heightmap (TODO: add this back)
				/*
				if (y < sample_map_point(heightmap, x, z, max_x)) {
					*dest = 0;
					continue;
				}
				*/

_____

	for (int i = 0; i < 3; i++) ao_strength = smoothstep(0.0f, 1.0f, ao_strength);

_____

	// curr_tile[0] += tile_steps[0];
	// curr_tile[1] += tile_steps[1];
	// curr_tile[2] += tile_steps[2];

_____


	/*
	SDL_Rect
		last_dest = {0, 0, normal_map_w, normal_map_h},
		dest = {normal_map_w, 0, normal_map_w >> 1, normal_map_h >> 1};
	*/

	SDL_Rect dest = {0, 0, normal_map_w, normal_map_h};
	SDL_Rect last_dest = dest;

	for (byte depth = 1; (dest.w != 0) && (dest.h != 0); depth++) {
		if (depth >= 2) dest.y += normal_map_h >> (depth - 1);

		printf("Copying to {%d, %d, %d, %d}\n", dest.x, dest.y, dest.w, dest.h);
		SDL_BlitScaled(mipmap_buffer, &last_dest, mipmap_buffer, &dest);
		// break;

		////////// This part renormalizes part of the mipmap buffer

		//////////

		last_dest = dest;

		dest.x = normal_map_w;
		dest.w >>= 1;
		dest.h >>= 1;
	}

_____

				/*
				glm_vec3_normalize(color);
				glm_vec3_scale(color, half_max_byte_value, color);
				glm_vec3_adds(color, half_max_byte_value, color);
				*/

				// normalize_color_to_rgb_range(color);

				/*
				printf("color before initial scaling is %.10f, %.10f, %.10f\n", (double) color[0], (double) color[1], (double) color[2]);

				glm_vec3_scale(color, one_over_scaler, color);

					printf("color before normalization (length = %.10f) is %.10f, %.10f, %.10f\n",
						(double) glm_vec3_norm(color), (double) color[0], (double) color[1], (double) color[2]);

				// glm_vec3_normalize(color);

				glm_vec3_scale(color, scaler, color);
					printf("color is %.10f, %.10f, %.10f\n---\n", (double) color[0], (double) color[1], (double) color[2]);
				*/

_____

				vec3 c = {
					(color[0] / 255.0f) * 2.0f - 1.0f,
					(color[1] / 255.0f) * 2.0f - 1.0f,
					(color[2] / 255.0f) * 2.0f - 1.0f,
				};

				DEBUG(glm_vec3_norm(c), f);

_____ Some uploading logic:

	/*
	printf("orig size = {%d, %d}\n", mips -> w, mips -> h);

	byte l = 1;

	int y = 0;
	do {
		GLint shifted_w = mips -> w >> l, shifted_h = mips -> h >> l;

		if (shifted_w == 0 || shifted_h == 0) break;

		printf("shifted size = {%d, %d}\n", shifted_w, shifted_h);

		DEBUG(type, d);
		if (type == TexPlain) {
			// void* pixels = NULL;
			// glTexImage2D(type, l, OPENGL_NORMAL_MAP_INTERNAL_PIXEL_FORMAT, shifted_w, shifted_h, 0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, pixels);
		}
		else {
			sdl_pixel_t* pixels = malloc(shifted_w * shifted_h * sizeof(sdl_pixel_t));

			for (int sy = y; sy <= sy + shifted_h; sy++)
				memcpy(pixels + sy * shifted_w, read_surface_pixel(mips, 0, y), shifted_w * shifted_h)

			free(pixels);
		}

		printf("y is %d\n", y);
		y += shifted_h;

		l++;
	} while (true);

	puts("---");
	*/

_____

	SDL_Surface* const mips = general_purpose_surface_1;
	if (type == TexSet) SDL_SaveBMP(mips, "mips.bmp");

_____ Some renormalization utils:


// TODO: to excluded
static void renormalize_normal_map_area(SDL_Surface* const normal_map, const SDL_Rect area) {
	SDL_PixelFormat* const format = normal_map -> format;

	const GLfloat normalized_range_scaler = 2.0f / constants.max_byte_value;

	WITH_SURFACE_PIXEL_ACCESS(normal_map,
		for (GLint y = area.y; y < area.y + area.h; y++) {
			for (GLint x = area.x; x < area.x + area.w; x++) {
				sdl_pixel_t* const pixel_dest = (sdl_pixel_t*) read_surface_pixel(normal_map, x, y);

				sdl_pixel_component_t r, g, b;
				SDL_GetRGB(*pixel_dest, format, &r, &g, &b);

				vec3 color; // This is downscaled from -1 to 1, or a bit outside (since it's unnormalized)
				glm_vec3_scale((vec3) {r, g, b}, normalized_range_scaler, color);
				glm_vec3_subs(color, 1.0f, color);

				normalize_vector_to_rgb_range(color);

				*pixel_dest = SDL_MapRGB(format,
					(sdl_pixel_component_t) color[0],
					(sdl_pixel_component_t) color[1],
					(sdl_pixel_component_t) color[2]
				);
			}
		}
	);
}

// TODO: to excluded
static void make_mipmap_of_normal_map(SDL_Surface* const normal_map, SDL_Surface* const mipmap_buffer) {
	TIME(
	/*
	static bool first_call = true;
	if (!first_call) return;
	first_call = false;
	*/

	// SDL_SaveBMP(normal_map, "orig.bmp");

	////////// A problem I have to deal with is that when copied, the image pixels must be in contigous memory

	// Writing the first mip level to the buffer
	SDL_Rect src = {0, 0, normal_map -> w >> 1, normal_map -> h >> 1};
	SDL_SoftStretchLinear(normal_map, NULL, mipmap_buffer, &src);
	renormalize_normal_map_area(mipmap_buffer, src);

	// Writing the rest of the levels to the buffer
	for (SDL_Rect dest = src; (dest.w != 0) || (dest.h != 0); src = dest) {
		dest.y += dest.h;
		dest.w >>= 1;
		dest.h >>= 1;

		SDL_SoftStretchLinear(mipmap_buffer, &src, mipmap_buffer, &dest);
		renormalize_normal_map_area(mipmap_buffer, dest);
	}
	);
	// SDL_SaveBMP(mipmap_buffer, "normalized.bmp");
}

_____

	// Writing the mip levels to #1, and renormalizing every step of the way
	make_mipmap_of_normal_map(general_purpose_surface_2, general_purpose_surface_1);

_____

static void normalize_vector_to_rgb_range(vec3 color) {
	const GLfloat half_max_byte_value = 0.5f * constants.max_byte_value;

	/* This first normalizes the color, and then converts
	the color from a range of (-1, 1) to (0, `max_byte_value`) */
	glm_vec3_normalize(color);
	glm_vec3_scale(color, half_max_byte_value, color);
	glm_vec3_adds(color, half_max_byte_value, color);
}

_____

	return vec4(0.0f, 1.0f, 0.0f, 1.0f) * diffuse(fragment_normal);

_____

// TODO: remove (returns if it hit)
static bool naive_tracer(const byte* const heightmap, const byte origin[3], const byte max_extents[3], const vec3 inv_dir) {
	vec3 dir;
	glm_vec3_div(GLM_VEC3_ONE, (GLfloat*) inv_dir, dir);

	GLfloat s = 0.0f;

	while (true) {
		const vec3 pos = {
			origin[0] + dir[0] * s,
			origin[1] + dir[1] * s,
			origin[2] + dir[2] * s
		};

		if (pos[0] < 0.0f || pos[2] < 0.0f) return false;
		if (pos[0] > max_extents[0] || pos[1] > max_extents[1] || pos[2] > max_extents[2]) return false;

		const byte sample_height = sample_map_point(heightmap, (byte) pos[0], (byte) pos[2], max_extents[0]);
		if (pos[1] < sample_height) return true;

		s += 0.00001f;
	}
}

_____

				// With this, the fast tracer behaves basically the same as the naive tracer

_____

				// printf("vid = %u, GPU num colls = %u\n", vid, gpu_num_colls);
				// assert(gpu_num_colls == vid);

				// DEBUG((GLuint) gpu_num_colls, u);
				/*
				printf("CPU = %u, GPU = %u, vertex ID = %u, pos = {%u, %u, %u}\n", num_collisions, (GLuint) gpu_num_colls, vid, x, y, z);
				assert(num_collisions == (GLuint) gpu_num_colls);
				*/

_____

				const uint32_t gpu_num_colls = (uint32_t) calculated_with_the_gpu[vid];
				DEBUG(gpu_num_colls, u);
				DEBUG((uint32_t) calculated_with_the_gpu[vid + 1], u);
				DEBUG((uint32_t) calculated_with_the_gpu[vid + 2], u);

_____


				/*
				- So the positions are the same
				- But the number of collisions turn out different
				- The first mismatch is always on <1, 0, 2> for trace iters <= 10
				- And all inv rand dirs have been verified to be the same
				- The heightmap has also been verified to be the same
				- One simple case that doesn't work for either is when testing a collision with just the first inv rand dir
				- The number of CPU and GPU iteration steps were verified as well
				- Overall, many more false negatives for the GPU

				- Raytracer variables:
				- x/y/z dir positve bools match
				- Ray length components match
				- Tile steps match

				- Doing `<=` for the sample height comparison fixes some cases
				*/
	
_____

	- Note: no `glFlush` needed after the `glDrawArrays` call, since `glGetBufferSubData` is blocking anyways

_____

		if (ray_length_components.x < ray_length_components.y)
			index_of_shortest = (ray_length_components.x < ray_length_components.z) ? 0u : 2u;
		else
			index_of_shortest = (ray_length_components.y < ray_length_components.z) ? 1u : 2u;

_____

		byte index_of_shortest;

		if (ray_length_components[0] < ray_length_components[1])
			index_of_shortest = (ray_length_components[0] < ray_length_components[2]) ? 0 : 2;
		else
			index_of_shortest = (ray_length_components[1] < ray_length_components[2]) ? 1 : 2;

_____
	
	/*
	DEBUG_FLOAT(cos_v);
	DEBUG_FLOAT(sin_v);
	DEBUG_FLOAT(cos_h);
	DEBUG_FLOAT(sin_h);
	*/

_____

	ON_FIRST_CALL(
	GLfloat vtest = 0.0f, htest = 0.0f;

	const GLfloat
		cos_v = cosf(vtest), sin_v = sinf(vtest),
		cos_h = cosf(htest), sin_h = sinf(htest);

	/*
	sin(0) = 0
	sin(pi) = 0
	sin(two_pi) = 0

	cos(pi / 2) = 0
	cos(3 pi / 2) = 0
	*/
	);

_____

	// if (v[0] == 0.0f || v[1] == 0.0f || v[2] == 0.0f) {
	
	for (int i = 0; i < 3; i++) {
		if (fabsf(v[i] - 0.0f) < 0.00001f) {
			puts("Bingo");
			return true;
		}
	}

_____

	const GLfloat hori_min = 0.0f, hori_max = TWO_PI, vert_min = 0.0f, vert_max = PI; // Flat hemisphere

_____

				int a = num_collisions * collision_term_scaler;
				a >>= 1;
				if (a > 255) a = 255;
				*dest = constants.max_byte_value - a;
				continue;

_____

	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	INIT_SHADER_BRANCH(shader, branch, G);

_____

	// printf("v = {%f, %f, %f}\n", (double) v[0], (double) v[1], (double) v[2]);

_____

		/*
		#define vset(x, y, z, dest) glm_vec3_copy((vec3) {x, y, z}, dest)
		vset(0.0001f, 1.0f, 0.0001f, v);
		#undef vset
		glm_vec3_normalize(v);
		printf("v = {%f, %f, %f}\n", (double) v[0], (double) v[1], (double) v[2]);
		*/

_____


	// printf("hori = %f, vert = %f\n", (double) angles -> hori, (double) angles -> vert);
	/*
	const Uint8* const keys = SDL_GetKeyboardState(NULL);
	TWEAK_REALTIME_VALUE(v, 0.0f, 0.0f, 10.0f, 0.01f, T, Y, U);
	angles -> vert = v;
	angles -> vert = HALF_PI;
	*/

_____

	/*
	const signed_byte
		tl = height_difference_samples[0][0], tm = height_difference_samples[0][1], tr = height_difference_samples[0][2],
		ml = height_difference_samples[1][0], 										mr = height_difference_samples[1][2],
		bl = height_difference_samples[2][0], bm = height_difference_samples[2][1], br = height_difference_samples[2][2];
	*/

_____

	/*
	const signed_byte
		dx = (-tl - (ml << 1) - bl) + (tr + (mr << 1) + br),
		dz = (-tl - (tm << 1) - tr) + (bl + (bm << 1) + br);
	*/

_____

	//////////

	const kernel_t kernel_x = {
		{1, 0, -1},
		{2, 0, -2},
		{1, 0, -1}
	},

	kernel_y = {
		{1, 2, 1},
		{0, 0, 0},
		{-1, -2, -1}
	};

	const int16_t
		dx = convolution_op(kernel_x, height_difference_samples),
		dz = convolution_op(kernel_y, height_difference_samples);
	
	printf("dx = %d, dz = %d\n", dx, dz);
	
	const float angle = atan2(dz, dx);
	DEBUG_FLOAT(glm_deg(angle));

	// printf("dx, dz = %d, %d\n", dx, dz);
	vec3 vector = {dx, 0.0f, dz}; glm_vec3_normalize(vector); // When there's a derivative of zero, make the vector point up
	printf("vector = {%f, %f, %f}\n", (double) vector[0], (double) vector[1], (double) vector[2]);

	// Perhaps a simpler solution - one without the Sobel operator - only need 4 samples in total? Yes, sample 3 values backwards, and then find a vector from there.

	//////////

	puts("height_difference_samples = {");

	for (byte oz = 0; oz < 3; oz++) {
		for (byte ox = 0; ox < 3; ox++)
			printf("%d ", height_difference_samples[oz][ox]);
		putchar('\n');
	}

	puts("}");

	puts("---");

_____

// TODO: remove from the global scope
enum {kernel_size = 3};
typedef int16_t kernel_t[kernel_size][kernel_size];

// TODO: to excluded
static int16_t convolution_op(const kernel_t kernel, const kernel_t samples) {
	const int16_t
		a = samples[0][0], b = samples[0][1], c = samples[0][2],
		d = samples[1][0], e = samples[1][1], f = samples[1][2],
		g = samples[2][0], h = samples[2][1], i = samples[2][2];
	
	return
		i * kernel[0][0] + h * kernel[0][1] + g * kernel[0][2] +
		f * kernel[1][0] + e * kernel[1][1] + d * kernel[1][2] +
		c * kernel[2][0] + b * kernel[2][1] + a * kernel[2][2];
}

_____

	#define CLAMP(x, low, high) do {\
		if ((x) < (low)) (x) = (low);\
		else if ((x) > (high)) (x) = (high);\
	} while (false)

_____

	enum {kernel_size = 3};
	typedef int16_t kernel_t[kernel_size][kernel_size];

_____

	/*
	const int16_t
		left_sample_diff = left_height - y,
		top_sample_diff = top_height - y,
		top_left_sample_diff = top_left_height - y;
	
	printf("Left sample diff: %d\n", left_sample_diff);
	printf("Top sample diff: %d\n", top_sample_diff);
	printf("Top left sample diff: %d\n", top_left_sample_diff);

_____

	/*
	if (map_y_sign_difference != 0) {
		// Sometimes, above will yield in a good normal (so remove some of this logic)
		const GLchar* const problem = (map_y_sign_difference == 1) ? "above" : "below";
		printf("No normal to calculate; y %s heightmap\n", problem);
		glm_vec3_zero(normal);
		return;
	}
	*/

____

	// if (sign_difference_x == 0 && sign_difference_z == 0 && top_le)

	// printf("Sign difference x and z: %d, %d\n", sign_difference_x, sign_difference_z);

	//////////

	/*
	- Also manage a partial y in some way (perhaps through the top left height?)
	- And this configuration too: (normal is not correctly calculated at the moment).
		2, 1
		1, 1
	- Slant the y at the bottom and top y.
	*/

_____

	if (sign_differences.x == 0 && sign_differences.z == 0 && sign_differences.corner == 0) {
		// TODO: avoid this stmt in some way (implicit logic)
		puts("On a fully flat surface; setting to y up vector");
		glm_vec3_copy(GLM_YUP, normal);
	}
	else {
		printf("Setting to vector to be normalized; final diffs = %d, %d, %d\n", sign_differences.x, y_slant, sign_differences.z);
		normal[0] = sign_differences.x;
		normal[1] = y_slant;
		normal[2] = sign_differences.z;
		glm_vec3_normalize(normal);
	}

_____

	// if (sign_differences.x <= 0 && sign_differences.z <= 0) {
	if (sign_differences.corner == 1) {
		puts("Setting to special corner normal");
		sign_differences.x = sign_differences.corner; // TODO: set these in one go
		sign_differences.z = sign_differences.corner;
		if (sign_differences.origin == 0) {
			puts("Adding slant b/c at a special corner's base");
			y_slant = 1; // If at the base, do a y slant, since joining with the ground and a corner
		}
		// Also do for top y
	}
	else {
		puts("No special corner normal");
		/*
		puts("No special corner normal");
		if (sign_differences.x == 0 || sign_differences.z == 0) {
			puts("Adding slant b/c at a base");
			y_slant = 1;
		}
		*/
	}

_____

		if (sign_differences.x != 0) {
			y_slant = sign_differences.x;
		}
		else if (sign_differences.x != 0) {
			y_slant = sign_differences.z;
		}

_____

	typedef struct {
		const byte neighbor_samples[2][2];
		const vec3 expected_normal;
	} UnitTestUnit;

_____

	const byte x = 1, y = 3, z = 1;

	byte neighbors[2][2];
	get_neighbors((const byte*) heightmap, x, z, map_width, neighbors);

_____

// TODO: to excluded
static void normal_inference_unit_test(void) {
	// TODO: a unit test with a small map + a 3D normal dataset

	enum {map_width = 5, map_height = 4};

	const byte heightmap[map_height][map_width] = {
		{3, 7, 3, 3, 3},
		{7, 7, 3, 2, 3},
		{3, 3, 3, 3, 3},
		{3, 3, 3, 3, 3}
	};

	const vec3 expected_normals[map_width] = {
		{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.707107f, 0.707107f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}
	};

	const byte start_x = 1, y = 3, z = 1;

	for (byte x = start_x; x < map_width; x++) {
		byte neighbors[2][2];
		get_neighbors((const byte*) heightmap, x, z, map_width, neighbors);

		printf("neighbors:\n%d, %d\n%d, %d\n-\n", neighbors[0][0], neighbors[0][1], neighbors[1][0], neighbors[1][1]);

		vec3 normal;
		normal_inference(neighbors, y, normal);

		DEBUG_VEC3(normal);

		const GLfloat* const expected_normal = expected_normals[x];
		DEBUG_VEC3(expected_normal);

		assert(glm_vec3_eqv_eps(normal, (GLfloat*) expected_normal));

		puts("---");

		#undef PRINT_VEC3
	}
}

_____

	/*
	{{{0, 0},
	  {0, 0}}, 0, _},
	*/

_____


	/*
	printf("y = %hhu\nneighbors =\n\t%hhu, %hhu\n\t%hhu, %hhu\n",
		y, neighbor_heights.top_left, neighbor_heights.top,
		neighbor_heights.left, neighbor_heights.at_y);
	*/
	
_____

	if (above_heightmap_at_origin && !all_heights_are_the_same) {
		// normal[1] = 0.0f;

		// normal[0] = sign_differences.x;
		// normal[2] = 0.0f;
		/*
		puts("Handle this case");
		normal[0] = sign_differences.x;
		normal[1] = 0.0f;
		normal[2] = sign_differences.z;
		return;
		*/
	}

_____

	else if (above_heightmap_at_origin && !all_heights_are_the_same) {
		printf("Vertex pos over the top map value. "
			"Because of that, incorrect sign differences (x and z): %d, %d.\n",
			sign_differences.x, sign_differences.z);
		
		// If y has the same height as the top left corner, set the corner sign difference to be 1
		if (y == neighbor_heights.top_left) sign_differences.corner = 1; // TODO: don't modify this

		// For direct neighbors, if y is above them, invalidate them
		if (y > neighbor_heights.left) sign_differences.x = 0;
		if (y > neighbor_heights.top) sign_differences.z = 0;
	}

	if (sign_differences.x == 0 && sign_differences.z == 0)
		sign_differences.x = sign_differences.z = sign_differences.corner;

_____

			1. Only store a yaw and pitch angle, and then remap them and create a new vector in each inner loop iteration
			2. Store random vectors in a unit sphere (already done), and then remap vectors to hemisphere orientations (via absolute value?)
			3. Only store hemispheres, and then remapping from that hemisphere should be easier
			4. Or, based on the normals, generate a coefficient to multiply the final sample amount by (but that would mean that a lot of samples are wasted)
		- A simple selection method: for a given face normal, reject a random vector if it is facing the opposite way of the normal (i.e. if dot(rand, normal) < 0)

_____

	const GLuint t = init_plain_texture(ASSET_PATH("objects/donkeykong.bmp"), TexPlain, TexNonRepeating, TexNearest, TexNearest, OPENGL_DEFAULT_INTERNAL_PIXEL_FORMAT);
	const GLuint nmp = init_normal_map_from_diffuse_texture(t, TexPlain, &(NormalMapConfig) {.blur_radius = 5, .blur_std_dev = 2.0f, .intensity = 3.0f});
	glDeleteTextures(2, (GLuint[2]) {t, nmp});
	GL_ERR_CHECK;

_____

					mat3 image = {
						{tl, tm, tr},
						{ml, 0.0f, mr},
						{bl, bm, br}
					};

					mat3 kx = {
						{-1, 0, 1},
						{-2, 0, 2},
						{-1, 0, 1}
					};

					mat3 ky = {
						{1, 2, 1},
						{0, 0, 0},
						{-1, -2, -1}
					};

					float bx = convolution_op(kx, image);
					float by = convolution_op(ky, image);

					/*
					DEBUG_FLOAT(bx);
					DEBUG_FLOAT(normal[0]);
					putchar('\n');

					DEBUG_FLOAT(by);
					DEBUG_FLOAT(normal[1]);
					puts("---");
					*/

					/*
					assert(glm_eq(normal[0], bx));
					assert(glm_eq(normal[1], by));
					*/

					/*
					normal[0] = bx;
					normal[1] = by;
					*/

_____

static float convolution_op(const float kernel[3][3], const float samples[3][3]) {
	const float
		a = samples[0][0], b = samples[0][1], c = samples[0][2],
		d = samples[1][0], e = samples[1][1], f = samples[1][2],
		g = samples[2][0], h = samples[2][1], i = samples[2][2];
	
	return
		i * kernel[0][0] + h * kernel[0][1] + g * kernel[0][2] +
		f * kernel[1][0] + e * kernel[1][1] + d * kernel[1][2] +
		c * kernel[2][0] + b * kernel[2][1] + a * kernel[2][2];
}

_____


	vec3 a = {1.0f, 9.0f, 2.0f};
	glm_vec3_normalize(a);
	DEBUG_VEC3(a);

	vec3 b;
	glm_vec3_add(a, a, b);

	DEBUG_VEC3(b);

	glm_vec3_normalize(b);
	DEBUG_VEC3(b);

_____

typedef struct {
	const struct {const GLchar *const scrolling_background, *const foreground;} paths;
	const NormalMapConfig normal_map_config;
} TitleScreenConfig;

_____

#define gl_deinit(suffix, object) glDelete##suffix##s(1, &(object))

_____

// TODO: to excluded
static void init_3D_texture_subdata(const GLsizei size[3], const GLenum input_format, const GLint internal_format,
	const GLenum color_channel_type, const void* const pixels) {

	const GLint level = 0, offset = 0;

	glTexSubImage3D(TexSet, level, offset, offset, offset, size[0], size[1], size[2], input_format, color_channel_type, pixels);
}

_____

	const GLuint vertex_buffer_for_shadow_map = init_gpu_buffer();
	use_vertex_buffer(vertex_buffer_for_shadow_map);
	init_vertex_buffer_data(mesh_cpu.length, sizeof(face_mesh_t), mesh_cpu.data, GL_STATIC_DRAW);

_____

	use_vertex_buffer(sector_context -> vertex_buffer_for_shadow_map);
	use_vertex_spec(drawable -> vertex_spec);

	const GLsizei num_vertices = (GLsizei) (num_face_meshes * vertices_per_face);
	ON_FIRST_CALL(
		printf("Drawing %d vertices\n", num_vertices);
	);

	glDisableVertexAttribArray(1);
	draw_primitives(GL_TRIANGLES, num_vertices);
	glEnableVertexAttribArray(1);

_____ An old unit test for normal inference:

// TODO: to excluded
static void normal_inference_unit_test(void) {
	(void) get_neighbors;

	enum {mw = 5, mh = 5};
	const byte heighmtap[mh][mw] = {
		{0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0},
		{0, 0, 3, 4, 0},
		{0, 0, 5, 6, 0},
		{0, 0, 0, 0, 0}
	};

	return;

	//////////

	typedef struct {
		const byte neighbors[2][2], y;
		const vec3 expected_normal;
	} NeighborTest;

	#define NO_NORMAL {0.0f, 0.0f, 0.0f}

	#define POS_X {1.0f, 0.0f, 0.0f}
	#define POS_Y {0.0f, 1.0f, 0.0f}
	#define POS_Z {0.0f, 0.0f, 1.0f}

	#define NEG_X {-1.0f, 0.0f, 0.0f}
	#define NEG_Y {0.0f, -1.0f, 0.0f}
	#define NEG_Z {0.0f, 0.0f, -1.0f}

	#define POS_X_AT_BASE {0.707107f, 0.707107f, 0.0f}
	#define POS_Z_AT_BASE {0.0f, 0.707107f, 0.707107f}

	#define NEG_X_AT_BASE {-0.707107f, 0.707107f, 0.0f}
	#define NEG_Z_AT_BASE {0.0f, 0.707107f, -0.707107f}

	#define POINTING_TO_LOWER_CORNER_AT_BASE {-0.57735f, 0.57735f, -0.57735f}
	#define POINTING_FROM_HIGHER_CORNER_AT_BASE {0.57735f, 0.57735f, 0.57735f}
	#define POINTING_FROM_HIGHER_CORNER_AT_TOP POINTING_FROM_HIGHER_CORNER_AT_BASE
	#define POINTING_FROM_ORIGIN_AT_TOP POINTING_TO_LOWER_CORNER_AT_BASE
	#define POINTING_FROM_HIGHER_CORNER_TO_LEFT_AT_TOP {-0.57735f, 0.57735f, 0.57735f}

	#define POS_XZ_AT_BASE_FROM_WALL_MIDDLE  {0.707107f, 0.0f, 0.707107f}

	const NeighborTest tests[] = {
		{{{5, 5}, // Below heightmap
		  {5, 5}}, 4, NO_NORMAL},

		{{{5, 5}, // Above heightmap
		  {5, 5}}, 6, NO_NORMAL},

		{{{5, 5},
		  {5, 5}}, 5, POS_Y},

		{{{7, 4},
		  {7, 4}}, 4, POS_X_AT_BASE},

		{{{8, 8},
		  {4, 4}}, 4, POS_Z_AT_BASE},

		{{{4, 5},
		  {4, 5}}, 5, NEG_X_AT_BASE},

		{{{4, 4},
		  {5, 5}}, 5, NEG_Z_AT_BASE},

		{{{4, 5},
		  {5, 5}}, 5, POINTING_TO_LOWER_CORNER_AT_BASE},

		{{{5, 5},
		  {5, 4}}, 4, POINTING_FROM_HIGHER_CORNER_AT_BASE},

		// These are cases for when a point is on the middle (or on the top edge) of a vert wall

		{{{8, 2},
		  {8, 2}}, 5, POS_X},

		{{{2, 2}, // THIS EXPECTED IS WRONG!!!!!!!!!!!!!!!!
		  {8, 2}}, 5, {-0.707107f, 0.0f, 0.707107f}},

		{{{2, 8},
		  {2, 8}}, 5, NO_NORMAL},

		{{{8, 8},
		  {2, 2}}, 5, POS_Z},

		{{{2, 2},
		  {8, 8}}, 5, NO_NORMAL},

		{{{8, 2},
		  {2, 2}}, 5, POS_XZ_AT_BASE_FROM_WALL_MIDDLE},

		{{{8, 2},
		  {2, 2}}, 7, POS_XZ_AT_BASE_FROM_WALL_MIDDLE},

		{{{8, 2},
		  {2, 2}}, 8, POINTING_FROM_HIGHER_CORNER_AT_TOP},

		{{{8, 2},
		  {2, 2}}, 9, NO_NORMAL},

		{{{2, 2},
		  {2, 8}}, 9, NO_NORMAL},

		{{{2, 2},
		  {2, 8}}, 8, POINTING_FROM_ORIGIN_AT_TOP},

		{{{2, 8},
		  {2, 2}}, 9, NO_NORMAL},

		{{{8, 8}, // WRONG RESULT!!!!!
		  {2, 2}}, 8, {0.0f, 0.707107f, 0.707107f}},

		{{{2, 8}, // WRONG RESULT!!!!!
		  {2, 2}}, 7, {-0.57735f, 0.57735f, 0.57735f}},

		// What about top corners with different directions? Test that as well.
	};

	// Idea (maybe don't do): perhaps make a bitmask from the height difference states, and do a switch stmt? Think about that later.

	//////////

	for (size_t i = 0; i < ARRAY_LENGTH(tests); i++) {
		const NeighborTest test = tests[i];

		printf("neighbors = %hhu, %hhu\n            %hhu, %hhu\ny = %hhu\n",
			test.neighbors[0][0], test.neighbors[0][1], test.neighbors[1][0], test.neighbors[1][1], test.y);

		vec3 inferred_normal;
		normal_inference(test.neighbors, test.y, inferred_normal);

		const size_t test_id = i + 1;

		if (!glm_vec3_eqv_eps(inferred_normal, (GLfloat*) test.expected_normal)) {
			DEBUG_VEC3(test.expected_normal);
			DEBUG_VEC3(inferred_normal);
			fprintf(stderr, "--- Failed test #%zu\n\n", test_id);
			abort();
		}

		printf("--- Passed test #%zu with inferred normal {%f, %f, %f}\n\n",
			test_id, (GLdouble) inferred_normal[0], (GLdouble) inferred_normal[1],
			(GLdouble) inferred_normal[2]);
	}
}

_____ And some other normal inference code:

// TODO: to excluded
static signed_byte sign_difference(const byte a, const byte b) {
	if (a > b) return -1;
	else if (b > a) return 1;
	else return 0;
}

// TODO: to excluded
static void get_neighbors(const byte* const heightmap, const byte x, const byte z, const byte max_x, byte neighbors[2][2]) {
	const byte left_x = (x == 0) ? 0 : (x - 1), top_z = (z == 0) ? 0 : (z - 1);

	neighbors[0][0] = sample_map_point(heightmap, left_x, top_z, max_x); // Top left
	neighbors[0][1] = sample_map_point(heightmap, x, top_z, max_x); // Top
	neighbors[1][0] = sample_map_point(heightmap, left_x, z, max_x); // Left
	neighbors[1][1] = sample_map_point(heightmap, x, z, max_x); // At y
}

// TODO: to excluded, and add back the const qualifiers
static void normal_inference(const byte neighbors[2][2], const byte y, vec3 normal) {
	const struct {const byte top_left, top, left, origin;} neighbor_heights = {
		.top_left = neighbors[0][0], .top = neighbors[0][1], .left = neighbors[1][0], .origin = neighbors[1][1]
	};

	const byte origin_h = neighbor_heights.origin;

	struct {const signed_byte x, z, corner, origin;} sign_diffs = {
		.x = sign_difference(origin_h, neighbor_heights.left),
		.z = sign_difference(origin_h, neighbor_heights.top),
		.corner = sign_difference(origin_h, neighbor_heights.top_left),
		.origin = sign_difference(y, neighbor_heights.origin)
	};

	//////////////////////////////////////////////////////////////////////////////////////////

	/*
	vec3 normal = vec3(2.0f * (center_right - center_left), 2.0f * (center_down - center_up), -4.0f);
	glm_vec3_normalize(normal);

	// center_right = origin, left = left, 
	// down = 
	*/

	vec3 n;

	// center_r = right, center_l = left, center_d = 

	//////////////////////////////////////////////////////////////////////////////////////////

	////////// Some boolean initialization

	const bool
		below_heightmap_at_origin = sign_diffs.origin == 1,
		above_heightmap_at_origin = sign_diffs.origin == -1,
		touching_heightmap_at_origin = sign_diffs.origin == 0,
		touching_corner_at_top = y == neighbor_heights.top_left,
		touching_top_at_top = y == neighbor_heights.top,
		touching_left_at_top = y == neighbor_heights.left,

		all_heights_are_the_same =
			sign_diffs.origin == sign_diffs.x &&
			sign_diffs.origin == sign_diffs.z &&
			sign_diffs.origin == sign_diffs.corner;

	const bool
		above_all_heights =
			above_heightmap_at_origin &&
			sign_diffs.x == -1 &&
			sign_diffs.z == -1 &&
			sign_diffs.corner == -1;

	////////// First special cases

	if (below_heightmap_at_origin || above_all_heights) {
		glm_vec3_zero(normal);
		return;
	}

	else if (all_heights_are_the_same) { // Here, the normal is the Y up vector
		glm_vec3_copy(GLM_YUP, normal);
		return;
	}

	////////// Second special case

	struct {signed_byte x, z, corner;} flow = {sign_diffs.x, sign_diffs.z, sign_diffs.corner};

	if (flow.x == 0 && flow.z == 0) {
		flow.x = flow.corner;
		flow.z = flow.corner;
	}

	/*
	// If y is above the origin height, and not all heights are the same,
	// the normal will be situated on a wall without slant
	if (above_heightmap_at_origin) {
		puts("Above heightmap at origin");

		// If y has the same height as the top left corner, set the corner sign difference to be 1
		if (y == neighbor_heights.top_left) {
			puts("Setting corner sign diff");
			flow.corner = 1;
		}

		// For direct neighbors, if y is above them, invalidate them
		if (y > neighbor_heights.left) {
			puts("Invalidating x b/c y is over the left value");
			flow.x = 0;
		}
		if (y > neighbor_heights.top) {
			puts("Invalidating z b/c y is over the top value");
			flow.z = 0;
		}
	}

	if (flow.x == 0 && flow.z == 0) {
		printf("Setting to x (%hhd) and z (%hhd) to the corner flow, which is %hhd\n", flow.x, flow.z, flow.corner);
		flow.x = flow.z = flow.corner;
	}
	*/

	//////////

	// If at the base, and any sign difference isn't zero, the y slant will be 1/true
	const bool y_slant = touching_heightmap_at_origin || touching_corner_at_top || touching_top_at_top || touching_left_at_top;
		// && (flow.x || flow.z || flow.corner);

	printf("Flow (x, z, y): %hhd, %hhd, %hhd\n", flow.x, flow.z, y_slant);

	normal[0] = flow.x;
	normal[1] = y_slant;
	normal[2] = flow.z;

	glm_vec3_normalize(normal);
}

_____ Some old AO map generation code for the GPU


// TODO: to excluded
static void hook_before_linking(const GLuint shader) {
	const GLchar* const outputs[] = {"occlusion_sum"};
	glTransformFeedbackVaryings(shader, ARRAY_LENGTH(outputs), outputs, GL_INTERLEAVED_ATTRIBS);
}

// TODO: to somewhere
static GLfloat* init_gpu_ao_map(const byte* const heightmap, const byte max_extents[3], const vec3* const inv_rand_dirs) {
	typedef GLfloat output_t;

	const byte map_width = max_extents[0], max_y = max_extents[1], map_height = max_extents[2];

	const GLsizei num_outputs = map_width * map_height * max_y;
	const GLsizei output_size = num_outputs * (GLsizei) sizeof(output_t);

	//////////

	const GLuint shader = init_shader(ASSET_PATH("shaders/ao_raytracer.vert"), NULL, NULL, hook_before_linking);
	use_shader(shader);

	INIT_UNIFORM_VALUE(num_trace_iters, shader, 1ui, num_trace_iters);
	INIT_UNIFORM_VALUE(max_y, shader, 1ui, max_y);

	//////////

	UniformBuffer ubo = init_uniform_buffer(GL_STATIC_DRAW, "InvRandDirs", shader, (const GLchar*[]) {"inv_rand_dirs"}, 1);

	bind_uniform_buffer_to_shader(&ubo, shader);
	enable_uniform_buffer_writing_batch(&ubo, true);
	write_array_of_primitives_to_uniform_buffer(&ubo, "inv_rand_dirs", (List) {.data = (vec3*) inv_rand_dirs, .item_size = sizeof(vec3), .length = num_trace_iters});
	disable_uniform_buffer_writing_batch(&ubo);

	const GLuint tbo = init_gpu_buffer();
	use_vertex_buffer(tbo);
	init_vertex_buffer_data(1, output_size, NULL, GL_STATIC_READ);
	glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, tbo);

	//////////

	const GLuint heightmap_texture = preinit_texture(TexPlain, TexNonRepeating, TexNearest, TexNearest, true);

	GLint standard_unpack_alignment;
	glGetIntegerv(GL_UNPACK_ALIGNMENT, &standard_unpack_alignment);

	glPixelStorei(GL_UNPACK_ALIGNMENT, sizeof(byte)); // TODO: specify the format in texture.h, and use sRGB
		init_texture_data(TexPlain, (GLsizei[]) {max_extents[0], max_extents[2]}, GL_RED_INTEGER, GL_R8UI, OPENGL_COLOR_CHANNEL_TYPE, heightmap);
	glPixelStorei(GL_UNPACK_ALIGNMENT, standard_unpack_alignment);

	use_texture_in_shader(heightmap_texture, shader, "heightmap_sampler", TexPlain, TU_Temporary);

	//////////

	output_t* const tf_output = alloc(1, (size_t) output_size);

	// TODO: output into a 3D texture on the GPU, instead of on the CPU, so that CPU -> GPU -> CPU doesn't have to happen
	WITH_BINARY_RENDER_STATE(GL_RASTERIZER_DISCARD,
		glBeginTransformFeedback(GL_POINTS);
			draw_primitives(GL_POINTS, num_outputs);
		glEndTransformFeedback();
	);

	glGetBufferSubData(GL_TRANSFORM_FEEDBACK_BUFFER, 0, output_size, tf_output);

	//////////

	deinit_uniform_buffer(&ubo);
	deinit_texture(heightmap_texture);
	deinit_gpu_buffer(tbo);
	deinit_shader(shader);

	return tf_output;
}

_____

	GLfloat* const calculated_with_the_gpu = init_gpu_ao_map(heightmap, (byte[3]) {max_x, max_y, max_z}, inv_rand_dirs);
	uint32_t vid = 0;

_____

// GLuint gpu_num_collisions = (GLuint) calculated_with_the_gpu[vid];
// assert(num_collisions == gpu_num_collisions);
// *dest = constants.max_byte_value - (byte) ((byte) gpu_num_collisions * collision_term_scaler);

dealloc(calculated_with_the_gpu);

_____ The AO raytracer:

#version 400 core
#define MAX_NUM_TRACE_ITERS 255u // Since the max byte size is 255

out float occlusion_sum;

layout(packed) uniform InvRandDirs {
	vec3 inv_rand_dirs[MAX_NUM_TRACE_ITERS];
};

uniform uint num_trace_iters, max_y; // This must not exceed `MAX_NUM_TRACE_ITERS`
uniform usampler2D heightmap_sampler;

uint sample_heightmap(ivec2 xz) {
	return texelFetch(heightmap_sampler, xz, 0).r;
}

// TODO: return type to bool
// See https://github.com/cgyurgyik/fast-voxel-traversal-algorithm/
float ray_collides_with_heightmap(const uvec2 max_xz, const uvec3 origin, const vec3 inv_dir) {
	// `curr_tile` is signed b/c it may go out of bounds on the lower side
	ivec3 tile_steps = ivec3(sign(inv_dir)), curr_tile = ivec3(origin);

	vec3
		unit_step_size = abs(inv_dir), // For `ray_length_components`, keeping components that are > 0
		ray_length_components = inv_dir * vec3(equal(tile_steps, ivec3(1)));

	while (true) {
		// Will yield 1 if x >= y, and 0 if x < y (so this gives the index of the smallest among x and y)
		uint x_and_y_min_index = uint(ray_length_components.x >= ray_length_components.y);
		uint index_of_shortest = (ray_length_components[x_and_y_min_index] < ray_length_components.z) ? x_and_y_min_index : 2u;

		curr_tile[index_of_shortest] += tile_steps[index_of_shortest];
		ray_length_components[index_of_shortest] += unit_step_size[index_of_shortest];

		//////////

		if ((curr_tile.y > max_y) // TODO: only check the component that changed
			|| (curr_tile.x == -1) || (curr_tile.x == max_xz.x)
			|| (curr_tile.z == -1) || (curr_tile.z == max_xz.y)) return float(false);

		// TODO: remove the cast
		else if (curr_tile.y < int(sample_heightmap(curr_tile.xz))) return float(true);
	}
}

void main(void) {
	/*
	num_trace_iters; heightmap_sampler; max_y; inv_rand_dirs;
	occlusion_sum = gl_VertexID;
	return;
	*/

	uvec2 max_xz = textureSize(heightmap_sampler, 0);
	uint count_over_max_x = gl_VertexID / max_xz.x;

	uvec3 origin = uvec3(
		gl_VertexID % max_xz.x,
		count_over_max_x / max_xz.y,
		count_over_max_x % max_xz.y
	);

	//////////

	occlusion_sum = 0.0f;
	
	// if (origin.y < sample_heightmap(ivec2(origin.xz))) return; // If inside a block

	for (uint i = 0; i < num_trace_iters; i++)
		occlusion_sum += ray_collides_with_heightmap(max_xz, origin, inv_rand_dirs[i]);
	// occlusion_sum /= num_trace_iters;
}

_____

vec2 retranslate_UV(const vec2 untranslated_UV) {
	/*
	bvec3
		in_top_left_extent = bvec3(step(UV_translation_area[0], fragment_pos_world_space)),
		in_bottom_right_extent = bvec3(step(fragment_pos_world_space, UV_translation_area[1]));

	bool in_translation_area = (in_top_left_extent == in_bottom_right_extent) == true;
		// && in_bottom_right_extent == bvec3(true);

	return UV_translation * float(in_translation_area) + untranslated_UV;
	*/

	// bool in_area = vertex_pos_world_space == UV_translation_area[0] || vertex_pos_world_space == UV_translation_area[1];

	UV_translation_area;

	bool in_area = false;

	// if (vertex_pos_world_space.x > 0.0f && vertex_pos_world_space.z > 0.0f && vertex_pos_world_space.x < 5.0f && vertex_pos_world_space.z < 5.0f) in_area = true;
	/*
	if (vertex_pos_world_space == vec3(4.0f, 0.0f, 1.0f)
		||
		vertex_pos_world_space == vec3(6.0f, 0.0f, 2.0f)
	) in_area = true;
	*/

	vec3 source = vec3(0, 0, 0), dest = vec3(1, 3, 1);
	vec3 v = vertex_pos_world_space;

	if (all(greaterThanEqual(v, vec3(5, 5, 5)))) in_area = true;

	// if (all(greaterThanEqual(v, source)) && all(lessThan(v, dest))) in_area = true;
	// if (v >= source || v <= dest) in_area = true;

	return UV_translation * float(in_area) + untranslated_UV;
}

_____

		// + y_displacement_map[(byte) (pos[2] * map_width + pos[0])];

_____

	// bool valid = (face_id == 0u) && (texture_id == 11u) && (vertex_pos_world_space.y == 0.0f);

_____

	bool valid =
		// (face_id == 0u) &&
		(texture_id == correct_texture_id) &&
		(vertex_pos_world_space.y == 0.0f);

_____

	const byte test = 0b01111111;
	DEBUG(test, hhu);

	byte bob = 0b10101010;
	bob &= test;
	DEBUG_BITS(bob);

_____

	printf("From {%hhu, %hhu} to {%hhu, %hhu}\n", start_x, start_z, (byte) (start_x + size_x), (byte) (start_z + size_z));

_____

	/*
	for (byte y = 0; y < map_height; y++) {
		for (byte x = 0; x < map_width; x++)
			printf("%f ", (GLdouble) displacement_map[y * map_width + x]);
		putchar('\n');
	}
	puts("---");
	*/

_____

	/*
	- TODO: do antialiased point filtering
	- Hm, neighboring vertex positions have some similar positions attributes, which leads to the wrong displacement
	- Perhaps pass in an integer number in another map or texture channel that gives more metadata for that displacement area
	- Support negative displacement
	- An overshot by 1 messes up collision, but makes displacement better (compromise
		on the collision for now, that can be fixed with a separate map, or a smarter solution)
	*/

	// const uint correct_texture_id = 11u;

	/*
	bool valid =
		(texture_id == correct_texture_id) &&
		(vertex_pos_world_space.y == 0.0f);
	*/
	
	// valid = sector_is_dynamic;

_____

	bool is_a_bottom_vertex = vertex_pos_world_space.y == 0;

_____

		{{18, 26, 2, 3}, 1.2f},

_____ The old function for drawing all objects to the shadow map:

static void draw_all_objects_to_shadow_map(const CascadedShadowContext* const shadow_context,
	const SectorContext* const sector_context, const WeaponSprite* const weapon_sprite) {

	/* Curr problems with the weapon sprite shadow:
	- Partial transparency (i.e. translucency); should I handle that?

	- For binary transparency, how do I do it without aliasing?
	- Perhaps with a filtered cutout texture: https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S17/final_projects/anthony_philip.pdf
	- Since 1-bit textures don't exist in OpenGL, or in hardware, perhaps do a translucency map anyways (a separate texture map). It would be
		a bit hard to implement, but it would be worth it for the sake of billboards later too.
	- For a translucency map, I will need alpha blending, which requires ordered billboards, so I must sort my billboards front-to-back by their center
	- This will make alpha results for billboards better, and it will allow shadows for the weapon sprite that have less aliasing

	- Transparency code is sorta fragmented right now: alpha blending for the weapon,
		normally, alpha testing for transparent objects, and alpha to coverage for billboards

	- Integration with the depth shader is a bit messy; find a neat way to do that (this should go first in terms of priorities)
	- The weapon sprite's shadow is way too light since it's close to the ground; find a way to resolve that

	- A note: one billboard takes up 24 bytes, and 4 vec3s take up 48 bytes (and adding a 16-bit texture id makes that 64)
	- Perhaps define billboards + the weapon sprite through 1. center pos, 2. face normal, and 3. size?
	*/

	const GLuint depth_shader = shadow_context -> depth_shader;

	static GLint drawing_translucent_quads_id, frame_index_id;

	ON_FIRST_CALL(
		INIT_UNIFORM(drawing_translucent_quads, depth_shader);
		INIT_UNIFORM(frame_index, depth_shader);
		INIT_UNIFORM_VALUE(alpha_threshold, depth_shader, 1f, 0.2f);

		use_texture_in_shader(weapon_sprite -> drawable.diffuse_texture, depth_shader, "alpha_test_sampler", TexSet, TU_WeaponSpriteDiffuse);
	);

	// Opaque objects are drawn first

	UPDATE_UNIFORM(drawing_translucent_quads, 1i, false);
	draw_all_sectors_to_shadow_context(sector_context);

	// Then, translucent objects after

	UPDATE_UNIFORM(drawing_translucent_quads, 1i, true);
	UPDATE_UNIFORM(frame_index, 1ui, weapon_sprite -> animation_context.curr_frame);
	draw_weapon_sprite_to_shadow_context(weapon_sprite);
}

_____ The multipurpose depth.vert:

#version 400 core

#include "../quad_utils.vert"

layout(location = 0) in vec3 vertex_pos_world_space;

out vec2 translucent_vertex_quad_UV;

void main(void) {
	gl_Position = vec4(vertex_pos_world_space, 1.0f);
	translucent_vertex_quad_UV = get_quad_UV();
}

_____ The multipurpose depth.frag:

#version 400 core

in vec2 translucent_fragment_quad_UV;

uniform bool drawing_translucent_quads;
uniform uint frame_index;
uniform float alpha_threshold;
uniform sampler2DArray alpha_test_sampler;

void main(void) {
	if (drawing_translucent_quads) {
		vec3 UV = vec3(translucent_fragment_quad_UV, frame_index);
		if (texture(alpha_test_sampler, UV).a < alpha_threshold) discard;
	}
}

_____ The multipurpose depth.geom:

#version 400 core

#include "../shared_params.glsl"

#define VERTICES_PER_TRIANGLE 3u

layout(triangles, invocations = NUM_CASCADES) in;
layout(triangle_strip, max_vertices = VERTICES_PER_TRIANGLE) out;

in vec2 translucent_vertex_quad_UV[];
out vec2 translucent_fragment_quad_UV;

void main(void) {
	mat4 light_view_projection_matrix = light_view_projection_matrices[gl_InvocationID];

	for (uint i = 0; i < VERTICES_PER_TRIANGLE; i++) {
		// Need to re-write to these since their values are undefined after invoking `EmitVertex`
		gl_Layer = gl_InvocationID; // This sets the cascade layer for the rendering invocation
		gl_Position = light_view_projection_matrix * gl_in[i].gl_Position;
		translucent_fragment_quad_UV = translucent_vertex_quad_UV[i];

		EmitVertex();
	}
	EndPrimitive();
}

#undef VERTICES_PER_TRIANGLE

_____

