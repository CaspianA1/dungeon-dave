///// The old navigation snippet:

/*
// if past the current vertex

if ((dir[0] > 0.0 && pos[0] > next_vertex[0]) || (dir[0] < 0.0 && pos[0] < next_vertex[0])
	|| (dir[1] > 0.0 && pos[1] > next_vertex[1]) || (dir[1] < 1.0 && pos[1] < next_vertex[1]))
	nav -> path_ind++;
*/

///// An attempt at making it better:

/*
DEBUG_VECF(curr_vertex);
DEBUG_VECF(next_vertex);

const VectorF dir = VectorFF_sub(next_vertex, curr_vertex);
const VectorF movement = VectorFF_mul(dir, VectorF_memset(nav -> v));
*nav -> pos = VectorFF_add(*nav -> pos, movement);
if (*nav -> dist_to_player < 0.5) nav -> path_ind++;

return Navigating;
*/

///// The old make_corrected_path code:

CorrectedPath make_corrected_path(const Path path, const VectorF player_pos) {
	const VectorI* orig_path = path.data;
	// const int extended_length = path.length + 1;
	const CorrectedPath corrected_path = {wmalloc(path.length * sizeof(VectorF)), path.length};

	for (int i = 0; i < path.length; i++) {
		const VectorI orig_entry = orig_path[i];
		corrected_path.data[i] = (VectorF) {orig_entry.x, orig_entry.y};
	}

	// corrected_path.data[path.length - 1] = player_pos;

	/*
	int temp_path_ind = 0;
	for (int i = 0; i < path.length - 1; i++) {
		VectorF
			* const pos_ref = &corrected_path.data[i],
			* const next_ref = &corrected_path.data[i + 1];

		VectorF pos = *pos_ref, next = *next_ref;
		const VectorF dir = VectorFF_sub(next, pos);

		while (1) {
			pos = VectorFF_add(pos, dir);

			if (navigator_in_wall(pos)) {
				// printf("In wall! Bad, adjust.\n");
			}

			if ((dir[0] == 1 && pos[0] >= next[0]) || (dir[0] == -1 && pos[0] <= next[0])
				|| (dir[1] == 1 && pos[1] >= next[1]) || (dir[1] == -1 && pos[1] <= next[1])) {
				temp_path_ind++;
				break;
			}
		}
		// here, assign a new curr and next pos, if needed
	}
	*/

	return corrected_path;
}

/////

inlinable VectorI VectorF_round(const VectorF vf) {
	return (VectorI) {(int) round(vf[0]), (int) round(vf[1])};
}

/////

/*
const VectorF
	enemy_pos = enemy -> animations.billboard.pos,
	bullet_pos = VectorF_line_pos(pos, dir, bullet.dist);

const VectorF delta = VectorFF_sub(enemy_pos, bullet_pos);
const double dist = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);

if (dist <= 0.51) {
*/

/////

/*
const VectorF dest = path -> data[path -> length - 1];
const VectorF delta = VectorFF_sub(player_pos, dest);
const double dist = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);

DEBUG_VECF(dest);
DEBUG_VECF(player_pos);
DEBUG(dist, lf);
printf("---\n");
*/

/////

// if (!VectorFF_exceed_dist(player_pos, pos, 0.4)) nav -> path_ind++;

/////

/*
const VectorI
	top = {vertex.x, vertex.y - 1},
	bottom = {vertex.x, vertex.y + 1},
	left = {vertex.x - 1, vertex.y},
	right = {vertex.x + 1, vertex.y},

	top_left = {vertex.x - 1, vertex.y - 1},
	bottom_left = {vertex.x - 1, vertex.y + 1},
	top_right = {vertex.x + 1, vertex.y - 1},
	bottom_right = {vertex.x + 1, vertex.y + 1};

// use an enum
const VectorI neighbors[8] = {
	top, bottom, left, right, top_left, bottom_left, top_right, bottom_right
};
*/

/////

if ((VectorII_eq(neighbor, top_left) && map_point(current_level.wall_data, left.x, left.y)) ||
	(VectorII_eq(neighbor, top_right) && map_point(current_level.wall_data, right.x, right.y)) ||
	(VectorII_eq(neighbor, bottom_right) && map_point(current_level.wall_data, bottom.x, bottom.y)) ||
	(VectorII_eq(neighbor, bottom_left) && map_point(current_level.wall_data, bottom.x, bottom.y)))
	continue;

/////

// offset is vertical
inlinable void draw_column(const Sprite sprite, const VectorF hit,
	const int offset, const int slice_h, const double shade_h, const SDL_FRect* const dest) {
	/* slice_h pertains to src crop. shade_h pertains to shading.
	for partially obscured walls, need shade h. */

	#ifndef SHADING_ENABLED
	(void) shade_h;
	(void) hit;
	#endif

	const byte shade = 255 * calculate_shade(
		(shade_h == -1) ? (double) dest -> h : shade_h, hit);

	SDL_SetTextureColorMod(sprite.texture, shade, shade, shade);

	const SDL_Rect slice = {
		offset, 0, 1,
		(slice_h == -1) ? sprite.surface -> h : slice_h
	};	

	SDL_RenderCopyF(screen.renderer, sprite.texture, &slice, dest);
}

/////

/*
for map center {18.5, 3.5}, drawing ranges from {18.0, 3.0} to {19.0, 4.0}
*/

printf("---\n\n\n\n\n");

// if in wall, override wall
for (int screen_row = start_x; screen_row < end_x; screen_row++) {
	// if (screen_row < 0 || screen.z_buffer[screen_row] < corrected_dist) continue;
	if (screen_row < 0) continue;

	const double percent_scanned = ((double) (screen_row - (int) start_x) / size);
	// const double map_pos = (percent_scanned - 0.5) + billboard.pos;
	const VectorF map_pos = VectorFF_add(billboard.pos, VectorF_memset(percent_scanned - 0.5));

	// if wall is closer to player than sprite column
	if (screen.z_buffer[screen_row] < corrected_dist) {
		if (!keys[SDL_SCANCODE_R])
		continue;
		// if (!map_point(current_level.wall_data, map_pos[0], map_pos[1]))
	}

	screen_pos.x = screen_row;
	src_crop.x = percent_scanned * width + src_begin_x;

	SDL_RenderCopyF(screen.renderer, billboard.sprite.texture, &src_crop, &screen_pos);
}

/////

const double scan_percent_step = (double) (end_x - start_x) / size;
double percent_scanned = 0.0;

for (int screen_row = start_x; screen_row < end_x; screen_row++) {
	percent_scanned += scan_percent_step;

	DEBUG(percent_scanned, lf);

	if (screen_row < 0 || screen.z_buffer[screen_row] < corrected_dist) continue;

	// const double percent_scanned = ((double) (screen_row - (int) start_x) / size);

	screen_pos.x = screen_row;
	src_crop.x = percent_scanned * width + src_begin_x;

	SDL_RenderCopyF(screen.renderer, billboard.sprite.texture, &src_crop, &screen_pos);
}

/////

/*
const double max_log10_v = log(limit_v);
const double rev_log_incr = max_log10_v - log(v);
DEBUG(rev_log_incr, lf);
*/

/*
const double rev_log_incr = 1.0 - (log(v + 1.0) / log(limit_v + 1.0));
DEBUG(rev_log_incr, lf);
*/

// const double domain_incr = domain -> step * rev_log_incr;
// const double domain_incr = domain -> step * v / limit_v;
// const double domain_incr = domain -> step * log(limit_v) / log(v);
/*
const double num = log(limit_v) / log(v);
DEBUG(num, lf);
*/
const d

/////

// pace -> screen_offset = log10(v + 1.0) * settings.screen_height / pace -> offset_scaler * 20.0 * sin(domain -> val);
// pace -> screen_offset = 20;

// pace -> screen_offset++;

/////

KinematicBody* const body = &player -> body;
const double curr_secs = SDL_GetTicks() / 1000.0;
if (moved_any_direction && !body -> moving_forward_or_backward) {
	if (body -> v > 0.0) {
		printf("Should keep some\n");
		// body -> time_of_move = (double) (curr_secs + body -> time_of_stop) / 2.0;
		body -> time_of_move = body -> time_of_stop;
	}
	else {
		printf("Else\n");
		body -> time_of_move = curr_secs;
	}
}

/////

void keep_gui_state(const int key) {
	static byte enabled, toggled_previously = 0;
	const byte pressed_key = keys[key];
	if (pressed_key && !toggled_)
}

/////

/*
static byte minimap_enabled = 0, toggled_minimap_previously = 0;
const byte pressed_minimap_key = keys[KEY_TOGGLE_MINIMAP];
*/

/*
if (pressed_minimap_key && !toggled_minimap_previously)
	minimap_enabled = !minimap_enabled;
toggled_minimap_previously = toggle_minimap_key;

if (!minimap_enabled) return;
*/

/////

/*
if (obscured_diff == 0.0f) printf("Zero\n");
else if (obscured_diff < 0.0f) printf("Less\n");
else printf("More\n");
*/

/////

// subtract from src_crop a certain amount; the difference is in screen space, translate to sprite space

/////

/*
DataDDA d = *d_ref;

if (d.ray_length[0] < d.ray_length[1]) {
	d.dist = d.ray_length[0];
	d.curr_tile.x += d.ray_step.x;
	d.ray_length[0] += d.unit_step_size[0];
	d.side = 0;
}
else {
	d.dist = d.ray_length[1];
	d.curr_tile.y += d.ray_step.y;
	d.ray_length[1] += d.unit_step_size[1];
	d.side = 1;
}
*/

/////

// if (i == point_height - 1) wall_y_buffer[d.screen_x] = raised_wall.y;

/////

if ((double) raised_wall.y < *d.smallest_wall_y) {
	printf("Yes, set\n");
	*d.smallest_wall_y = (double) raised_wall.y;
}
else {
	printf("No, do not set\n");
}

/////

/*
byte in_wall = 0;
if (point_exists_at(new_pos[0], new_pos[1] + stop_dist, p_height) ||
	point_exists_at(new_pos[0], new_pos[1] - stop_dist, p_height)) {
	// const double adjusted = ceil(new_pos[1]);
	const double adjusted = floor(new_pos[1]) + 0.2;
	printf("Stop at pos y = %lf\nReset pos to %lf\n", new_pos[1], adjusted);
	new_pos[1] = adjusted;
	in_wall = 1;
}

else printf("No point exists at y = %lf\n", new_pos[1]);
*/

/*
if (point_exists_at(new_pos[0], new_pos[1] + stop_dist, p_height) ||
	point_exists_at(new_pos[0], new_pos[1] - stop_dist, p_height))
	new_pos[1] = prev_pos[1];

if (point_exists_at(new_pos[0] + stop_dist, new_pos[1], p_height) ||
	point_exists_at(new_pos[0] - stop_dist, new_pos[1], p_height))
	new_pos[0] = prev_pos[0];
*/

/////

if (!point_exists_at((*pos)[0], new_pos[1], p_height)) {
	(*pos)[1] = new_pos[1];
}

/////


/*
DEBUG(new_pos[1], lf);
if (new_pos[1] < 11.0 + 0.05) new_pos[1] = 11.0 + 0.05;
*/

if (current_level.map_data[])

/*
if (point_exists_at((*pos)[0], new_pos[1] + stop_dist, p_height))
	new_pos[1] = ceil(new_pos[1]) + stop_dist;
*/

/*
byte in_wall = 0;
if (point_exists_at(new_pos[0], new_pos[1] + stop_dist, p_height) ||
	point_exists_at(new_pos[0], new_pos[1] - stop_dist, p_height)) {
	// const double adjusted = ceil(new_pos[1]);
	const double adjusted = floor(new_pos[1]) + 0.2;
	printf("Stop at pos y = %lf\nReset pos to %lf\n", new_pos[1], adjusted);
	new_pos[1] = adjusted;
	in_wall = 1;
}

else printf("No point exists at y = %lf\n", new_pos[1]);
*/

/*
if (point_exists_at(new_pos[0], new_pos[1] + stop_dist, p_height) ||
	point_exists_at(new_pos[0], new_pos[1] - stop_dist, p_height))
	new_pos[1] = prev_pos[1];

if (point_exists_at(new_pos[0] + stop_dist, new_pos[1], p_height) ||
	point_exists_at(new_pos[0] - stop_dist, new_pos[1], p_height))
	new_pos[0] = prev_pos[0];
*/

/////

// x0, y0, x1, y1
// SDL_RenderDrawLine(screen.renderer, screen_x, last_height_change_y, screen_x, height_change_y);
// last_height_change_y = height_change_y;

/////

/*
else if (i == 0) std_draw_floor(d.begin, d.dir, player.pace.screen_offset, player.y_pitch,
	player.jump.height, cos_beta, raised_wall);
*/

/////