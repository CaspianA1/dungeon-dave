// FloorCastThread floorcast_thread = init_floorcast_thread(&player);
// player.pos = (VectorF) {3.0, 3.0};
// start_floorcast_tick(&floorcast_thread);
// wait_for_floorcast_tick(&floorcast_thread);

/////

/*
if (ray_length[0] < ray_length[1])
	distance = ray_length[0],
	curr_tile.x += ray_step.x,
	ray_length[0] += unit_step_size[0],
	side = 0;
else
	distance = ray_length[1],
	curr_tile.y += ray_step.y,
	ray_length[1] += unit_step_size[1],
	side = 1;
*/

/////

double sprite_h;

// fully visible: bottom smaller than smallest top
if (raised_wall_bottom <= *smallest_wall_y) {
	sprite_h = max_sprite_h;

	#ifndef PLANAR_MODE

	if (i == 0) std_draw_floor(player, dir, raised_wall, cos_beta);

	#endif
}

else { // partially obscured: bottom of wall somewhere in middle of tallest
	const double
		y_obscured = raised_wall_bottom - *smallest_wall_y,
		init_raised_h = (double) raised_wall.h;

	raised_wall.h -= (float) y_obscured;
	if (doubles_eq((double) raised_wall.h, 0.0, std_double_epsilon)) continue;

	// sprite_h = max_sprite_h * (double) raised_wall.h / init_raised_h;
	sprite_h = max_sprite_h;
}

if ((double) raised_wall.y < *smallest_wall_y) *smallest_wall_y = (double) raised_wall.y;

/////

/*
inlinable void iter_dda(double* const distance, VectorI* const curr_tile_ref,
	VectorF* const ray_length_ref, byte* const side,
	const VectorF unit_step_size, const VectorI ray_step) {

	VectorI curr_tile = *curr_tile_ref;
	VectorF ray_length = *ray_length_ref;

	if (ray_length[0] < ray_length[1]) {
		*distance = ray_length[0];
		curr_tile.x += ray_step.x;
		ray_length[0] += unit_step_size[0];
		*side = 0;
	}
	else {
		*distance = ray_length[1];
		curr_tile.y += ray_step.y;
		ray_length[1] += unit_step_size[1];
		*side = 1;
	}

	*curr_tile_ref = curr_tile;
	*ray_length_ref = ray_length;
}
*/

/////

/*
inlinable void raycast_dda_loop(const Player player, DataDDA* d) {
	void handle_ray();
	void old_handle_ray();

	while (1) {
		iter_dda(d);

		const VectorI curr_tile = dda_data.curr_tile;
		if (VectorI_out_of_bounds(curr_tile)) break;

		const byte point = map_point(current_level.wall_data, curr_tile.x, curr_tile.y);
		if (point) {
			void (*fn) () = keys[SDL_SCANCODE_C] ? handle_ray : old_handle_ray;

			const CastData cast_data = {point, dda_data.side, dda_data.distance, VectorF_line_pos(player.pos, dir, dda_data.distance)};
			fn(player, cast_data, screen_x, &first_wall_hit, &smallest_wall_y,
				player_angle, theta, wall_y_shift, full_jump_height, dir);
		}
	}
}
*/

/*
void dda(const VectorF pos, const VectorF dir, void (*upon_hit) (int), byte stop_at_first) {
	(void) pos;
	(void) dir;
	(void) upon_hit;
	(void) stop_at_first;
}
*/

/////

void handle_ray(const Player player, const CastData cast_data, const int screen_x,
	const byte first_wall_hit, double* const smallest_wall_y, const double player_angle,
	const double theta, const double wall_y_shift, const double full_jump_height, const VectorF dir) {

	// this one is slower

	#ifdef PLANAR_MODE
	(void) player;
	#endif

	const double cos_beta = cos(player_angle - theta);
	const double corrected_dist = cast_data.dist * cos_beta;
	const double wall_h = settings.proj_dist / corrected_dist;

	const byte point_height = current_level.get_point_height(cast_data.point, cast_data.hit);

	const SDL_FRect wall = {
		screen_x,
		wall_y_shift - wall_h / 2.0 + full_jump_height / corrected_dist,
		settings.ray_column_width,
		wall_h
	};

	if (first_wall_hit) update_z_buffer(screen_x, corrected_dist);

	const Sprite wall_sprite = current_level.walls[cast_data.point - 1];
	const int offset = calculate_wall_tex_offset(cast_data.side, cast_data.hit, dir, wall_sprite.surface -> w);

	for (byte i = 0, first_draw_event = 1; i < point_height; i++) {
		SDL_FRect raised_wall = wall;
		raised_wall.y -= wall.h * i;

		// completely obscured: starts under the tallest so far
		if ((double) raised_wall.y >= *smallest_wall_y) continue;

		const double raised_wall_bottom = (double) (raised_wall.y + raised_wall.h);

		// partially obscured: bottom of wall somewhere in middle of tallest
		if (raised_wall_bottom > *smallest_wall_y) {
			const double y_obscured = raised_wall_bottom - *smallest_wall_y;
			raised_wall.h -= (float) y_obscured;
			if (doubles_eq((double) raised_wall.h, 0.0, std_double_epsilon)) continue;
		}

		if ((double) raised_wall.y < *smallest_wall_y) *smallest_wall_y = (double) raised_wall.y;

		if (first_draw_event) {
			const byte shade = 255 * calculate_shade((double) wall.h, cast_data.hit);
			SDL_SetTextureColorMod(wall_sprite.texture, shade, shade, shade);
			std_draw_floor(player, dir, raised_wall, cos_beta);
			first_draw_event = 0;
		}

		const SDL_Rect slice = {offset, 0, 1, wall_sprite.surface -> h};
		SDL_RenderCopyF(screen.renderer, wall_sprite.texture, &slice, &raised_wall);
	}
}

/////

void (*fn) (const Player, const CastData, const int, const byte, double* const, const double,
	const double, const double, const double, const VectorF) = old_handle_ray;
// keys[SDL_SCANCODE_C] ? handle_ray : old_handle_ray;

/////

const double raised_wall_bottom = (double) (raised_wall.y + raised_wall.h);


if (raised_wall_bottom > *smallest_wall_y) {
	const double
		y_obscured = raised_wall_bottom - *smallest_wall_y,
		init_raised_h = (double) raised_wall.h;

	raised_wall.h -= (float) y_obscured;
	if (doubles_eq((double) raised_wall.h, 0.0, std_double_epsilon)) continue;

	sprite_h = max_sprite_h;
	if (raised_wall.y > 0.0f)
		sprite_h *= (double) raised_wall.h / init_raised_h;
}

/////

int sprite_h = max_sprite_h;

// partially obscured: bottom of wall somewhere in middle of tallest
if ((double) (raised_wall.y + raised_wall.h) > *smallest_wall_y) {
	raised_wall.h = *smallest_wall_y - (double) raised_wall.y;
	if (raised_wall.y > 0.0f)
	sprite_h = ceil(max_sprite_h * (double) raised_wall.h / wall_h);
}

else if (i == 0) std_draw_floor(player, dir, raised_wall, cos_beta);

/////

/*
const CastData cast_data = {point, ray.side, ray.dist, VectorF_line_pos(player.pos, dir, ray.dist)};
handle_ray(player, cast_data, screen_x, ray.at_first_hit, &smallest_wall_y,
	player_angle, theta, wall_y_shift, full_jump_height, dir);

ray.at_first_hit = 0;
*/

/////

typedef struct {
	const byte point, side;
	const double dist;
	const VectorF hit;
} CastData;

/*
extended cast data:
- player angle and angle of ray in radians - check
- distance of raycast - check
- the point that the raycast hit, and the position that the raycast hit - check
- the screen x - check
- wall y shift - check
- full jump height - check
- if the first wall y hit - check
- direction - check

typedef struct {
	const double player_angle, theta, cos_beta, dist, wall_y_shift, full_jump_height;
	const VectorF hit, dir;
	const byte point, first_wall_hit;
	const int screen_x;
} DataRaycast;
*/

///// The test enemy:

set_level_enemies(&current_level, enemy_count,
	Idle, // state
	2.0, 8.0, // dist_thresholds
	20.0, // hp
	4, 8, 10, 4, // animation_seg_lengths

	"../assets/spritesheets/enemy_spritesheet_test.bmp", 5, 6, 26, 12, // animation data
	3.0, 7.5, 0.0, // billboard data

	"../assets/audio/enemy_sound_test/idle.wav", // sound data
	"../assets/audio/enemy_sound_test/chase.wav",
	"../assets/audio/enemy_sound_test/attack.wav",
	"../assets/audio/enemy_sound_test/death.wav",
	"../assets/audio/enemy_sound_test/attacked.wav",

	0.03 /* navigator speed */ );

/////