// FloorCastThread floorcast_thread = init_floorcast_thread(&player);
// player.pos = (VectorF) {3.0, 3.0};
// start_floorcast_tick(&floorcast_thread);
// wait_for_floorcast_tick(&floorcast_thread);

/////

/*
if (ray_length[0] < ray_length[1])
	distance = ray_length[0],
	curr_tile.x += ray_step.x,
	ray_length[0] += unit_step_size[0],
	side = 0;
else
	distance = ray_length[1],
	curr_tile.y += ray_step.y,
	ray_length[1] += unit_step_size[1],
	side = 1;
*/

/////

double sprite_h;

// fully visible: bottom smaller than smallest top
if (raised_wall_bottom <= *smallest_wall_y) {
	sprite_h = max_sprite_h;

	#ifndef PLANAR_MODE

	if (i == 0) std_draw_floor(player, dir, raised_wall, cos_beta);

	#endif
}

else { // partially obscured: bottom of wall somewhere in middle of tallest
	const double
		y_obscured = raised_wall_bottom - *smallest_wall_y,
		init_raised_h = (double) raised_wall.h;

	raised_wall.h -= (float) y_obscured;
	if (doubles_eq((double) raised_wall.h, 0.0, std_double_epsilon)) continue;

	// sprite_h = max_sprite_h * (double) raised_wall.h / init_raised_h;
	sprite_h = max_sprite_h;
}

if ((double) raised_wall.y < *smallest_wall_y) *smallest_wall_y = (double) raised_wall.y;

/////

/*
inlinable void iter_dda(double* const distance, VectorI* const curr_tile_ref,
	VectorF* const ray_length_ref, byte* const side,
	const VectorF unit_step_size, const VectorI ray_step) {

	VectorI curr_tile = *curr_tile_ref;
	VectorF ray_length = *ray_length_ref;

	if (ray_length[0] < ray_length[1]) {
		*distance = ray_length[0];
		curr_tile.x += ray_step.x;
		ray_length[0] += unit_step_size[0];
		*side = 0;
	}
	else {
		*distance = ray_length[1];
		curr_tile.y += ray_step.y;
		ray_length[1] += unit_step_size[1];
		*side = 1;
	}

	*curr_tile_ref = curr_tile;
	*ray_length_ref = ray_length;
}
*/

/////

/*
inlinable void raycast_dda_loop(const Player player, DataDDA* d) {
	void handle_ray();
	void old_handle_ray();

	while (1) {
		iter_dda(d);

		const VectorI curr_tile = dda_data.curr_tile;
		if (VectorI_out_of_bounds(curr_tile)) break;

		const byte point = map_point(current_level.wall_data, curr_tile.x, curr_tile.y);
		if (point) {
			void (*fn) () = keys[SDL_SCANCODE_C] ? handle_ray : old_handle_ray;

			const CastData cast_data = {point, dda_data.side, dda_data.distance, VectorF_line_pos(player.pos, dir, dda_data.distance)};
			fn(player, cast_data, screen_x, &first_wall_hit, &smallest_wall_y,
				player_angle, theta, wall_y_shift, full_jump_height, dir);
		}
	}
}
*/

/*
void dda(const VectorF pos, const VectorF dir, void (*upon_hit) (int), byte stop_at_first) {
	(void) pos;
	(void) dir;
	(void) upon_hit;
	(void) stop_at_first;
}
*/

/////