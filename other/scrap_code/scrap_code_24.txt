typedef struct {
	union {
		Billboard* billboard;
		Animation* animation;
	};
	int is_billboard;
} AnyBillboard;

int compare_any_billboards(const void* a, const void* b) {
	AnyBillboard
		*any_a = (AnyBillboard*) a,
		*any_b = (AnyBillboard*) b;

	const double
		dist_squared_a = any_a -> is_billboard
			? any_a -> billboard -> dist_squared
			: any_a -> animation -> billboard.dist_squared,

		dist_squared_b = any_b -> is_billboard
			? any_b -> billboard -> dist_squared
			: any_b -> animation -> billboard.dist_squared;

	return round(dist_squared_a - dist_squared_b);
}

/*
AnyBillboard* generic_billboards = calloc(generic_billboard_count, sizeof(AnyBillboard));

for (int i = 0; i < generic_billboard_count; i++) {
	AnyBillboard* generic_billboard = &generic_billboards[i];
	generic_billboard -> is_billboard = i < billboard_count;

	// const double beta = atan2(delta.y, delta.x) - player_angle;
	// billboard -> dist_squared = (delta.x * delta.x + delta.y * delta.y) * cos(billboard -> beta);

	if (generic_billboard -> is_billboard) {
		Billboard copy_billboard = billboards[i];

		const VectorF delta = {
			copy_billboard -> pos.x - player.pos.x,
			copy_billboard -> pos.y - player.pos.y
		};

		copy_billboard.beta = 

		// generic_billboard -> billboard = &billboards[i];
		// generic_billboard -> billboard.beta = 
	}
	else
		generic_billboard -> animation = &animations[i - billboard_count];
}

qsort(generic_billboards, generic_billboard_count, sizeof(AnyBillboard), compare_any_billboards);

for (int i = 0; i < generic_billboard_count; i++) {
	AnyBillboard generic_billboard = generic_billboards[i];
	const int is_billboard = generic_billboard.is_billboard;
}

free(generic_billboards);
*/

/////

/*
Animation
	whip = init_animation("assets/spritesheets/whip.bmp", 4, 6, 22, 25),
	shotgun = init_animation("assets/spritesheets/other/shotgun.bmp", 4, 7, 28, 12);

memcpy(&animations[0], &whip, sizeof(Animation));
memcpy(&animations[1], &shotgun, sizeof(Animation));
*/

/////

/*
ProceedAsNormal = 1, and SpacebarPress = 2
(ProceedAsNormal == ProceedAsNormal) - 1 -> 0 -> frame 0
(SpacebarPress == ProceedAsNormal) - 1 -> -1 -> frame -1 ->  an animation cycle
*/

if (input_status == SpacebarPress) {
	printf("pressed space\n");
}

animate_full_screen(&whip, -(input_status == SpacebarPress));

// const int pressed_space_bar = input_status == SpacebarPress;

// if (cycling_whip_animation)

/*
if (!cycling_whip_animation) {
	cycling_whip_animation = (input_status == ProceedAsNormal - 1);
	printf("Here\n");
}

DEBUG(cycling_whip_animation, d);
*/

/*
int foo = (input_status == ProceedAsNormal) - 1;
DEBUG(foo, d);
animate_full_screen(&whip, foo);
*/

/////

/*
if (cycling_whip_animation && whip.frame_ind == 0)
	cycling_whip_animation = 0;

if (input_status == SpacebarPress) {
	printf("Pressed space\n");
	if (!cycling_whip_animation) {
		printf("Not already cycling\n");
		cycling_whip_animation = 1;
	}
}

if (cycling_whip_animation) {
	printf("Cycling\n");

	if (whip.frame_ind == 0) {
		printf("The frame number is %d\n", whip.frame_ind);
	}
}

if (cycling_whip_animation)
	animate_full_screen(&whip, -1);
else
	animate_full_screen(&whip, 0);
*/

///// Small, but hard to read:

animating_weapon = !(animating_weapon || weapon.frame_ind == 0) || input_status == SpacebarPress;

/////

/*
if (kinematic_body -> moving_forward_or_back) {
	double t = curr_time - kinematic_body -> time_of_move;

	if (t == 0.0 && kinematic_body -> v != 0.0) {
		DEBUG(curr_time, lf);
		DEBUG(kinematic_body -> time_of_stop, lf);
		DEBUG(kinematic_body -> time_of_move, lf);
	}

	kinematic_body -> v = kinematic_body -> a * t;

	if (kinematic_body -> v > kinematic_body -> limit_v)
		kinematic_body -> v = kinematic_body -> limit_v;

	kinematic_body -> max_v_reached = kinematic_body -> v,
	kinematic_body -> was_forward = forward,
	kinematic_body -> was_backward = backward;
}

else {
	const double t = curr_time - kinematic_body -> time_of_stop;
	kinematic_body -> v = kinematic_body -> max_v_reached - kinematic_body -> a * t;
	if (kinematic_body -> v < 0) kinematic_body -> v = 0;
}
*/

///// Works a bit, but not fully (too fast):

// kinematic_body -> v = kinematic_body -> max_v_reached + kinematic_body -> a * t;
kinematic_body -> v = kinematic_body -> a * t;

/////

/*
// moving sprites + spritesheets
Billboard* all_sorted_billboards = calloc(generic_billboard_count, sizeof(Billboard));

for (int i = 0; i < generic_billboard_count; i++) {
	Billboard billboard = i < billboard_count
		? billboards[i] // static billboard
		: animations[i - billboard_count].billboard; // animated one

	const VectorF delta = {billboard.pos.x - player.pos.x, billboard.pos.y - player.pos.y};
	billboard.beta = atan2(delta.y, delta.x) - player_angle;
	billboard.dist_squared = (delta.x * delta.x + delta.y * delta.y) * cos(billboard.beta);

	all_sorted_billboards[i] = billboard;
}

qsort(all_sorted_billboards, generic_billboard_count, sizeof(Billboard), compare_billboard_distances);

for (int i = 0; i < generic_billboard_count; i++) {
	const Billboard billboard = all_sorted_billboards[i];

	const double abs_billboard_beta = fabs(billboard.beta);

	if (billboard.dist_squared <= 0
		|| doubles_eq(abs_billboard_beta, half_pi)
		|| doubles_eq(abs_billboard_beta, three_pi_over_two)
		|| doubles_eq(abs_billboard_beta, five_pi_over_two)) continue;

	const double
		dist = sqrt(billboard.dist_squared),
		center_offset = tan(billboard.beta) * screen.projection_distance,
		size = screen.projection_distance / dist;

	const int
		width = billboard.sprite.surface -> w,
		center_x = half_screen_width + center_offset,
		half_size = size / 2;

	int start_x = center_x - half_size, end_x = center_x + half_size;
	if (end_x < 0) continue;

	SDL_Rect pos = {
		0, half_screen_height - half_size + player.pace.screen_offset + player.y_pitch,
		ray_column_width, size
	};

	printf("I is %d\n", i);

	if (i >= billboard_count) { // this is bad code, but make it work first
		Animation* animation = &animations[i - billboard_count];
		printf("Confirmed: %s\n", billboard.sprite.path);
		const int rel_y_ind = animation -> frame_ind / animation -> frames_per_row;
		const int rel_x_ind = animation -> frame_ind - rel_y_ind * animation -> frames_per_row;

		const int
			sheet_begin_x = ((double) rel_x_ind / animation -> frames_per_row)
				* billboard.sprite.surface -> w,

			sheet_begin_y = ((double) rel_y_ind / animation -> frames_per_col)
				* billboard.sprite.surface -> h;

		SDL_Rect sheet_crop = {
			sheet_begin_x, sheet_begin_y,
			10, animation -> frame_h / 2
		};

		for (int screen_row = start_x; screen_row < end_x; screen_row++) {
			if (screen_row < 0 || screen_row > screen_width || screen.z_buffer[screen_row] < dist)
				continue;

			const int tex_ind = ((double) (screen_row - start_x) / size) * width;
			sheet_crop.x = sheet_begin_x + tex_ind;

			pos.x = sheet_begin_x + screen_row;

			SDL_RenderCopy(screen.renderer_3D, billboard.sprite.texture, &sheet_crop, &pos);
		}
	}

	else {
		printf("Else: %s\n", billboard.sprite.path);
		for (int screen_row = start_x; screen_row < end_x; screen_row++) {
			if (screen_row < 0 || screen_row > screen_width || screen.z_buffer[screen_row] < dist)
				continue;

			const int tex_ind = ((double) (screen_row - start_x) / size) * width;
			pos.x = screen_row;
			draw_scanline(billboard.sprite, tex_ind, &pos);
		}
	}
}

free(all_sorted_billboards);
*/

/////

/*
GenericBillboard* generic = &generic_billboards[i];

generic -> is_animated = i >= billboard_count;
generic -> billboard = generic -> is_animated
	? animations[i - billboard_count].billboard
	: billboards[i];

const VectorF delta = {
	generic -> billboard.pos.x - player.pos.x,
	generic -> billboard.pos.y - player.pos.y
};

generic -> billboard.beta = atan2(delta.y, delta.x) - player_angle;
generic -> billboard.dist_squared =
	(delta.x * delta.x + delta.y * delta.y) * cos(generic -> billboard.beta);
*/

/////

/*
Billboard billboard = animation -> billboard;

const int y_ind = animation -> frame_ind / animation -> frames_per_row;
const int x_ind = animation -> frame_ind - y_ind * animation -> frames_per_row;

const int
	sheet_begin_x = ((double) x_ind / animation -> frames_per_row)
		* billboard.sprite.surface -> w,

	sheet_begin_y = ((double) y_ind / animation -> frames_per_col)
		* billboard.sprite.surface -> h;

const SDL_Rect sheet_crop = {
	sheet_begin_x, sheet_begin_y,
	animation -> frame_w, animation -> frame_h
};
*/

/////

/*
SDL_Rect possible_spritesheet_crop;
int possible_spritesheet_begin_x;

if (generic.is_animated) {
	const int y_ind =
		possible_animation -> frame_ind
		/ possible_animation -> frames_per_row;

	const int x_ind =
		possible_animation -> frame_ind - y_ind
		* possible_animation -> frames_per_row;

	possible_spritesheet_begin_x =
		((double) x_ind / possible_animation -> frames_per_row)
		* billboard.sprite.surface -> w;

	possible_spritesheet_crop.y =
		((double) y_ind / possible_animation -> frames_per_col)
		* billboard.sprite.surface -> h;

	possible_spritesheet_crop.w = 1;
	possible_spritesheet_crop.h = possible_animation -> frame_h;

	progress_frame_ind(possible_animation);
}
*/

/////