float gamma = theta - to_radians(player.angle);

if ((sprite.dx > 0 && player.angle >= 180 && player.angle <= 360) || (sprite.dx < 0 && sprite.dy < 0))
	gamma += M_PI * 2;

// follow the tutorial super exactly

/*
int screen_x = (gamma / (2 * M_PI)) * screen_width;
int height = screen_height / sprite.dist;
SDL_Rect position = {screen_x, 0, 100, 100};
SDL_RenderCopy(renderer_3D, sprite.texture, NULL, &position);
*/

/////

/*
Sprite sorted_sprites[sprite_count]; // make to a method sometime
memcpy(sorted_sprites, sprites, sizeof(sorted_sprites));
for (int i = 0; i < sprite_count; i++) {
	Sprite* sprite = &sprites[i];

	Coord pos = sprite_pos(i + wall_count + 1);
	sprite -> pos = pos;

	float dx = pos.x - player.pos.x, dy = pos.y - player.pos.y;
	sprite -> dx = dx;
	sprite -> dy = dy;
	sprite -> dist = sqrt(dx * dx + dy * dy) * distance_adjustment(thet)
}

qsort(sorted_sprites, sprite_count, sizeof(Sprite), compare_distances);
*/

/////

float projection_distance = (screen_width / 2.0) / tan(to_radians(half_fov));

/////

float cam_min = wrap_angle(-to_radians(half_fov)),
	cam_max = wrap_angle(to_radians(half_fov));


	/*
	if ((sprite.gamma < cam_min && sprite.gamma > cam_max)|| z_buffer[(int) scr_row] < sprite.dist)
			continue;
	*/

/////

/*
int screen_x = screen_width * (sprite.gamma / two_pi);

float sprite_pixel_offset = tan(to_radians(gamma)) * projection_distance;
int sprite_screen_x = (screen_width / 2.0) = sprite_pixel_offset;
*/

/*
int screen_begin_x = screen_x - sprite.surface -> w / 2,
	screen_end_x = screen_x + sprite.surface -> w / 2;

for (float scr_row = screen_begin_x; scr_row < screen_end_x; scr_row += step_x) {

	if (z_buffer[(int) scr_row] < sprite.dist)
		continue;

	int tex_coord = scr_row - screen_begin_x;

	SDL_Rect pos = {
		// round(screen_x),
		round(scr_row),
		(screen_height / 2 - size / 2) + player.pace.height,
		step_x + 1,
		size
	};

	// printf("pos = {%d, %d, %d, %d}\n", pos.x, pos.y, pos.w, pos.h);

	render_scanline(sprite, tex_coord, &pos);
}
*/

//////////

screen_start_y = -half_size + screen_height / 2,
screen_end_y = half_size + screen_height / 2;

float min_cam = wrap_angle(-half_fov), max_cam = wrap_angle(half_fov);

/*
if (sprite.gamma < min_cam || sprite.gamma > max_cam)
	continue;
*/

// remove sprites not in vision

/////

/*
printf("a = %d\n", a);

SDL_PumpEvents();
*/

// handle_input(&player);	

/*
int state = SDL_PollEvent(&event);
// printf("%d\n", state);
handle_movement(&player);
*/

/*
if (SDL_PollEvent(&event)) {
	switch (event.type) {
		case SDL_QUIT:
			cleanup();
			SDL_Quit();
			return 0;

		case SDL_KEYDOWN:
			handle_movement(&player);
	}
}
*/

// else continue;

/////

/*
printf("It is %d\n", event.type);
DEBUG(SDL_QUIT, d);
DEBUG(SDL_KEYDOWN, d);
handle_input(&player);
*/

/*
SDL_PollEvent(&event);
switch (event.type) {
	case SDL_QUIT:
		cleanup();
		SDL_Quit();
		return 0;

	case SDL_KEYDOWN:
		handle_input(&player);
}
*/

/*
SDL_PumpEvents();
handle_input(&player);
*/

/////

`pkg-config --cflags --libs sdl2`

/////

sprites[0] = load_sprite("assets/static/robot.bmp");
sprites[1] = load_sprite("assets/static/tomato.bmp");
sprites[2] = load_sprite("assets/static/bogo.bmp");
sprites[3] = load_sprite("assets/static/zombieman.bmp");
sprites[4] = load_sprite("assets/static/doomguy.bmp");
sprites[5] = load_sprite("assets/static/ness.bmp");

/////

/*
while (SDL_PollEvent(&event)) {
	switch (event.type) {
		case SDL_QUIT:
			cleanup();
			SDL_Quit();
			return 0;

		case SDL_KEYDOWN:
			handle_input(&player);
			break;
	}
}
*/

/////

/*
while (SDL_PollEvent(&event)) {
	switch (event.type) {
		case SDL_KEYDOWN:
			printf("Down\n"); break;
		case SDL_KEYUP:
			printf("Up\n"); break;
		default:
			printf("None\n"); break;
	}
}
*/

/////

/*
Uint64 after = SDL_GetPerformanceCounter();

DEBUG((double) before, lf);
DEBUG((double) after, lf);
DEBUG((double) after - before, lf);

Uint64 elapsed_ms = (after - before) / ticks_per_sec * 1000.0f;
DEBUG((double) elapsed_ms, lf);

DEBUG(max_delay, lf);
Uint64 delay = max_delay - elapsed_ms;
DEBUG((double) delay, lf);
*/

/////

float ms_1 = SDL_GetTicks() - before_1;
float wait_1 = max_delay - ms_1;

float ms_2 = (SDL_GetPerformanceCounter() - before_2) / ticks_per_sec * 1000.0f;
float wait_2 = max_delay - ms_2;
printf("1 vs 2: %f, %f\n", wait_1, wait_2);

/////

/*
Uint32 after_1 = SDL_GetTicks();
Uint64 after_2 = SDL_GetPerformanceFrequency();

int elapsed_1 = (after_1 - before_1) / 1000.0f;
int elapsed_2 = (after_2 - before_2) / ticks_per_sec * 1000.0f;

printf("Elapsed 1 vs 2: %d, %d\n", elapsed_1, elapsed_2);
*/

/*
float wait = max_delay - (SDL_GetTicks() - before);
DEBUG(wait, f);
if (wait > 0) SDL_Delay(wait);
*/

/////

const double ticks_per_sec = SDL_GetPerformanceFrequency();

/////

/*
if (gamma == half_pi || gamma == 3 * half_pi) {
	printf("Check here!\n");
}
*/

/*
if (close_to_whole(fabsf(gamma - half_pi)) || close_to_whole(fabsf(gamma - 3 * half_pi))) {
	printf("Check here!\n");
}
*/

/////

/*
printf("--- i = %d ---\n", i);
DEBUG(gamma, f);
float deg_gamma = to_degrees(gamma);
DEBUG(deg_gamma, f);
int test = (int) roundf(deg_gamma) % 90;
DEBUG(test, d);
DEBUG(tanf(gamma), f);
*/

/////

/*
printf("---\n");
DEBUG(sprite.theta, f);
DEBUG(sprite.gamma, f);
DEBUG(half_pi, f);
DEBUG(three_pi_over_2, f);
DEBUG(sprite.gamma - half_pi, f);
DEBUG(sprite.gamma - three_pi_over_2, f);
DEBUG(tanf(sprite.gamma), f);

DEBUG(sprite.gamma - half_pi, f);
DEBUG(sprite.gamma - half_pi == -0, d);
DEBUG(close_to_whole(sprite.gamma - half_pi), d);
*/

/////


#ifdef PRECISE
#define float double
#define sinf sin
#define cosf cos
#define tanf tan
#define fabsf fabs
#define roundf round
#endif

/////

const unsigned char map[map_height][map_width] = {
	{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};

/////