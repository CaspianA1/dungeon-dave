/*
draw_ceiling(pace_wall, player, ray_direction, cos_beta);
draw_floor(pace_wall, player, ray_direction, cos_beta);
*/

///// NOTE: the two functions below work as expected.

void draw_ceiling(const SDL_Rect wall, const Player player,
	const VectorF dir, const double cos_beta) {

	const Sprite sprite = textured_walls[0];
	const SDL_Surface* surface = sprite.surface;
	const SDL_PixelFormat* format = surface -> format;
	const void* pixels = surface -> pixels;
	const int
		surface_pitch = surface -> pitch,
		sprite_w = sprite.surface -> w;

	const double pace = player.pace.screen_offset;

	for (int y = -pace; y < wall.y - pace; y++) {
		const int ceil_y = y + pace;
		if (ceil_y < 0 || ceil_y >= screen_height) continue;
		// const int ceil_row = half_screen_height - y + player.y_pitch.val;
		// const int ceil_row = -y + half_screen_height + player.y_pitch.val;
		// const int ceil_row = half_screen_height + player.y_pitch.val - y;
		const int ceil_row = -y + half_screen_height + player.y_pitch.val;

		const double floor_straight_distance = 0.5 / ceil_row * screen.projection_distance;
		const double floor_actual_distance = floor_straight_distance / cos_beta;

		const VectorF hit = {
			dir.x * floor_actual_distance + player.pos.x,
			dir.y * floor_actual_distance + player.pos.y
		};

		const VectorI pixel_coord = {
			(int) ((hit.x - floor(hit.x)) * sprite_w) & sprite_w - 1,
			(int) ((hit.y - floor(hit.y)) * sprite_w) & sprite_w - 1
		};

		Uint32 surface_pixel = get_surface_pixel(pixels, surface_pitch, pixel_coord.x, pixel_coord.y);
		SDL_Color pixel;
		SDL_GetRGB(surface_pixel, format, &pixel.r, &pixel.g, &pixel.b);

		// there's no wall here (of course), but this is used for the shading calculation
		const double shade = calculate_shade(screen.projection_distance / floor_actual_distance);
		surface_pixel = SDL_MapRGB(format, pixel.r * shade, pixel.g * shade, pixel.b * shade);
		*get_pixbuf_pixel(wall.x, ceil_y) = surface_pixel;
	}
}

void draw_floor(const SDL_Rect wall, const Player player,
	const VectorF dir, const double cos_beta) {

	const Sprite sprite = textured_walls[0];
	const SDL_Surface* surface = sprite.surface;
	const SDL_PixelFormat* format = surface -> format;
	const void* pixels = surface -> pixels;
	const int
		surface_pitch = surface -> pitch,
		sprite_w = sprite.surface -> w;
	const double pace = player.pace.screen_offset;

	for (int y = wall.y + wall.h - pace; y < screen_height - pace; y++) {
		const int floor_y = y + pace;
		if (floor_y < 0 || floor_y >= screen_height) continue;
		const int floor_row = y - half_screen_height - player.y_pitch.val;

		const double floor_straight_distance = 0.5 / floor_row * screen.projection_distance;
		const double floor_actual_distance = floor_straight_distance / cos_beta;

		const VectorF hit = {
			dir.x * floor_actual_distance + player.pos.x,
			dir.y * floor_actual_distance + player.pos.y
		};

		const VectorI pixel_coord = {
			(int) ((hit.x - floor(hit.x)) * sprite_w) & sprite_w - 1,
			(int) ((hit.y - floor(hit.y)) * sprite_w) & sprite_w - 1
		};

		Uint32 surface_pixel = get_surface_pixel(pixels, surface_pitch, pixel_coord.x, pixel_coord.y);
		SDL_Color pixel;
		SDL_GetRGB(surface_pixel, format, &pixel.r, &pixel.g, &pixel.b);

		// there's no wall here (of course), but this is used for the shading calculation
		const double shade = calculate_shade(screen.projection_distance / floor_actual_distance);
		surface_pixel = SDL_MapRGB(format, pixel.r * shade, pixel.g * shade, pixel.b * shade);
		*get_pixbuf_pixel(wall.x, floor_y) = surface_pixel;
	}
}

/////