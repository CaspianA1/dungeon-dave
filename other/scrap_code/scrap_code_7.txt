/*
int rel_x = player.x * width_ratio, rel_y = player.y * height_ratio;

SET_COLOR(renderer_2D, 0, 191, 255);
SDL_Rect rect = {rel_x, rel_y, 5, 5};
SDL_RenderFillRect(renderer_2D, &rect);

SET_COLOR(renderer_2D, 255, 255, 255);

float half_fov = fov / 2;

for (float theta = player.angle - half_fov;
	theta < player.angle + half_fov; theta += theta_step) {

	float radian_theta = to_radians(theta);
	float cos_theta = cos(radian_theta), sin_theta = sin(radian_theta);

	float dist = 0, new_x, new_y;
	while (dist += dist_step) {
		new_x = cos_theta * dist + rel_x;
		new_y = sin_theta * dist + rel_y;

		if (new_x < 0 || new_x > screen_width || new_y < 0 || new_y > screen_height)
			break;

		if (map[(int) (new_y / height_ratio)][(int) (new_x / width_ratio)]) break;
	}
	SDL_RenderDrawLine(renderer_2D, rel_x, rel_y, new_x, new_y);
}
*/

/////

/*
SET_COLOR(renderer_2D, 0, 191, 255);
SDL_Rect rect = {rel_x, rel_y, 5, 5};
SDL_RenderFillRect(renderer_2D, &rect);
SET_COLOR(renderer_2D, 255, 255, 255);
*/

/*
#ifdef MODE_2D
SET_COLOR(renderer_2D, 0, 0, 0);
SDL_RenderClear(renderer_2D);
render_map_2D();
raycast_2D(player);
SDL_RenderPresent(renderer_2D);
SDL_UpdateWindowSurface(window_2D);
#endif
*/

/////

// theta_step = 0.01, // 0.05 before. fov / screen_width could also work

////////////////////

/*
float radian_angle = to_radians(player -> angle);
float move_x = cos(radian_angle) * move_speed_decr,
	move_y = sin(radian_angle) * move_speed_decr;

/////
if (keys[SDL_SCANCODE_A]) player -> angle -= angle_turn;
if (keys[SDL_SCANCODE_S]) player -> angle += angle_turn;

int moved = 0,
	state_up = keys[SDL_SCANCODE_UP],
	state_down = keys[SDL_SCANCODE_DOWN],
	state_left = keys[SDL_SCANCODE_LEFT],
	state_right = keys[SDL_SCANCODE_RIGHT];

if (state_up || state_down || state_left || state_right) moved = 1;
if (state_up) player -> pos.x += move_x, player -> pos.y += move_y;
if (state_down) player -> pos.x -= move_x, player -> pos.y -= move_y;
if (state_left) player -> pos.x += move_y, player -> pos.y -= move_x;
if (state_right) player -> pos.x -= move_y, player -> pos.y += move_x;

/////
if (player -> pos.x < 0) player -> pos.x = 0;
else if (player -> pos.x > screen_width) player -> pos.x = screen_width;

if (player -> pos.y < 0) player -> pos.y = 0;
else if (player -> pos.y > screen_height) player -> pos.y = screen_height;

if (is_a_wall(map[(int) player -> pos.y][(int) player -> pos.x]))
	player -> pos.y = player -> prev_pos.y, player -> pos.x = player -> prev_pos.x;

if (player -> angle > 360) player -> angle = 0;
else if (player -> angle < 0) player -> angle = 360;
/////
if (moved && (player -> prev_pos.y != player -> prev_pos.y || player -> prev_pos.x != player -> pos.x)) {
	Pace* pace = &player -> pace;
	float movement = pace -> step * (pace -> up * 2 - 1);
	pace -> height += movement;
	if (pace -> height > pace -> bound || pace -> height < -pace -> bound)
		pace -> up = !pace -> up;
}

player -> prev_pos.y = player -> pos.y, player -> prev_pos.x = player -> pos.x;
*/

////////////////////

/*
SDL_Rect slice = {tex_coord, 0, 1, tex_h};
SDL_RenderCopy(renderer_3D, wall.texture, &slice, &screen_pos);
*/

/////

// float tex_step = 1 / ((sprite.hit_end - sprite.hit_begin) / sprite.surface -> w);
printf("%f\n", tex_step);

/////

/*
float progress = sprite.hit_end / screen_width;
printf("progress = %f\n", progress);
float answer = 64 - (progress * 128);
printf("answer = %f\n", answer);
begin = answer;
*/

/////

printf("sprite.hit_end = %f\n", sprite.hit_end);
// float progress = 1 - sprite.hit_end / screen_width;
// float progress = sprite.hit_end;
// printf("turned %f %% of the way\n", progress * 100);

/*
printf("progress = %f\n", progress);
begin = 128 * progress - 32;
printf("begin = %f\n", begin);
*/

/////

float progress = sprite.hit_end / screen_width;
printf("progress = %f\n", progress);
begin = sprite.surface -> w * (168 - sprite.hit_end);

/////

printf("hit from %f to %f, diff %f\n",
	sprite.hit_begin, sprite.hit_end, sprite.hit_end - sprite.hit_begin);

/////


float begin = 0;

if (sprite.hit_begin == 0) {
	printf("ended at %f\n", sprite.hit_end);
	int a = screen_width - sprite.hit_end;
	DEBUG(a, d);
}

/////

int cast_range = sprite.hit_end - sprite.hit_begin;

for (float x = 0; x < cast_range; x += step_x) {
	int absolute_x = x + (sprite.hit_end - sprite.hit_begin);

	if (z_buffer[(int) absolute_x] > sprite.distance) {
		int height = screen_height / sprite.distance;

		SDL_Rect screen_pos = {
			absolute_x,
			(screen_height / 2 - height / 2) + player.pace.height,
			step_x + 1,
			height
		};

		render_scanline(sprite, x, &screen_pos);
	}
}

/////

int tex_begin = (sprite.hit_begin / screen_width) * sprite.surface -> w;
int tex_end = (sprite.hit_end / screen_width) * sprite.surface -> w;

printf("tex_begin = %d\n", tex_begin);

/////

/*
float tex_coord = 0;
if (sprite.hit_begin == 0) {
	float progress = 1 - sprite.hit_end / screen_width;
	DEBUG(a, f);
	tex_coord = progress * 64 - 50;
	DEBUG(tex_coord, f);
}
*/

/////

float tex_coord = (1 - sprite.hit_end / screen_width) * 64;
DEBUG(tex_coord, f);

/////

// think about where the sprite is centered in terms of the screen, and the begin and end hits

float tex_coord = 0; // where does that begin?
if (sprite.hit_begin == 0) {
	printf("Out of bounds!\n");
	tex_coord = (sprite.hit_end / screen_width) * 64;
	DEBUG(tex_coord, f);
}

/////