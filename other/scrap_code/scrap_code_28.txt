enum {
	screen_width = 1200, screen_height = 700, map_width = 25, map_height = 15,
	fov = 90, max_fps = 60, ray_column_width = 2,
	plain_wall_count = 4, textured_wall_count = 7, billboard_count = 4,
	animation_count = 3
};

/*
5 = grass (floor)
6 = cobblestone_2
7 = mossy
8 = colorstone (ceiling)
9 = pyramid_bricks
10 = desert_snake
11 = sand
*/

const byte map[map_height][map_width] = {
	{9, 9, 9, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
	{9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{9, 0, 0, 0, 9, 0, 0, 0, 0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 6},
	{9, 0, 0, 0, 9, 0, 0, 11,0, 11,0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 7, 7, 0, 6},
	{9, 9, 9, 0, 9, 0, 0, 11,0, 11,0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 7, 7, 0, 6},
	{6, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 9, 9, 9, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 7, 7, 7, 7, 7, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 6, 0, 10,0, 0, 0, 10,0, 6, 0, 7, 0, 0, 7, 0, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 7, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 6, 6, 6, 6, 0, 6, 6, 6, 6, 0, 7, 7, 7, 7, 0, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};


static Sprite* textured_walls;
static Billboard* billboards;
static Animation animations[animation_count];

/////

void init() {
	screen = init_screen();

	//////////

	textured_walls = init_sprites(textured_wall_count,
		"assets/walls/grass.bmp",
		"assets/walls/cobblestone_2.bmp",
		"assets/wolf/mossy.bmp",
		"assets/wolf/colorstone.bmp",

		"assets/walls/pyramid_bricks.bmp",
		"assets/walls/desert_snake.bmp",
		"assets/walls/sand.bmp");

	//////////

	billboards = init_billboards(billboard_count,
		"assets/objects/tomato.bmp",
		"assets/objects/demon_tut.bmp",
		"assets/objects/jungle.bmp",
		"assets/objects/health_kit.bmp");

	const VectorF billboard_positions[billboard_count] = {
		{6, 2},
		{23.5, 1.5},
		{11.5, 11.5},
		{11.5, 7.5}
	};

	for (int i = 0; i < billboard_count; i++)
		billboards[i].pos = billboard_positions[i];

	//////////

	Animation loaded_animations[animation_count] = {
		init_animation("assets/spritesheets/gold_key.bmp", 3, 4, 12, 6),
		init_animation("assets/spritesheets/bogo.bmp", 2, 3, 6, 3),
		init_animation("assets/spritesheets/torch.bmp", 3, 3, 9, 9)
	};

	const VectorF animation_positions[animation_count] = {
		{1.5, 1.5}, {4.5, 11.5}, {19, 9.5}
	};

	for (int i = 0; i < animation_count; i++) {
		Animation* animation = &loaded_animations[i];
		animation -> billboard.pos = animation_positions[i];
		memcpy(&animations[i], animation, sizeof(Animation));
	}
}

void deinit() {
	deinit_sprites(textured_walls, textured_wall_count);
	deinit_billboards(billboards, billboard_count);
	deinit_animations(animations, animation_count);
	deinit_screen();
}

/////

const double
	width_ratio = (double) screen_width / map_width,
	height_ratio = (double) screen_height / map_height;

/////

/*
level_1.map = calloc(level_1_map_height, sizeof(byte*));
for (int i = 0; i < level_1_map_height; i++) {
	byte* row = level_1.map[i];
	row = calloc(level_1_map_width, sizeof(byte)); // to malloc later
	memcpy(row, map_data + i, sizeof(byte) * level_1_map_width);
}
*/

/////

plain_wall_count = 4,

void draw_untextured_wall(const byte point, const SDL_Rect wall) {
	byte r, g, b;
	switch (point) {
		case 1: r = 255, g = 255, b = 0; break;
		case 2: r = 0, g = 128, b = 128; break;
		case 3: r = 255, g = 165, b = 0; break;
		default: r = 255, g = 0, b = 0; break;
	}
	const double shade = calculate_shade(wall.h);
	draw_rectangle(&wall, r * shade, g * shade, b * shade);
}

inlinable void draw_wall(const CastData cast_data, const VectorF dir, const SDL_Rect wall) {
	if (cast_data.point <= plain_wall_count)
		draw_untextured_wall(cast_data.point, wall);
	else
		draw_textured_wall(cast_data, dir, wall);
}

inlinable void draw_rectangle(const SDL_Rect* rect, const byte r, const byte g, const byte b) {
	SDL_SetRenderDrawColor(screen.renderer_3D, r, g, b, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer_3D, rect);
}

// const Sprite wall_sprite = current_level.textured_walls[cast_data.point - plain_wall_count - 1];

/*
const byte map_data[level_1_map_height][level_1_map_width] = {
	{9, 9, 9, 9, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
	{9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{9, 0, 0, 0, 9, 0, 0, 0, 0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 6},
	{9, 0, 0, 0, 9, 0, 0, 11,0, 11,0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 7, 7, 0, 6},
	{9, 9, 9, 0, 9, 0, 0, 11,0, 11,0, 11,0, 11,0, 11,0, 0, 0, 0, 0, 7, 7, 0, 6},
	{6, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 0, 9, 9, 9, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 7, 7, 7, 7, 7, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 6, 0, 10,0, 0, 0, 10,0, 6, 0, 7, 0, 0, 7, 0, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 7, 0, 0, 7, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 6, 6, 6, 6, 0, 6, 6, 6, 6, 0, 7, 7, 7, 7, 0, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6},
	{6, 0, 0, 9, 0, 9, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 6},
	{6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6},
	{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};
*/

/*
for (int y = 0; y < level_1_map_height; y++) {
	printf("{");
	for (int x = 0; x < level_1_map_width - 1; x++) {
		const byte val = map_data[y][x];
		printf("%d, ", val == 0 ? 0 : val - 4);
	}

	const byte end = map_data[y][level_1_map_width - 1];
	printf("%d},\n", end == 0 ? 0 : end - 4);
}
*/

/////

for (int y = 0; y < level_1_map_height; y++) {
	for (int x = 0; x < level_1_map_width; x++) {
		// options: 
		// byte foo = (rand() % 2) + 1;
		byte foo = 25;
		ceiling_data[y][x] = foo;
		floor_data[y][x] = foo;
	}
}

/////

/*
level_1.wall_data = malloc(level_1_map_width * sizeof(byte));
level_1.ceiling_data = malloc(level_1_map_width * sizeof(byte));
level_1.floor_data = malloc(level_1_map_width * sizeof(byte));

for (int i = 0; i < level_1_map_height; i++) {
	byte
		*wall_row = level_1.wall_data[i],
		*floor_row = level_1.wall_data[i],
		*ceiling_row = level_1.wall_data[i];

	wall_row
}
*/

/////


draw_floor_or_ceil(player.pos, dir, wall.x, 0, wall.y,
	cos_beta, pace, player.y_pitch, get_ceil_row, 1);

	/*
	, current_level.textured_walls
		[current_level.ceiling_data[hit_y][hit_x]]);
	*/

	// current_level.textured_walls[3]);

draw_floor_or_ceil(player.pos, dir, wall.x, wall.y + wall.h, screen_height,
	cos_beta, pace, player.y_pitch, get_floor_row, 0);

	/*, current_level.textured_walls
		[current_level.floor_data[hit_y][hit_x]]);*/

	//  current_level.textured_walls[0]);

/////

const int move_up_amt = (double) (abs(y_pitch) / half_screen_height) * animation -> frame_h / 20;

const SDL_Rect sheet_crop = {
	frame_origin.x, frame_origin.y + move_up_amt,

/////

/*
byte
	floor_data[level_1_map_height][level_1_map_width],
	ceiling_data[level_1_map_height][level_1_map_width];

for (int y = 0; y < level_1_map_height; y++) {
	for (int x = 0; x < level_1_map_width; x++) {
		floor_data[y][x] = 1;
		ceiling_data[y][x] = 2;
	}
}
*/



level_1.wall_data = malloc(level_1_map_height * sizeof(byte*));

/*
level_1.ceiling_data = malloc(level_1_map_height * sizeof(byte));
level_1.floor_data = malloc(level_1_map_height * sizeof(byte));
*/

for (int i = 0; i < level_1_map_height; i++) {

	/*
	level_1.wall_data[i] = malloc(level_1_map_width * sizeof(byte));
	printf("Before memcpy, i = %d\n", i);
	// memcpy(level_1.wall_data + i, wall_data + i, sizeof(wall_data[i]));
	printf("After memcpy\n");
	*/

	/*
	level_1.ceiling_data[i] = calloc(level_1_map_width, sizeof(byte));
	level_1.floor_data[i] = calloc(level_1_map_width, sizeof(byte));
	*/

	/*
	memcpy(&level_1.wall_data[i], &wall_data[i], level_1_map_width * sizeof(byte));
	memcpy(&level_1.ceiling_data[i], &ceiling_data[i], level_1_map_width * sizeof(byte));
	memcpy(&level_1.floor_data[i], &floor_data[i], level_1_map_width * sizeof(byte));
	*/
}

for (int y = 0; y < level_1_map_height; y++) {
	printf("{");
	for (int x = 0; x < level_1_map_width - 1; x++) {
		printf("%d, ", level_1.wall_data[y][x]);
	}
	printf("%d}\n", level_1.wall_data[y][level_1_map_width - 1]);
}

/////

/*
for (int y = 0; y < level_1_map_height; y++)
	memcpy(level_1.wall_data + y, wall_data + y, level_1_map_width);
*/

/*
level_1.wall_data = malloc(level_1_map_height * sizeof(byte*));
for (int y = 0; y < level_1_map_height; y++) {
	DEBUG(y, d);

	printf("About to copy this row: {");
	for (int i = 0; i < level_1_map_width - 1; i++)
		printf("%d, ", wall_data[y][i]);
	printf("%d}\n", wall_data[y][level_1_map_width - 1]);

	// byte* row = malloc(level_1_map_width); // byte guaranteed size of 1
	memcpy(level_1.wall_data + y, wall_data + y, level_1_map_width);
}
printf("Done\n");
*/

/////

/*
byte
	wall_data[level_1_map_height][level_1_map_width],
	ceiling_data[level_1_map_height][level_1_map_width],
	floor_data[level_1_map_height][level_1_map_width];
*/

/////

/*
printf("Level address: %p\n", (void*) &level);

byte*** wall_data_ptr = &level.wall_data;
printf("Wall data stored in struct at %p\n", (void*) wall_data_ptr);
wall_data_ptr = malloc(map_height * sizeof(byte*));
printf("Assigned wall data ptr\n");
for (int y = 0; y < map_height; y++)
	wall_data_ptr[y] = malloc(map_width);

wall_data_ptr[0][0] = 5;
DEBUG(wall_data_ptr[0][0], d);
DEBUG(level.wall_data, d);

exit(0);
*/

/////


// I don't need to worry about struct memory locations; it should point to the same memory anyways

printf("Address stored by wall data before: %p\n", (void*) level.wall_data);

byte*** wall_data_ptr = &level.wall_data;
*wall_data_ptr = calloc(map_height, sizeof(byte*));
printf("Address stored by wall data after: %p\n", (void*) level.wall_data);

printf("---\n");
for (int y = 0; y < map_height; y++) {
	DEBUG(y, d);
	printf("Before, offset val was %d\n", (int) level.wall_data[y]);
	wall_data_ptr[y] = calloc(map_width, sizeof(byte));
	printf("After, offset val is %d\n", (int) level.wall_data[y]);
	// printf("Pointer stored at offset %d is %p\n", y, (void*) wall_data_ptr[y]);
}

printf("Try to assign\n");
/*
// (*wall_data_ptr)[0][0] = 10;
byte** not_a_ptr = *wall_data_ptr;
not_a_ptr[0][0] = 10;
*/
printf("Assignment successful\n");
printf("Value stored at origin of level wall data: %d\n", level.wall_data[0][0]);

exit(0);

/*
byte*** map_data[3] = {&level.wall_data, &level.ceiling_data, &level.floor_data};
for (int i = 0; i < 3; i++) {
	byte*** map_datum = map_data[i]; // pointer to double-pointer array in struct
	*map_datum = malloc(map_height * sizeof(byte*));

	printf("in array, %p; vs wall i: %p\n", (void*) map_data[i], (void*) &level.wall_data);

	for (int y = 0; y < map_height; y++) {
		DEBUG(y, d);
		*map_datum[y] = malloc(map_width); // byte size is always 1
		printf("Map datum at row %d is %p\n", y, (void*) map_datum[y]);
	}

	printf("Assignment test\n");
	printf("Address of map datum[0][0]: %p\n", map_datum[0][0]);
	*map_datum[0][0] = 'a';

	printf("map datum at (0, 0) is %c\n", *map_datum[0][0]);
	printf("wall data at (0, 0) is %c\n", level.wall_data[0][0]);
}

DEBUG(level.wall_data[0][0], d);
exit(0);
return level;
*/

/////

printf("Address stored by wall data before: %p\n", (void*) level.wall_data);
byte*** wall_data_ptr = &level.wall_data;
*wall_data_ptr = calloc(map_height, sizeof(byte*));
printf("Address stored by wall data after: %p\n", (void*) level.wall_data);

printf("---\n");
for (int y = 0; y < map_height; y++) {
	DEBUG(y, d);
	printf("Before, offset val at %d was %d\n", (void*) level.wall_data[y], level.wall_data[y]);

	/*
	wall_data_ptr[y] = calloc(map_width, sizeof(byte));
	*wall_data_ptr[y] = 5;
	*/

	byte** row = calloc(map_width, sizeof(byte*));
	wall_data_ptr[y] = row;

	wall_data_ptr[y][0] = 2;

	printf("After, offset val is %d\n", level.wall_data + y);
	// printf("Pointer stored at offset %d is %p\n", y, (void*) wall_data_ptr[y]);
}

printf("Value in ptr thing: %d\n", wall_data_ptr[0][0]);
printf("Value stored at origin of level wall data: %d\n", &level.wall_data[0][0]);
exit(0);

/////

	byte*** map_data[3] = {&level.wall_data, &level.ceiling_data, &level.floor_data};
	for (int i = 0; i < 3; i++) {
		byte*** map_datum = map_data[i];
		*map_datum = malloc(map_height * sizeof(byte*));

		for (int y = 0; y < map_height; y++)
			(*map_datum)[y] = malloc(map_width); // byte size = 1

		(*map_datum)[0][0] = 2;

		DEBUG((*map_datum[0][0]), d);
	}

	DEBUG(level.wall_data[0][0], d);

	return level;

	/* working:
	byte*** wall_data_ptr = &level.wall_data;
	*wall_data_ptr = calloc(map_height, sizeof(byte*));

	printf("Wall data in level at %p, and ptr stores the address %p\n",
		(void*) level.wall_data, (void*) wall_data_ptr);

	for (int y = 0; y < map_height; y++)
		(*wall_data_ptr)[y] = calloc(map_width, sizeof(byte));

	(*wall_data_ptr)[0][0] = 2;

	printf("Value in ptr thing: %d\n", (*wall_data_ptr)[0][0]);
	// printf("Value stored at origin of level wall data: %p\n", (void*) &level.wall_data[0][0]);
	printf("Value stored at origin of level wall data: %d\n", level.wall_data[0][0]);
	exit(0);
	*/
}

/////

/*
const Sprite sprite = current_level.textured_walls[is_ceiling + 2];

const SDL_Surface* surface = sprite.surface;
const SDL_PixelFormat* format = surface -> format;
const void* pixels = surface -> pixels;
const int
	surface_pitch = surface -> pitch,
	sprite_w = sprite.surface -> w;
*/

// cannot be initialized until its two variants are dynamically allocated

/////

/*
for (int y = 0; y < level_1_map_height; y++) {
	for (int x = 0; x < level_1_map_width; x++) {
		printf("%d, ", ceiling_data[y][x]);
	}
	printf("\n");
}
*/

/////

/*
static byte
	ceiling_data[level_1_map_height][level_1_map_width],
	floor_data[level_1_map_height][level_1_map_width];
*/

Level level_1 = init_level(level_1_map_width, level_1_map_height, 11.5, 13.5);

for (int y = 0; y < level_1_map_height; y++)
	memcpy(level_1.wall_data[y], &wall_data[y], level_1_map_width);

enum {ceil_floor_point_count = 4};
const byte ceil_floor_points = {5, 6, 7};

set_rand_map_points

/*
for (int y = 0; y < level_1_map_height; y++) {
	for (int x = 0; x < level_1_map_width; x++) {

		byte rand_point; // grass or colorstone
		do rand_point = rand() % 4;
		while (rand_point == 1 || rand_point == 2);

		// byte rand_point = 0;

		ceiling_data[y][x] = rand_point;
		floor_data[y][x] = rand_point;
	}
}
*/


/*
for (int y = 0; y < level_1_map_height; y++) {
	memcpy(level_1.wall_data[y], &wall_data[y], level_1_map_width);
	memcpy(level_1.ceiling_data[y], &ceiling_data[y], level_1_map_width);
	memcpy(level_1.floor_data[y], &floor_data[y], level_1_map_width);
}
*/

/////