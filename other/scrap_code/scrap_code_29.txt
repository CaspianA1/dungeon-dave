/*
#ifdef __clang__
#include <SDL2/SDL.h>
#else
#include <SDL.h>
#endif
*/

/////

/*
DEBUG(i, d);
DEBUG(va_arg(animation_data, const char*), s);
DEBUG(va_arg(animation_data, const int), d);
DEBUG(va_arg(animation_data, const int), d);
DEBUG(va_arg(animation_data, const int), d);
DEBUG(va_arg(animation_data, const int), d);
DEBUG(va_arg(animation_data, const double), lf);
DEBUG(va_arg(animation_data, const double), lf);
*/

/*
printf("Before part 1\n");
Animation new_animation = init_animation(
	(va_arg(animation_data, const char*)),
	(va_arg(animation_data, const int)),
	(va_arg(animation_data, const int)),
	(va_arg(animation_data, const int)),
	(va_arg(animation_data, const int)));
*/

// Animation new_animation;

printf("Initialized animation\n");

new_animation.billboard.pos.x = pos_x;
new_animation.billboard.pos.x = pos_y;

/*
new_animation.billboard.pos.x = (va_arg(animation_data, const double));
new_animation.billboard.pos.y = (va_arg(animation_data, const double));
*/

/////

/*
for (int y = 0; y < current_level.map_height; y++) {
	printf("{");
	byte* row = tex_hit_data[y];
	for (int x = 0; x < current_level.map_width - 1; x++)
		printf("%d, ", row[x]);
	printf("%d}\n", row[current_level.map_width - 1]);
}
printf("---\n\n\n");
*/

/////

/*
set_level_textured_walls(&level_1, textured_wall_count,
	"../assets/walls/grass.bmp",
	"../assets/walls/cobblestone_2.bmp",
	"../assets/wolf/mossy.bmp",
	"../assets/wolf/colorstone.bmp",

	"../assets/walls/pyramid_bricks_3.bmp",
	"../assets/walls/stone_2.bmp",
	"../assets/walls/sand.bmp",
	"../assets/walls/hieroglyphics.bmp",
	"../assets/walls/cobblestone_3.bmp");
*/

/////

typedef struct {
	int screen_width, screen_height,
		fov, max_fps, ray_column_width;
} Settings;

/////

/*
SDL_Surface* text_surface = TTF_RenderText_Solid(font, "DUNGEON DAVE 3D", font_color);
SDL_Texture* text_texture = SDL_CreateTextureFromSurface(screen.renderer_3D, text_surface);

const double w_h_ratio = (double) text_surface -> w / text_surface -> h;

const int x_begin = screen_width / 3;
const int y_begin = x_begin / w_h_ratio;

const SDL_Rect screen_pos = {x_begin - text_surface -> w, 0, x_begin, y_begin};
*/

/////

/*
const int
	third_screen_w = screen_width / 3,
	third_screen_h = screen_height / 3,
	font_w = text_surface -> w,
	font_h = text_surface -> h;

const int font_center_x = 
*/

/*
const double font_w_over_h = (double) text_surface -> w / text_surface -> h;
const int third_screen_w = screen_width / 3, third_screen_h = screen_height / 3;
SDL_Rect screen_pos;
screen_pos.x = third_screen_w;
screen_pos.y = third_screen_h;
screen_pos.w = 100;
screen_pos.h = third_screen_h;
*/

/////

const int w_height(const byte point) {
	return (point == 5) + 1;
}

void raycast(const Player player) {
	const double player_angle = to_radians(player.angle);
	for (int screen_x = 0; screen_x < screen_width; screen_x += ray_column_width) {
		const double theta =
			atan((screen_x - half_screen_width) / screen.projection_distance) + player_angle;

		const VectorF ray_direction = {cos(theta), sin(theta)};
		// CastData cast_data = {.dist = 0};

		VectorF ray_begin = player.pos;
		// int first_iteration = 1; // current_height = 0;

		while (1) {
			dda(ray_begin, ray_direction); break;

			/*
			if (ray_begin.x < 0 || ray_begin.x >= map_width - 1 || ray_begin.y < 0 || ray_begin.y >= map_height - 1) {
				printf("Exit\n");
				break;
			}
			else printf("ray_begin was correct: {%lf, %lf}\n", ray_begin.x, ray_begin.y);

			cast_data = dda(ray_begin, ray_direction);

			printf("Hit at {%lf, %lf}, while next ray starts at {%lf, %lf}\n",
			cast_data.hit.x, cast_data.hit.y, cast_data.next_cast_start.x, cast_data.next_cast_start.y);

			const double correct_dist = cast_data.dist * cos(player_angle - theta);

			if (first_iteration) {
				screen.z_buffer[screen_x] = correct_dist;
				first_iteration = 0;
			}

			const int wall_height = screen.projection_distance / correct_dist;

			SDL_Rect wall = {
				screen_x,
				half_screen_height - wall_height / 2 + player.y_pitch + player.pace.screen_offset,
				ray_column_width, wall_height
			};

			draw_wall(cast_data, ray_direction, wall);

			ray_begin = cast_data.next_cast_start;	
			*/
		}
	}
}

/////

void print_int_queue(Queue queue) {
	for (int i = 0; i < queue.length; i++)
		printf("%d, ", (int) queue.data[i]);
	printf("\n");
}


/////

Queue queue = init_queue(3, 1, 2, 3);
enqueue(&queue, (void*) 5);
enqueue(&queue, (void*) 6);
enqueue(&queue, (void*) 7);
print_int_queue(queue);

deinit_queue(queue);
exit(0);

// 7, 6, 5, 1, 2, 3

/////

/*
floor_data[map_height][map_width] = {
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
	{4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}
};
*/

Level level_1 = init_level(map_width, map_height, 11.5, 13.5);

for (int y = 0; y < map_height; y++) {
	memcpy(level_1.wall_data[y], &wall_data[y], map_width);
	memset(level_1.ceiling_data[y], 4, map_width);
	memset(level_1.floor_data[y], 4, map_width);
}

/*
for (int y = 0; y < map_height; y++) {
	for (int x = 0; x < map_width; x++) {
		level_1.ceiling_data[y][x] = 4;
		level_1.floor_data[y][x] = floor_data[y][x];

		// x > map_width / 2 && y > map_height / 2 ? 4 : 8;
	}
}
*/

/*
const byte ceil_floor_points[ceil_floor_point_count] = {4};
randomize_map(level_1, level_1.ceiling_data, ceil_floor_points, ceil_floor_point_count);
randomize_map(level_1, level_1.floor_data, ceil_floor_points, ceil_floor_point_count);
*/

/////

/*

DynArray path_copy;
memcpy(&path_copy, path, sizeof(DynArray)); printf("First memcpy\n");
memcpy(&path_copy.data, path -> data, path -> length * sizeof(void*)); printf("Second memcpy\n");

const VectorI* first = path_copy.data[0];
DEBUG(first -> x, d);

/*
printf("Path copy: {");
for (int i = 0; i < path_copy.length; i++) {
	VectorI* path_step = path_copy.data[i];
	printf("{%d, %d}", path_step -> x, path_step -> y);
}
printf("}\n");
*/

/////

for (int y = 0; y < current_level.map_height; y++) {
	for (int x = 0; x < current_level.map_width; x++)
		printf("%d", visited[y][x]);
	printf("\n");
}

/////

/*
printf("Before code of shallow copy\n");

DynArray copy = {malloc(src.length * sizeof(void*)), src.length, src.length};

printf("Made copy + one more allocation\n");

printf("Memcpy #1\n");



printf("Copied dyn array\n");
return copy;
*/

/////

inlinable void push_dyn_array_vertex(DynArray* dyn_array, const VectorI vertex) {
	VectorI* heap_copy_vertex = malloc(sizeof(VectorI));
	memcpy(heap_copy_vertex, &vertex, sizeof(VectorI));
	push_dyn_array(dyn_array, (void*) heap_copy_vertex);
}

/////

/*
printf("Path copy: {");
for (int i = 0; i < path_copy.length; i++) {
	VectorI* path_step = path_copy.data[i];
	printf("{%d, %d}", path_step -> x, path_step -> y);
}
printf("}\n");
*/

/////


// operates on current_level.map_data
/*
const DynArray get_edges(const VectorI vertex) {
	const VectorI
		top = {vertex.x, vertex.y - 1},
		bottom = {vertex.x, vertex.y + 1},
		left = {vertex.x - 1, vertex.y},
		right = {vertex.x + 1, vertex.y},

		top_left = {vertex.x - 1, vertex.y - 1},
		bottom_left = {vertex.x - 1, vertex.y + 1},
		top_right = {vertex.x + 1, vertex.y - 1},
		bottom_right = {vertex.x + 1, vertex.y + 1};

	const VectorI possible_edges[8] = {
		top, bottom, left, right, top_left, bottom_left, top_right, bottom_right
	};

	DynArray valid_edges = init_dyn_array(0);
	for (int i = 0; i < 8; i++) {
		const VectorI possible_edge = possible_edges[i];
		if (valid_vertex(possible_edge)) {
			printf("Valid edge: {%d, %d}\n", possible_edge.x, possible_edge.y);

			if ((eq_VectorII(possible_edge, top_left) && current_level.wall_data[left.y][left.x]) ||
				(eq_VectorII(possible_edge, top_right) && current_level.wall_data[right.y][right.x]) ||
				(eq_VectorII(possible_edge, bottom_right) && current_level.wall_data[bottom.y][bottom.x]) ||
				(eq_VectorII(possible_edge, bottom_left) && current_level.wall_data[bottom.y][bottom.x]))
				continue;

			push_dyn_array_vertex(&valid_edges, possible_edge);
		}
	}
	return valid_edges;
}
*/

const DynArray* bfs(const VectorF begin, const VectorF end) {
	const VectorI int_begin = {(int) floor(begin.x), (int) floor(begin.y)};

	byte** visited = malloc(current_level.map_height * sizeof(byte*));
	for (int y = 0; y < current_level.map_height; y++)
		visited[y] = calloc(current_level.map_width, sizeof(byte));
	visited[int_begin.y][int_begin.x] = 1;

	DynArray base_path = init_dyn_array(1, (void*) &int_begin);
	Queue paths = init_queue(1, (void*) &base_path);

	while (paths.length > 0) {
		print_paths(paths);

		DynArray* path = dequeue(&paths);
		const VectorI* vertex = path -> data[path -> length - 1];

		if (eq_VectorIF(*vertex, end))
			return path;

		const VectorI
			top = {vertex.x, vertex.y - 1},
			bottom = {vertex.x, vertex.y + 1},
			left = {vertex.x - 1, vertex.y},
			right = {vertex.x + 1, vertex.y},

			top_left = {vertex.x - 1, vertex.y - 1},
			bottom_left = {vertex.x - 1, vertex.y + 1},
			top_right = {vertex.x + 1, vertex.y - 1},
			bottom_right = {vertex.x + 1, vertex.y + 1};

		const VectorI possible_neighbors[8] = {
			top, bottom, left, right, top_left, bottom_left, top_right, bottom_right
		};

		for (int i = 0; i < 8; i++) {
			const VectorI possible_neighbor = possible_neighbors[i];
			if (valid_vertex(possible_neighbor)) {
				
			}
		}



		/*
		DynArray edges = get_edges(*vertex);
		for (int i = 0; i < edges.length; i++) {
			const VectorI* edge = edges.data[i];
			byte* visited_state = &visited[edge -> y][edge -> x];
			if (!*visited_state) {
				*visited_state = 1;
				DynArray path_copy = copy_dyn_array(*path);
				enqueue(&paths, &path_copy);
			}
		}
		*/
	}

/////

/*
DynArray edges = get_edges(*vertex);
for (int i = 0; i < edges.length; i++) {
	const VectorI* edge = edges.data[i];
	byte* visited_state = &visited[edge -> y][edge -> x];
	if (!*visited_state) {
		*visited_state = 1;
		DynArray path_copy = copy_dyn_array(*path);
		enqueue(&paths, &path_copy);
	}
}
*/

/////

// push_dyn_array_vertex(&path_copy, possible_neighbor);

inlinable void push_dyn_array_vertex(DynArray* dyn_array, const VectorI vertex) {
	// printf("\tCopy allocation of vertex\n");
	VectorI* heap_copy_vertex = malloc(sizeof(VectorI));
	memcpy(heap_copy_vertex, &vertex, sizeof(VectorI));
	push_dyn_array(dyn_array, (void*) heap_copy_vertex);
}

/////

/*
inlinable void print_paths(const Queue paths) {
	printf("{");
	for (int i = 0; i < paths.length; i++) {
		const DynArray* path = paths.data[i];
		printf("{");		
		for (int j = 0; j < path -> length - 1; j++) {
			const VectorI* entry = path -> data[i]; // fails here
			printf("[%d, %d]", entry -> x, entry -> y);
		}

		const VectorI* last = path -> data[path -> length - 1];
		printf("{%d, %d}}", last -> x, last -> y);
	}
	printf("}\n");
}
*/

/////

/*
inlinable void print_path(const DynArray* path) {
	for (int i = 0; i < path -> length; i++) {
		const VectorI* vertex = path -> data[i];
		printf("{%d, %d}", vertex -> x, vertex -> y);
		if (i != path -> length - 1) printf(", ");
	}
}

inlinable void print_paths(const Queue paths) {
	printf("number of paths in path: %d: ", paths.length);
	for (int i = 0; i < paths.length; i++)
		print_path((DynArray*) paths.data[i]);
}
*/

/////