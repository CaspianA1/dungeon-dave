inlinable const int eq_VectorIF(const VectorI v1, const VectorF v2) {
	return fabs(v1.x - v2.x) < 1.0 && fabs(v1.y - v2.y) < 1.0;
}

/////

inlinable void print_path(const DynArray path) {
	printf("path = ");
	for (int i = 0; i < path.length; i++) {
		printf("{%d, %d}")
	}
}

/////

// printf("neighbor = {%d, %d}\n", possible_neighbor.x, possible_neighbor.y);

DynArray path_copy = copy_dyn_array(*path);
assert(paths_eq(path, &path_copy))

/*
for (int i = 0; i < path -> length; i++) {
	const VectorI
		*orig = path -> data[i],
		*new = path_copy.data[i];

	if (orig -> x != new -> x || orig -> y != new -> y) {
		printf("Bad copying\n");
	}
}
*/

/////

// printf("begin: {%d, %d}\nend = {%d, %d}\n", int_begin.x, int_begin.y, int_end.x, int_end.y);

/////

/*
// a new invalid neighbor appears
printf("-\nnew_neighbor = {%d, %d}\n", possible_neighbor.x, possible_neighbor.y);

DynArray path_copy = copy_dyn_array(*path);
printf("Path copy before pushing: ");
print_path(path_copy);

assert(paths_eq(path, &path_copy));

push_dyn_array(&path_copy, (void*) &possible_neighbor);

printf("Path copy after pushing: ");
print_path(path_copy);

enqueue(&paths, &path_copy);
*/

/////

valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./bin/$(OUT)

/////

/*
printf("src path: {___, %d, %d}\n", path.length, path.max_alloc);
printf("src path data: ");
print_path(path);
*/

/*
printf("dest path: {___, %d, %d}\n", copy.length, copy.max_alloc);
printf("dest path data: ");
print_path(copy);
*/

/////

void deinit_path_queue(PathQueue path_queue);

inlinable void deinit_path_queue(PathQueue path_queue) {
	for (int i = 0; i < path_queue.length; i++)
		free(path_queue.data[i].data);
	free(path_queue.data);
}

///// A container creator:

#define defcontainer(name, lowercase_name, contained)\
	typedef struct {contained* data; int length, max_alloc;} name;\
	\
	name init_#lowercase_name(const int init_length, ...) {\
		va_list args;\
		va_start(args, init_length);\
		name container = {malloc(init_length * sizeof(name)), init_length, init_length};\
		for (int i = 0; i < init_length; i++) container.data[i] = va_arg(args, contained);\
		va_end(args); return container;\
	}\

/////

Path init_path(const int init_length, ...);
Path copy_path(Path path);
void add_to_path(Path* path, const VectorI new);
const int paths_eq(const Path p1, const Path p2);
void print_path(const Path path);

PathQueue init_path_queue(const int init_length, ...);
void enqueue_to_path(PathQueue* path_queue, const Path new);
Path dequeue_from_path(PathQueue* path_queue);

/////

DEBUG(current_level.wall_data[vertex.y][vertex.x], d);

/////

// assert(paths_eq(path_copy, *path));

// printf("---\npath: "); print_path(path);
// DEBUG(path.length, d);

// printf("vertex: {%d, %d}\n", vertex.x, vertex.y);

// printf("Path created:"); print_path(path);

// printf("Will attempt to copy path: "); print_path(path);

// printf("Did so successfully: "); print_path(path);

/*
printf("Request to add this to the path: {%d, %d}\n", new.x, new.y);
printf("Path before: "); print_path(*path);
*/

// printf("Path after: "); print_path(*path);

// printf("Enqueueing this path: "); print_path(new);

for (int k = path_queue -> length; k > 0; k--){        
    path_queue -> data[k] = path_queue -> data[k - 1];
}
path_queue -> data[0] = new;

// printf("Enqueue succeeded\n");

// printf("Entering dequeue\n");

// printf("Dequeue succeeded\n");

/////

- enemy ai: where the hell is {5, 12} coming from? Solve it on Friday by looking at other's solutions. Also, with my code, it seems like almost all nodes in a path are becoming the same (see if they all point to the same place). That is the key problem.

/////

int malloc_count = 0, free_count = 0;

void* wmalloc(size_t size) {
	malloc_count++;
	return malloc(size);
}

void* wcalloc(int num, size_t size) {
	malloc_count++;
	return calloc(num, size);
}

void wfree(void* ptr) {
	free_count++;
	free(ptr);
}

/*
#define wmalloc malloc
#define wcalloc calloc
#define wfree free
*/

/////

printf("wmalloc count = %d, wfree count = %d\n", malloc_count, free_count);

/////

Printed result
Freed result
objc[48739]: Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.
objc[48739]: receiver 0x7fff89bb0f98, SEL 0x7fff7c40ae88, isa 0x7fff884ed678, cache 0x7fff884ed688, buckets 0x7f9b15546490, mask 0x7, occupied 0x1
objc[48739]: receiver 0 bytes, buckets 128 bytes
objc[48739]: selector 'retain'
objc[48739]: isa 'NSConstantArray'
objc[48739]: Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.
/bin/sh: line 1: 48739 Abort trap: 6           ./dungeon_dave.app
make: *** [run] Error 134
Caspians-MacBook-Air:dungeon_dave caspianahl

/////

find_leaks: build_debug
	leaks -list -fullContent -atExit -- ./bin/dungeon_dave.app

/////

/*
if (screen_row < 0 || screen_row >= screen_width || screen.z_buffer[screen_row] < billboard.dist)
	continue;
*/

/////

// memcpy(path_queue -> data + 1, path_queue -> data, (path_queue -> length - 1) * sizeof(Path));

/////

//////////
ResultBFS result = bfs(current_level.billboards[1].pos, player.pos);
printf("---\nHave result\n");
print_bfs_result(result);
printf("Printed result\n");
if (result.succeeded) free(result.path.data);
printf("Freed result\n");
//////////

/////

//////////
/*
ResultBFS result = bfs(current_level.billboards[0].pos, player.pos);
print_bfs_result(result);
if (result.succeeded) free(result.path.data);
*/
//////////

/////

/*
DEBUG(dist_a, lf);
DEBUG(dist_b, lf);

const double diff = dist_b - dist_a;
DEBUG(diff, lf);

if (diff > 0.0 && diff < 1.0)
	return 1;

return diff;
*/


/*
if (dist_a < dist_b) return 1;
else if (dist_b > dist_a) return -1;
else return 0;
*/

/*
return floor(((GenericBillboard*) b) -> billboard.dist -
	  ((GenericBillboard*) a) -> billboard.dist);
*/

/////

/*
const Path curr_path = nav -> path_to_player; // may be the same as prev_path
if (nav -> path_ind <= curr_path.length - 1) {
	// const VectorF curr_path_vertex_delta = {curr_path}

	const VectorI
		curr_pos = curr_path.data[nav -> path_ind],
		next_pos = curr_path.data[nav -> path_ind + 1];

	// this is the direction
	const VectorI curr_direction = {next_pos.x - curr_pos.x, next_pos.y - curr_pos.y};

	// change billboardpos based on velocity, direction vector and time

	// printf("curr = {%d, %d}, next = {%d, %d}\n", curr_pos.x, curr_pos.y, next_pos.x, next_pos.y);

	// const VectorI next_pos = curr_path.data[nav -> path_ind++];
	// const VectorF next_double_pos = {next_pos.x + 0.5, next_pos.y + 0.5};
	// nav -> animation -> billboard.pos = next_double_pos;
}
*/

/////

const double step_time_delta = (SDL_GetTicks() / 1000.0) - nav -> time_at_step;
double delta_step = nav -> v * step_time_delta;
double delta_step_x;
if (curr_dir.x < 0) delta_step_x = -delta_step;
else if (curr_dir.y)
if (curr_dir < 0) delta_step = -delta_step;


// move x

/*
printf("dir = {%d, %d}\n", curr_dir.x, curr_dir.y);

const Uint32 time_delta = SDL_GetTicks() / 1000.0 - nav -> time_at_step;

const VectorF next_pos = {
	curr_vertex.x + 5
};
*/

// dir -> angle -> movement

// curr_vertex.x * nav -> speed

/////

/*
pos -> x += nav -> a * ((SDL_GetTicks() / 1000.0) - nav
DEBUG(pos -> x, lf);
*/

/////

/*
DEBUG(curr_vertex.x, lf);
DEBUG(next_vertex.x, lf);

const VectorI curr_dir = {
	next_vertex.x - curr_vertex.x, next_vertex.y - curr_vertex.y
};
*/

/*
const VectorF unit_step_size = {
	curr_dir.x == 0 ? 0 : fabs(1.0 / curr_dir.x),
	curr_dir.y ==  0 ? 0 : fabs(1.0 / curr_dir.y)
};

DEBUG(unit_step_size.x, lf);
*/

/////

/*
if (direction.y != 0) {
	if (direction.y == 1) {
		pos -> y += 0.01;
	}
	else {
		pos -> y -= 0.01;
	}
}
*/

/*
VectorF* pos = &nav -> animation -> billboard.pos;

const double dy = pos -> y * direction.y;
DEBUG(dy, lf);

pos -> y += dy;
*/

/////

/*
if (dir.x == 1) pos -> x += nav -> v;
else if (dir.x == -1) pos -> y -= nav -> v;

// if (dir.y != 0) pos -> y += nav -> v * dir.y;
if (dir.y == 1) pos -> y += nav -> v;
else if (dir.y == -1) pos -> y -= nav -> v;
*/

/*
DEBUG(pos -> x, lf);
DEBUG(next_vertex.x, d);
*/

/////

/*
if (dir.x == 1 && pos -> x > next_vertex.x) {
	printf("Case 1\n");
	nav -> path_ind++;
}

else if (dir.x == -1 && pos -> x < next_vertex.x) {
	printf("Case 2\n");
	nav -> path_ind++;
}
*/


if (dir.x == -1) {
	printf("Negative direction\n");
	DEBUG(pos -> x, lf);
	DEBUG(next_vertex.x, d);

	if (pos -> x < next_vertex.x) nav -> path_ind++;
}

/////

/*
if (dir.x == 1 && pos -> x > next_vertex.x) nav -> path_ind++;
else if (dir.x == -1 && pos -> x < next_vertex.x) nav -> path_ind++;
else if (dir.y == 1 && pos -> y > next_vertex.y) nav -> path_ind++;
else if (dir.y == -1 && pos -> y < next_vertex.y) nav -> path_ind++;
*/

/////

// DEBUG(pos -> x - floor(pos -> x), lf);

/*
if (current_level.wall_data[(int) floor(pos -> y)][(int) floor(pos -> x)]) {
	printf("In a wall\n");
}
*/

/*
if (current_level.wall_data[(int) floor(pos -> y)][(int) floor(old_pos.x)]) {
	printf("Stop y\n");
	pos -> y = old_pos.y;
}

else if (current_level.wall_data[(int) floor(old_pos.y)][(int) floor(pos -> x)]) {
	printf("Stop x\n");
	pos -> x = old_pos.x;
}
*/

/////

printf("Pos x, y: %lf, %lf\n", pos -> x, pos -> y);
const VectorI trunc_pos = {pos -> x, pos -> y};

pos -> x = trunc_pos.x + 0.5 * dir.x;

/*
const VectorI trunc_pos = {pos -> x, pos -> y};
if (!doubles_eq(fabs(pos -> x - trunc_pos.x), 0.5))
	pos -> x = trunc_pos.x + 0.5 * dir.x;
*/

/*
const VectorI trunc_pos = {pos -> x, pos -> y};
if (!doubles_eq(pos -> x - trunc_pos.x, 0.5))
	pos -> x = trunc_pos.x + 0.5 * dir.x;
*/

/*
else if (!doubles_eq(pos -> y - trunc_pos.y, 0.5))
	pos -> y = trunc_pos.y + 0.5 * dir.y;
*/

/////

/*
int in_wall = 0;

if (current_level.wall_data[floor_pos.y][old_pos.x]) {
	printf("1\n");

	in_wall = 1;
}

if (current_level.wall_data[(int) floor(old_pos.y)][(int) floor(pos -> x)]) {
	printf("2\n");
	in_wall = 1;
}

if (!in_wall) {
	printf("3\n");
}
*/

/////

if (current_level.wall_data[floor_pos.y][floor_pos.x]) {
	printf("From %lf to ", pos -> x);
	pos -> x = floor_pos.x + -0.5 * dir.x;
	printf("%lf\n", pos -> x);
}

/*
int in_wall = 0;

if (current_level.wall_data[floor_pos.y][old_floor_pos.x]) {
	in_wall = 1;
	printf("1\n");
}

if (current_level.wall_data[old_floor_pos.y][floor_pos.x]) {
	in_wall = 1;
	printf("2\n");
}
*/

// if (!in_wall) printf("3\n");

/////

	const VectorF floor_pos = {floor(pos -> x), floor(pos -> y)};

	if (doubles_eq(old_pos.y, pos -> y)) {
		/*
		printf("Align x position to middle of square, from %lf to ", pos -> x);
		pos -> x = floor_pos.x + 0.5 * dir.x;
		printf("%lf\n", pos -> x);
		*/
	}
	else {
		printf("X position is fine\n");
	}

	/*	
	if (doubles_eq(old_pos.x, pos -> x)) {
		printf("1\n");
		// pos -> y = floor_pos.y + 0.5 * dir.y;
	}
	if (doubles_eq(old_pos.y, pos -> y)) {
		printf("2\n");
		pos -> x = floor_pos.x + 0.5 * dir.x;
	}
	*/
}

/////

// const VectorI old_floor_pos = {(int) floor(pos -> x), (int) floor(pos -> y)};

// printf("pos = {%lf, %lf}\n", pos -> x, pos -> y);

/////

const VectorF old_pos = {pos -> x, pos -> y};

/////

/*
DEBUG(on_wall, d);

if (on_wall) {
	if (walk_axis_y) {
		printf("Case 1\n");
	}

	if (walk_axis_x) {
		printf("Case 2\n");
	}
}
*/

/////

on_wall = current_level.wall_data[rounded_pos.y][rounded_pos.x];

/////

if (!walk_axis_y && !walk_axis_x) printf("Case 3\n");

/////

rounded_pos = VectorF_round(*pos);

/////