byte title_bar_shade = 0;

// reinitialized to scale to any possible new screen size
Message title = init_message("Dungeon Dave", 255, 140, 0, 0);
set_message_pos(&title, settings.half_screen_width - title.sprite.surface -> w / 2,
	title.sprite.surface -> h, title.sprite.surface -> w, title.sprite.surface -> h);

///

const int half_title_h = title.pos.h / 2;
const SDL_Rect darker_center_rect = {
	half_title_h, half_title_h,
	settings.screen_width - title.pos.h, settings.screen_height - title.pos.h
};

///

// draw_colored_rect(139, 0, 0, &darker_center_rect);

const int line_thickness = settings.screen_height / 100;
const SDL_Rect bar_under_title = {
	title.pos.x, title.pos.y + title.pos.h + line_thickness,
	title.pos.w, line_thickness
};

///

draw_colored_rect(255, 99 + title_bar_shade, 71 + title_bar_shade, &bar_under_title);
title_bar_shade++;

///

draw_message(title);
deinit_message(title);

/////

inlinable void print_path(const Path path) {
	for (int i = 0; i < path.length; i++) {
		const VectorI vertex = path.data[i];
		printf("{%d, %d}%s", vertex.x, vertex.y, i == path.length - 1 ? "\n" : ", ");
	}
}

inlinable const int paths_eq(const Path p1, const Path p2) {
	if (p1.length != p2.length) return 0;

	for (int i = 0; i < p1.length; i++) {
		if (!VectorI_eq(p1.data[i], p2.data[i])) return 0;
	}

	return 1;
}

/////

subtraction of floating-point and int-based vectors (not together): {a[0] - b[0], a[1] - b[1]}
distance squared: a[0] * a[0] + b[1] * b[1]
ray equation: {a[0] * d + p[0], a[1] * d + p[1]}
texture offset: {a[0] - floor(a[0]) * m, a[1] - floor(a[1]) * m}
unit step size: {fabs(1.0 / a[0]), fabs(1.0 / a[1])}
truncation: {(int) floor(a[0]), (int) floor(a[1])}
delta between floating-point and int-based vectors: {fabs(v[0] - i[0]), fabs(v[1] - i[1])}

handy functions: https://chryswoods.com/vector_c++/emmintrin.html

/////

/*
const __m128d delta = {
	billboard -> pos[0] - player.pos[0],
	billboard -> pos[1] - player.pos[1]
};
*/

/////

#define VectorF_floor__ mm_floor_pd
__m128i
__m64i

/////

/*
Uint32 surface_pixel = get_surface_pixel(surface -> pixels, surface -> pitch,
	surface_offset.x, surface_offset.y);

SDL_SetColorKey(surface, SDL_FALSE, 0xFF000000);

SDL_Color color;
SDL_GetRGB(surface_pixel, screen.pixel_format, &color.r, &color.g, &color.b);

const double shade = calculate_shade(settings.projection_distance / actual_dist);
surface_pixel = SDL_MapRGB(screen.pixel_format, color.r * shade, color.g * shade, color.b * shade);
*/

// pixel = 0xFF000000 | (210 << 16) | (180 << 8) | 140;

///// The old wall/floor shading snippet:

/*
SDL_Color color;
SDL_GetRGB(surface_pixel, screen.pixel_format, &color.r, &color.g, &color.b);

// there's no wall here (of course), but this is used for the shading calculation
const double shade = calculate_shade(settings.projection_distance / actual_dist);

// slow point:
surface_pixel = SDL_MapRGB(screen.pixel_format, color.r * shade, color.g * shade, color.b * shade);

for (int x = screen_x; x < screen_x + settings.ray_column_width; x++)
	*get_pixbuf_pixel(x, pace_y) = surface_pixel;
*/

/////

/*
.r = getbits(pixel, 8, 16),
.g = getbits(pixel, 16, 24),
.b = getbits(pixel, 24, 32)
*/

// 0, 0, 0, 0

/*
getbits(pixel, 16, 24),
getbits(pixel, 24, 32),
getbits(pixel, 8, 16)
*/

/*
getbits(pixel, 7, 15),
getbits(pixel, 15, 23),
getbits(pixel, 23, 31)
*/

///// Some old shading code (maybe, maybe not working):

/*
SDL_Color color;
SDL_GetRGB(surface_pixel, screen.pixel_format, &color.r, &color.g, &color.b);
// SDL_Color color = {5, 120, 5};
*/

// const SDL_Color color = color_from_ARGB_pixel(surface_pixel);

/*
const double shade = calculate_shade(settings.projection_distance / actual_dist);

surface_pixel =
	0xFF000000
	| ((int) (color.r * shade) << 16)
	| ((int) (color.g * shade) << 8)
	| (int) (color.b * shade);
*/

/////

/*
*pixel =
	  color.a << 24
	| color.r << 16
	| color.g << 8
	| color.b;
*/

/*
*pixel =
	0xFF000000
	| ((unsigned) (color.r * shade) << 16)
	| ((unsigned) (color.g * shade) << 8)
	| (unsigned) (color.b * shade);
*/

/*
*pixel =
	0xFF000000
	| color.r << 16
	| color.g << 8
	| color.b;
*/

/*
*pixel =
	color.b
	| color.g << 8
	| color.r << 16
	| 0xFF000000;
*/

/////

void shade_ARGB_pixel(Uint32* pixel, const double dist) {
	// const double shade = calculate_shade(settings.projection_distance / dist);

	const SDL_Color other = {
		.r = get_bits(*pixel, 16, 23),
		.g = get_bits(*pixel, 8, 15),
		.b = get_bits(*pixel, 0, 7)
	};

	/*
	const SDL_Color other = {
		get_bits(*pixel, 0, 7),
		get_bits(*pixel, 16, 23),
		get_bits(*pixel, 8, 15)
	};
	*/

	Uint8 r, g, b;
	SDL_GetRGB(*pixel, screen.pixel_format, &r, &g, &b);

	/*
	if (other.r != r || other.g != g || other.b != b) {
		printf("other vs official: {%d, %d, %d} <-> {%d, %d, %d}\n",
			other.r, other.g, other.b, r, g, b);
	}
	*/

	// *pixel = 0xFF000000 | (other.r << 16) | (other.g << 8) | other.b;
	*pixel = 0xFF000000 | (r << 16) | (g << 8) | b;

	// *pixel = SDL_MapRGB(screen.pixel_format, r, g, b);
	// *pixel = SDL_MapRGB(screen.pixel_format, other.r, other.g, other.b);
}

/////

/*
if (other.r != r || other.g != g || other.b != b) {
	printf("other vs official: {%d, %d, %d} <-> {%d, %d, %d}\n",
		other.r, other.g, other.b, r, g, b);
}
*/

/////

void shade_ARGB_pixel(Uint32* pixel, const double dist) {
	// const double shade = calculate_shade(settings.projection_distance / dist);

	const SDL_Color other = {
		.r = get_bits(*pixel, 16, 23),
		.g = get_bits(*pixel, 8, 15),
		.b = get_bits(*pixel, 0, 8)
	};

	/*
	const SDL_Color other = {
		get_bits(*pixel, 0, 7),
		get_bits(*pixel, 8, 15),
		get_bits(*pixel, 16, 23)
	};
	*/

	/*
	Uint8 r, g, b;
	SDL_GetRGB(*pixel, screen.pixel_format, &r, &g, &b);
	*/

	/////
	/*
	if (other.r != r) printf("R\n");
	if (other.g != g) printf("G\n");
	if (other.b != b) printf("B\n");
	*/
	/////


	// *pixel = 0xFF000000 | (r << 16) | (g << 8) | b;
	*pixel = 0xFF000000 | (other.r << 16) | (other.g << 8) | other.b;

/////

/*
const SDL_Color other = {
	.r = get_bits(*pixel, 16, 23),
	.g = get_bits(*pixel, 8, 15),
	.b = get_bits(*pixel, 0, 8)
};
*/

// *pixel = 0xFF000000 | (other.r << 16) | (other.g << 8) | other.b;

/////

/*
const double shade = calculate_shade(settings.projection_distance / dist);
*pixel = 0xFF000000
		| (((int) (r * shade)) << 16)
		| (((int) (g * shade)) << 8)
		| (int) (b * shade);
*/

/////

/*
const double shade = calculate_shade(settings.projection_distance / dist);
r *= shade;
g *= shade;
b *= shade;
*/

// const double shade = calculate_shade(settings.projection_distance / dist);

/////

/*
const __m128d hit = {
	dir[0] * actual_dist + pos[0],
	dir[1] * actual_dist + pos[1]
};
*/

/////

// {dir[0] * distance + pos[0], dir[1] * distance + pos[1]}};

/////