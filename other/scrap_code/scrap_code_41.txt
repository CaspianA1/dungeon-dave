// typedef unsigned char byte;

/////

/*
// const VectorI floored_pos = VectorF_floor(pos);
const VectorI floored_pos = {round(pos[0]), round(pos[1])};
if (floored_pos.x == 0 || floored_pos.x == 1) return 4;
*/

/////

/*
// if ((int) floor(pos[0]) % 2 == 0) {
// if (doubles_eq(pos[0], 1)) {
const double pos_0_minus_1 = pos[0] - 1.0;
if (pos_0_minus_1 < 0.01 && pos_0_minus_1 > 0.0) {
	DEBUG_VECF(pos);
	return 2;
	// return (int) pos[0] % 2 == 0;
}
*/

/////

const VectorI floored = VectorF_floor(pos), rounded = {round(pos[0]), round(pos[1])};

/*
if (rounded.x == 2 && rounded.y == 26) {
	printf("Yes\n");
	return 1;
}
*/


if (pos[0] <= 1.01) {
	// const double floored = floor(pos[1]);
	// if ((int) floor(pos[1]) % 2 == 0)
	// DEBUG(fmod(pos[1], 2.0), lf);
	DEBUG((int) floor(pos[1]) % 2, lf);
	// if ((int) trunc(pos[1]) % 2 == 0) return 2;

/////

// if (cell.x == 11 && cell.y == 22) return 2;
// if (cell.x == 3 && cell.y == 20) return 1;
// if (cell.x == 4 && cell.y == 20) return 1;

/////

/*
if (doubles_eq(pos[0], 3.0) && doubles_eq(pos[1], 20.0)) {
	return 1;
}
*/

/*
const VectorI cell = VectorF_floor(pos);

static const int codes[4] = {
	SDL_SCANCODE_1,
	SDL_SCANCODE_2,
	SDL_SCANCODE_3,
	SDL_SCANCODE_4
};

for (int i = 0; i < 4; i++) {
	if (keys[codes[i]]) {
		switch (i) {
			case 0: if (cell.x == 3 && cell.y == 20) return 1; break;
			case 1: if (cell.x == 2 && cell.y == 20) return 1; break;
			case 2: if (cell.x == 3 && cell.y == 21) return 1; break;
			case 3: if (cell.x == 3 && cell.y == 19) return 1; break;
		}
	}
}
*/

/////

/*
if (doubles_eq(pos[0], 11.0, 0.01) && doubles_eq(pos[1], 23.0, 0.01))
	return 2;
*/

/*
if (cell.x == 9 && cell.y == 21) return 2;
if (cell.x == 10 && cell.y == 21) return 2;
if (cell.x == 11 && cell.y == 23) return 2;
if (cell.x == 10 && cell.y == 23) return 2;
if (cell.x == 11 && cell.y == 21) return 2;
if (cell.x == 11 && cell.y == 22) return 2;
if (cell.x == 11 && cell.y == 23) return 2;
*/

/////

const VectorI cell = VectorF_floor(pos);

if (doubles_eq(pos[0], 3.0, 0.01) && doubles_eq(pos[1], 20.0, 0.01))
	return 1;

/*
if (pos[0] > 9.9 && pos[0] < 11.1 && pos[1] > 21.9 && pos[1] < 23.1)
	return 2;
*/

static const VectorF rx1 = {10.0, 11.0}, ry1 = {22.0, 23.0};
if (VectorF_in_range(pos[0], rx1) && VectorF_in_range(pos[1], ry1))
	return 2;

/////

inlinable byte VectorI_in_range(const double p, const VectorI range) {
	return p >= range.x - small_double_epsilon && p <= range.y + small_double_epsilon;
}

/////

/*
static const VectorF rx1 = {2.0, 3.0}, ry1 = {19.0, 20.0};
if (VectorF_in_range(pos[0], rx1) && VectorF_in_range(pos[1], ry1))
	return 1;
*/

/////

// static const VectorI test = {10, 22};

/////

spire_top = {5, 9};

else if (VectorI_in_cell(pos, spire_top))
	return 4;

/////

Billboard* ganesha = &current_level.billboards[0];


const double v = 0.05;
if (keys[SDL_SCANCODE_1]) ganesha -> pos[0] += v;
if (keys[SDL_SCANCODE_2]) ganesha -> pos[0] -= v;
if (keys[SDL_SCANCODE_3]) ganesha -> pos[1] += v;
if (keys[SDL_SCANCODE_4]) ganesha -> pos[1] -= v;
if (keys[SDL_SCANCODE_5]) ganesha -> height += v;
if (keys[SDL_SCANCODE_6]) ganesha -> height -= v;
if (keys[SDL_SCANCODE_7]) ganesha -> pos = player.pos, ganesha -> height = player.jump.height;
// DEBUG(player.jump.height, lf);
printf("{%lf, %lf, %lf}\n", ganesha -> pos[0], ganesha -> pos[1], ganesha -> height);

/////

inlinable double align_navigator_axis(const double axis_val) {
	return floor(axis_val) + 0.5;
}

// if the current and next vertex are right, the destination code can be wrong

// printf("pos = {%lf, %lf}\n", (*pos)[0], (*pos)[1]);


/*
(*pos)[0] = align_navigator_axis((*pos)[0]);
(*pos)[1] = align_navigator_axis((*pos)[1]);
*/

/////

/*
Player* cast = (Player*) untyped_player;
floor_ceiling_cast(*cast);
*/

/////

/*
pthread_t floor_drawing;
pthread_create(&floor_drawing, NULL, threaded_floor_ceiling_cast, NULL);
pthread_join(floor_drawing, NULL);
*/

/////

/*
typedef enum {
	BeginFloorCast, CurrentlyFloorCasting,
	WaitNextFloorCast, EndFloorCast
} FloorCastState;
*/

/*
FloorCastState thread_floorcast_state = WaitNextFloorCast;

void* threaded_floorcast(void* untyped_player) {
	while (thread_floorcast_state != EndFloorCast) {
		// printf("Going, not the end\n");
		if (thread_floorcast_state == BeginFloorCast) {
			printf("Begin\n");
			thread_floorcast_state = CurrentlyFloorCasting;
			floorcast(*(Player*) untyped_player);
			thread_floorcast_state = WaitNextFloorCast;
		}
	}
	printf("The end\n");
	return NULL;
}

pthread_t init_floor_drawing_thread(Player* player) {
	pthread_t floor_drawing_thread;
	pthread_create(&floor_drawing_thread, NULL, threaded_floorcast, player);
	return floor_drawing_thread;
}
*/

/////

/*
Player player = {
	.pos = {current_level.init_x, current_level.init_y},

	.angle = 0.0, .z_pitch = 0,

	// 4.8 and 8.0
	.jump = {.jumping = 0, .up_v0 = 4.8, .v0 = 0.0,
			.height = 0.0, .start_height = 0.0, 
			.highest_height = 0, .time_at_jump = 0.0},

	.tilt = {.val = 0.0, .step = 0.3, .max = 8.0},

	.pace = {.domain = {.val = 0.0, .step = 0.1,
		.max = settings.screen_height / settings.pace_max_divisor},
		.offset_scaler = 15, .screen_offset = 0},

	.body = {.moving_forward_or_backward = 0, .was_forward = 0, .was_backward = 0,
			.v = 0.0, .max_v_reached = 0.0, .a = 0.08, .limit_v = 0.06, .strafe_v = 0.04,
			.time_of_move = 0, .time_of_stop = 0, .v_incr_multiplier = 1.5},

	.mouse_pos = {.x = 0, .y = 0}
};
*/

/////

/*
#include "dungeon_dave.h"
#include "../combat/combat.h"

#include "utils.c"
#include "settings.c"
*/

/////

/*
struct Skybox;
struct Weapon;
struct Navigator;
struct Level;

void init_screen(void);
inlinable struct Weapon init_weapon(const char*, const char*, const int, const int, const int, const int);
inlinable struct Navigator init_navigator(const VectorF, const int, const double);
*/

/////

// level_1.shading_degree = 3.0;
// debug_level.shading_degree = 2.8;

/////

/*
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <pthread.h>

#include "../audio_visual/overlay/overlay.h"
#include "dungeon_dave.h"
#include "../combat/combat.h"

#include "utils.c"
#include "settings.c"
#include "input.c"
#include "screen.c"

#include "../audio_visual/overlay/sprite.c"
#include "../audio_visual/overlay/animation.c"
#include "../audio_visual/overlay/render_overlay.c"

#include "../combat/bfs_types.c"
#include "../combat/bfs.c"
#include "../combat/navigator.c"
#include "../combat/enemy.c"

#include "../audio_visual/sound.c"
#include "../audio_visual/raycasting/floor_and_ceiling.c"
#include "../audio_visual/raycasting/floor_and_ceiling_2.c"
#include "../audio_visual/raycasting/final_floor_and_ceiling.c"
#include "../audio_visual/raycasting/render.c"
#include "../audio_visual/raycasting/render_2.c"

#include "../combat/weapon.c"
#include "gui.c"
#include "level.c"
#include "level_data.c"
*/

/////

/*
load_default_settings();
init_screen();
load_level_1, load_debug_level, load_temple_level;

Player player = load_player(4.8, 0.3, 8.0, 0.1, 15.0, 0.08, 0.06, 0.04, 1.5);

Weapon weapon = init_weapon(
	"../assets/audio/shotgun.wav",
	"../assets/spritesheets/weapons/snazzy_shotgun.bmp", 6, 10, 59, 30);

Navigator nav = init_navigator(player.pos, 0, 0.04);
*/

/////

if (jump -> jumping) {
	const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;

	// y = y0 + v0t + 0.5at^2
	jump -> height = jump -> start_height + ((jump -> v0 * t)
					+ (0.5 * g * (t * t)));

	if (jump -> height > jump -> highest_height)
		jump -> highest_height = jump -> height;

	/*
	DEBUG(jump -> height, lf);
	double height_diff = jump -> height - wall_point_height;
	DEBUG(height_diff, lf);
	*/

	if (jump -> height < wall_point_height) {
		if (jump -> highest_height > wall_point_height && (jump -> v0 + g * t) < 0.0) {
			jump -> jumping = 0;
			jump -> start_height = wall_point_height;
			jump -> height = wall_point_height;

			// for big jumps only
			if (jump -> highest_height - wall_point_height > 2.0)
				play_sound(jump -> sound_at_land);

			jump -> highest_height = jump -> height + 0.001;
		}
		// else if (jump -> height < -0.01) {
		else {
			// printf("Illegal jump\n");
			/*
			jump -> jumping = 0;
			jump -> start_height = wall_point_height;
			jump -> height = wall_point_height;
			*/
		}
	}

/////

void foo(void) {
	// Enemy enemy = {.animations.idle = init_animation("", 0, 0, 0, 0)};
}

/////