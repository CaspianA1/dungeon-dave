/*
float width_ratio = (float) map_width / (screen_width - 1),
	height_ratio = (float) map_height / (screen_height - 1);

for (float x = 0; x < map_width; x += width_ratio) {
	int scaled_x = x * screen_width;
	for (float y = 0; y < map_height; y += height_ratio) {
		int scaled_y = y * screen_height;
		SET_COLOR(255, 0, 0);
		DRAW_POINT(scaled_x, scaled_y);
	}
}	
*/

/*
float rad_f = can * M_PI / 180;
float x = cos(rad_f) * 10 + dave.x;
float y = sin(rad_f) * 10 + dave.y;

SDL_RenderDrawLine(renderer, x, y, x + 10, y + 10);
*/

/*
for (float f = cam.angle - half_fov; f < cam.angle + half_fov; f += 0.1) {
	float rad_f = f * M_PI / 180;

	float x = cos(rad_f) * 10;
	float y = sin(rad_f) * 10;

	SDL_RenderDrawLine(renderer, x + dave.x, y + dave.y, x + 10 + dave.x, y + 10 + dave.y);

	// int x = cos(f * M_PI / 180);
	// printf("%d\n", x);
}
*/

/*
float rad_angle = dave.camera.angle * M_PI / 180;
SDL_RenderDrawLine(renderer, up_x, up_y, cos(rad_angle), 0);
*/

/*
case SDLK_LEFT: if (dave -> x > 0) dave -> x -= 0.1 * sin_theta; break;
case SDLK_RIGHT: if (dave -> x < map_width) dave -> x += 0.1 * sin_theta; break;
case SDLK_UP: if (dave -> y > 0) dave -> y -= 0.1 * cos_theta; break;
case SDLK_DOWN: if (dave -> y < map_height) dave -> y += 0.1 * cos_theta; break;
case 'a': dave -> camera.angle -= 0.1; break;
case 's': dave -> camera.angle += 0.1; break;
*/

/*
int in_bounds(float x, float y) {
	return x > 0 && x < map_width && y > 0 && y < map_height;
}

void handle_movement(int input, Player* dave) {
	if (in_bounds(dave -> x, dave -> y)) {
		float radian_angle = dave -> camera.angle * (M_PI / 180);
		float move_x = cos(radian_angle) * 0.1, move_y = sin(radian_angle) * 0.1;

		switch (input) {
			case SDLK_UP: dave -> x += move_x, dave -> y += move_y; break;
			case SDLK_DOWN: dave -> x -= move_x, dave -> y -= move_y; break;
			case SDLK_LEFT: dave -> camera.angle -= 5; break;
			case SDLK_RIGHT: dave -> camera.angle += 5; break;
		}
	}
}
*/

int distance_between(int x0, int y0, int x1, int y1) {
	return sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2));
}

/*
int rounded_y = round(dave.y), rounded_x = round(dave.x);
float y_diff = fabs(rounded_y - dave.y), x_diff = fabs(rounded_x - dave.x);

int sx = (dave.x * width_ratio);
printf("sx = %d\n", sx);

if (y_diff < 0.2 || x_diff < 0.2) {
	printf("y_diff = %f, x_diff = %f\n", y_diff, x_diff);
	printf("rounded_y = %d, rounded_x = %d\n", rounded_y, rounded_x);
	if (map[rounded_y][rounded_x])
		printf("Collision!\n");
	if (map[rounded_y][rounded_x]) {
		dave.y = rounded_y, dave.x = rounded_x;
	}
}
*/

// int height_gap = dist_to_wall;
// int 

// SDL_Rect hline = {hline_x, dist_to_wall, width_fov_ratio, screen_height - dist_to_wall * 2};
// SDL_RenderFillRect(renderer, &hline);
// SDL_RenderDrawRect(renderer, &hline);

/*
SDL_RenderDrawLine(renderer,
	hline_x, dist_to_wall * 2, hline_x, screen_height - dist_to_wall * 2);
*/

const int
	screen_width = 600, screen_height = 300,
	map_width = 10, map_height = 6;

/*
r.x = vline_x;
r.y = dist_to_wall;
r.w = width_fov_ratio,
r.h = screen_height - dist_to_wall * 2;
*/

int r = (map_point >> 5) * 32,
	g = ((map_point & 28) >> 2) * 32,
	b = (map_point & 3) * 64;

/////

/*
sprite.scale.x = vline_x;
sprite.scale.y = screen_height - dist_wall;
printf("dist_wall = %f\n", dist_wall);
printf("y = %d\n", sprite.scale.y);
*/

// float avg_x_y = (sprite.scale.x + sprite.scale.y) / 2;

/*
sprite.scale.w *= (float) 1 / dist_wall;
sprite.scale.h = screen_height - double_dist_wall;
*/

/*
float w_to_dist = (double) ((sprite.scale.w + sprite.scale.h) / 2) / ((double) dist_wall * 5);
sprite.scale.w *= dist_wall;
sprite.scale.h *= dist_wall;
*/

/////

// modify as necessary

/*
int sprite_w = sprite -> surface -> w, sprite_h = sprite -> surface -> h;

sprite -> scale.x = x;
sprite -> scale.y = screen_height - y_scale - sprite_h;

float expansion = sprite_w / y_scale;
printf("Expansion = %f\n", expansion);
sprite -> scale.w *= expansion, sprite -> scale.h *= expansion;
*/

/////

/*
if (scan.scanning) {
	int x_midpoint = (scan.begin_x + scan.end_x / 2);
	int avg_wall_dist = (scan.begin_dist + scan.end_dist) / 2;
	if (scale_sprite(&sprite, x_midpoint, avg_wall_dist))
		render_sprite(sprite);
}
*/

/////

/*
printf("map_point = %d\n", map_point);

for (int i = 0; i < sprite_count; i++) {
	SpriteScan* scan = &sprite_scans[i];
	if (!scan -> scanning)
		scan -> begin_x = vline_x,
		scan -> scanning = 1,
		scan -> begin_dist = dist_wall;
	else
		scan -> end_x = vline_x,
		scan -> end_dist = dist_wall;
}
*/

/////

/*
{1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
{1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
{1, 0, 5, 0, 0, 0, 0, 6, 0, 1},
{1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
{1, 0, 0, 0, 7, 0, 0, 0, 0, 1},
{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
*/

/////

if (keys[SDL_SCANCODE_UP]) dave.y -= 0.1;
if (keys[SDL_SCANCODE_DOWN]) dave.y += 0.1;
if (keys[SDL_SCANCODE_LEFT]) dave.x -= 0.1;
if (keys[SDL_SCANCODE_RIGHT]) dave.x += 0.1;

/////

/*
case SDLK_UP: dave.x += move_x, dave.y += move_y; break;
case SDLK_DOWN: dave.x -= move_x, dave.y -= move_y; break;
case SDLK_LEFT: dave.camera.angle -= 3; break;
case SDLK_RIGHT: dave.camera.angle += 3; break;
*/

/////

/*
SDL_Event event;
while (SDL_PollEvent(&event)) {
	switch (event.type) {
		case SDL_QUIT:
			SDL_DestroyWindow(window_3D);
			SDL_DestroyRenderer(renderer_3D);
			for (int i = 0; i < sprite_count; i++)
				free_sprite(sprites[i]);
			#ifdef WITH_2D
			SDL_DestroyWindow(window_2D);
			SDL_DestroyRenderer(renderer_2D);
			#endif
			return 0;
		case SDL_KEYDOWN: {
			float radian_angle = dave.camera.angle * (M_PI / 180);
			float move_x = cos(radian_angle) * 0.1, move_y = sin(radian_angle) * 0.1;
			switch (event.key.keysym.sym) {
				case SDLK_UP: dave.x += move_x, dave.y += move_y; break;
				case SDLK_DOWN: dave.x -= move_x, dave.y -= move_y; break;
				case SDLK_LEFT: dave.camera.angle -= 3; break;
				case SDLK_RIGHT: dave.camera.angle += 3; break;
			}
			if (dave.x < 0) dave.x = 0;
			else if (dave.x > screen_width) dave.x = screen_width;

			if (dave.y < 0) dave.y = 0;
			else if (dave.y > screen_height) dave.y = screen_height;

			if (map[(int) round(dave.y)][(int) round(dave.x)])
				dave.y = dave.prev_y, dave.x = dave.prev_x;

			if (dave.camera.angle > 360) dave.camera.angle = 0;
			else if (dave.camera.angle < 0) dave.camera.angle = 360;
		}
	}
}
*/

/////

// sprite -> scale.x = x - sprite_w;
sprite -> scale.x = x;
// sprite -> scale.y = screen_height / 2 - sprite_h / 4;
sprite -> scale.y = screen_height / 2;

/////

// float fattener = (float) (((screen_width + screen_height) / 2) / wall_dist);
float fattener = 100 / wall_dist;
sprite -> scale.w *= fattener;
sprite -> scale.h *= fattener;

sprite -> scale.x = x - sprite -> scale.w / 2;

// float min_size = (sprite_w + sprite_h) * 1.2;
// float min_size = sprite_h
// return (sprite -> scale.w + sprite -> scale.h) > min_size;
return 1;

/////

/*
sprite.scale.x = scan.begin_x;
sprite.scale.y = scan.begin_dist;
sprite.scale.w = width_fov_ratio * sprite.scale.w;
sprite.scale.h = (screen_height - scan.end_dist * 2);
render_sprite(sprite);
*/

/////

/*
float avg_dist = (scan.begin_dist + scan.end_dist) / 2;
sprite.scale.y = screen_height - avg_dist * 2;

if (sprite.scale.y + sprite.scale.h / 2 > screen_height)
	sprite.scale.y = screen_height - sprite.scale.h / 2;
render_sprite(sprite);
*/

/*
sprite.scale.x = (scan.begin_x + scan.end_x) / 2;
sprite.scale.y = screen_height / 2;

render_sprite(sprite);
*/

/*
printf("scale x = %d\n", sprite.scale.x);
if (sprite.scale.x > screen_width - sprite.scale.w)
	sprite.scale.x += sprite.scale.w;

float avg_dist = (scan.begin_dist + scan.end_dist) / 2;

sprite.scale.y = screen_height - avg_dist;

render_sprite(sprite);
*/

/*
int x_midpoint = (scan.begin_x + scan.end_x) / 2;
float avg_wall_dist = (scan.begin_dist + scan.end_dist) / 2;
if (scale_sprite(&sprite, x_midpoint, avg_wall_dist))
	render_sprite(sprite);
*/

/////

typedef struct {
	int scanning, begin_x, end_x;
	float begin_dist, end_dist;
} SpriteScan;

SpriteScan sprite_scans[sprite_count];
for (int i = 0; i < sprite_count; i++)
	sprite_scans[i].scanning = 0;


	/*
	printf("half sprite surface w = %f\n", (float) sprite.surface -> w / 2);
	printf("width_fov_ratio = %f\n---\n", width_fov_ratio);
	*/

	/*
	printf("vline_x = %f\n", vline_x);

	// SDL_Rect crop = {0, 0, sprite.surface -> w / 2, sprite.surface -> h};
	SDL_Rect crop = {vline_x, 0, width_fov_ratio / 2, sprite.surface -> h};
	SDL_RenderCopy(renderer_3D, sprite.texture, &crop, &sprite.scale);
	*/

	/*
	SpriteScan* scan = &sprite_scans[map_point - 5];
	if (!scan -> scanning)
		scan -> scanning = 1,
		scan -> begin_x = vline_x,
		scan -> begin_dist = dist_wall;
	else
		scan -> end_x = vline_x,
		scan -> end_dist = dist_wall;
	*/

	/*
	for (int i = 0; i < sprite_count; i++) {
		SpriteScan scan = sprite_scans[i];
		Sprite sprite = sprites[i];
		if (scan.scanning) {
			printf("begin x = %d, end x = %d\n", scan.begin_x, scan.end_x);

			int sprite_x = (scan.begin_x + scan.end_x) / 2;

			if (scan.begin_x == 0) sprite_x -= sprite.scale.w * 2;
			else if (scan.end_x == 0) {}

			sprite.scale.x = sprite_x;
			sprite.scale.y = screen_height / 2;

			float dist_diff = (scan.end_dist - scan.begin_dist) / 2;
			printf("dist_diff = %f\n", dist_diff);

			render_sprite(sprite);
		}
	}
	*/

/////

// SDL_RenderDrawRect(renderer_3D, &vline);

/*
Sprite sprite = sprites[map_point - 5];
// get a thin slice of the sprite data

int x = vline_x,
	// y = dist_wall,
	y = 0,
	w = width_fov_ratio / 2,
	// h = screen_height - double_dist_wall;
	h = sprite.surface -> h;

SDL_Rect crop = {x, y, w, h};
SDL_RenderCopy(renderer_3D, sprite.texture, &crop, &sprite.scale);
*/

/////

/*
SDL_Rect vline = {
	vline_x, dist_wall * 2,
	(width_fov_ratio + 1),
	screen_height - twice_dist_wall * 2
};
*/

/*
SDL_Rect vline = {
	vline_x, dist_wall, width_fov_ratio / 2, sprite.surface -> h
};
*/

/*
ideal:
x = 8, y = 93, width = 4, height = 32
working (but squashed):

*/

float fattener = 200 / dist_wall;
sprite.scale.w *= fattener;
sprite.scale.h *= fattener;

sprite.scale.x = vline_x;

SDL_Rect vline = {
	vline_x, dist_wall, 20, screen_height
};

// see if I can get a sprite drawn

// printf("x = %d, y = %d, width = %d, height = %d\n---\n", vline.x, vline.y, vline.w, vline.h);

SDL_RenderCopy(renderer_3D, sprite.texture, &vline, &sprite.scale);

/////

int scale_sprite(Sprite* sprite, int x, float wall_dist) {
	float fattener = 100 / wall_dist;
	sprite -> scale.w *= fattener;
	sprite -> scale.h *= fattener;
	sprite -> scale.x = x - sprite -> scale.w / 2;

	float avg_sprite_dim = (sprite -> scale.w + sprite -> scale.h) / 2;
	return avg_sprite_dim > avg_scr_dim / 15;
}

void render_sprite(Sprite sprite) {
	SDL_RenderCopy(renderer_3D, sprite.texture, NULL, &sprite.scale);
}

/////

/*
Sprite* sprite = &sprites[map_point - 5];
int surface_w = sprite -> surface -> w;
float width_slice = (1.0 / surface_w) * screen_width;
printf("width slice = %f\n", width_slice);
// sprite is 32 by 32
// screen width is 1000
SDL_Rect slice = {
	0,
	0,
	width_slice,
	sprite -> surface -> h
};
SDL_RenderCopy(renderer_3D, sprite -> texture, &slice, &sprite -> scale);
sprite -> scanline += width_fov_ratio;
printf("scanline = %f\n", sprite -> scanline);
*/

/////

This is a basic working example:

Sprite sprite = sprites[map_point - 5];

SDL_Rect scaled = {
	sprite.scale.x, sprite.scale.y,
	sprite.scale.w, sprite.scale.h
};

SDL_RenderCopy(renderer_3D, sprite.texture, NULL, &scaled);

/////


float vline_progression = (vline_x / (float) screen_width);
float sprite_center = vline_progression * sprite -> surface -> w;
// fix sprite following on the left side

/////

// sqrt(pow(new_x - rel_x, 2) + pow(new_y - rel_y, 2)) * distort_adjust;

/////

// draw indicators for the top and bottom of rectangles
SET_COLOR(renderer_3D, 0, 0, 0);

/*
// draw vertical lines
int line_len = vline_x + width_fov_ratio;
SDL_RenderDrawLine(renderer_3D,
	vline_x, dist_wall, line_len, dist_wall);
SDL_RenderDrawLine(renderer_3D,
	vline_x, screen_height - dist_wall, line_len, screen_height - dist_wall);
*/

/////

Uint32 before = SDL_GetTicks();

Uint32 after = SDL_GetTicks();
float secondsElapsed = (after - before) / 1000.0f;
printf("%f\n", 1.0f / secondsElapsed);

/*
clock_t after = clock();
printf("delta = %lu\n", after - before);
printf("per sec is called %d\n", CLOCKS_PER_SEC);

double a = (after - before) / (double) CLOCKS_PER_SEC;
printf("%f\n", 1.0 / a);
*/

/*
clock_t delta = (double) (clock() - before) / CLOCKS_PER_SEC;
printf("%lu\n", delta);
*/

/////

avg_scr_dim = (screen_width + screen_height) / 2;

/////

// if (two_dist_wall >= screen_height || dist_wall >= MAX_RAY_LEN) break;

/////

// Animation a = load_animation("assets/carrot_frames.bmp", 12, 3, 5);

/////

/*
float h_diff = new_x - (int) new_x, v_diff = new_y - (int) new_y;
if (h_diff > v_diff) {
	printf("Horizontal boundary\n");
	offset = (int) new_x % 128;
}
else {
	printf("Vertical boundary\n");
	offset = (int) new_y % 128;
}
*/

/////

/*
SDL_Rect the_sliced = {texture_x, 0, width_fov_ratio + 1, wall.scale.h};
SDL_Rect the_scaled = {vline_x, dist_wall, width_fov_ratio + 1, screen_height - 2 * dist_wall};
SDL_RenderCopy(renderer_3D, wall.texture, &the_sliced, &the_scaled);
texture_x++;
break;
*/

/////

/*
draw_colored_wall(map_point, width_fov_ratio, dist_wall, vline_x);
break; // for seethrough walls, don't include the break
*/

/////


/*
if (!(x_state ^ y_state)) {
	printf("Both\n");
}
*/

/*
float diff_x = map_x - i_map_x;
printf("diff_x = %f\n", diff_x);
int coord = ((diff_x <= 0.02 || diff_x >= 0.98) ? new_y : new_x);
int offset = coord % wall.scale.w;
*/

/*
float diff_x = map_x - i_map_x,
	diff_y = map_y - i_map_y;

int x_state = diff_x <= 0.02 || diff_x >= 0.98,
	y_state = diff_y <= 0.02 || diff_y >= 0.98;

if (x_state && y_state) // corner
	printf("Both met: %f, %f\n", map_x, map_y);
else if (x_state)
	printf("Only x met: %f\n", map_x);
else if (y_state)
	printf("Only y met: %f\n", map_y);
*/

/////

float w_to_h = (float) screen_width / screen_height;

/*
int sprite_w = width == -1 ? surface -> w * w_to_h : width;
int sprite_h = height == -1 ? surface -> h * w_to_h : height;
*/


int sprite_w = surface -> w,
	sprite_h = surface -> h;

/*
int sprite_w = surface -> w * w_to_h,
	sprite_h = surface -> h * w_to_h;
*/

/////

/*
int col_ind = (row_ind * animation.frame_count) - (frame_num + 1);
int col_ind = animation.per_row - (animation.frame_count / frame_num);
*/

/*
int count = 0;
SDL_Surface* dims = animation.spritesheet.surface;
for (int x = 1; x < animation.per_row; x++) {
	for (int y = 1; y < animation.per_col; y++) {
		if (count == frame_ind - 1) {
			printf("Got it: x is %d, y is %d.\n", x, y);

			int width = dims -> w / animation.per_row,
				height = dims -> h / animation.per_col;

			int sx = dims -> w / x,
				sy = dims -> h / y;

			printf("sx = %d, sy = %d, width = %d, height = %d\n", sx, sy, width, height);

			SDL_Rect sliced = {sx, sy, width, height};
			SDL_RenderCopy(renderer_3D, animation.spritesheet.texture, &sliced, NULL);
		}
		count++;
	}
}
*/

/*
Animation load_animation(const char* path, int frame_count, int rows, int cols) {
	Animation a = {frame_count, ANIMATION_FPS};

	SDL_Surface* surface = SDL_LoadBMP(path);
	SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer_3D, surface);

	int frame_width = surface -> w / rows,
		frame_height = surface -> h / cols;

	// convert from a frame index into a selective crop of texture, if possible

	for (int x = 0; x < surface -> w; x += frame_width) {
		for (int y = 0; y < surface -> h; y += frame_height) {
			// crop from x to step
		}
	}
	return a;
}
*/

/////