#ifdef __clang__
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#else
#include <SDL.h>
#include <SDL_ttf.h>
#include <immintrin.h>
#include <limits.h>
#include <time.h>
#include <assert.h>
#endif

/////

// if (keys[SDL_SCANCODE_T]) jump -> jumping = 0, jump -> height = 0;

/////

/*
printf("From %lf to ", *p_height);
const double old_ratio = *p_height / old_screen_height; // this is 1
*p_height = old_ratio * settings.screen_height;
printf("%lf\n", *p_height);
*/

/////

/*
if (new_width != settings.screen_width || new_height != settings.screen_height) {
	const int old_height = settings.screen_height;

	settings.screen_width = new_width;
	settings.screen_height = new_height;

	settings.half_screen_width = settings.screen_width / 2;
	settings.half_screen_height = settings.screen_height / 2;

	// reset_projection_distance();
	screen.z_buffer = wrealloc(screen.z_buffer, settings.screen_width * sizeof(double));
	*pace_max = settings.screen_height / INIT_PACE_MAX_DIVISOR;

	const byte old_point_height = *p_height / old_height;
	DEBUG(old_point_height, d);
	*p_height = old_point_height * 

	init_buffers(new_width, new_height, 1);
}
*/

/////

/*
settings.screen_width = INIT_W;
settings.screen_height = INIT_H;
settings.fov = INIT_FOV;
settings.max_fov = INIT_MAX_FOV;
update_max_fps(INIT_MAX_FPS);
settings.ray_column_width = INIT_RAY_COL_W;
settings.minimap_scale = INIT_MINIMAP_SCALE;
settings.half_screen_width = settings.screen_width / 2;
settings.half_screen_height = settings.screen_height / 2;
reset_projection_distance();
srand(time(NULL));
keys = SDL_GetKeyboardState(NULL);
*/

/////

const int prev_mouse_x = mouse_pos -> x;
SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);

const double percent_delta_x =
	(double) (mouse_pos -> x - prev_mouse_x) / settings.screen_width;

/*
DEBUG(percent_delta_x, lf);

int sign;
if (percent_delta_x > 0.0) sign = 1;
else if (percent_delta_x < 0.0) sign = -1;
else sign = 0;
*/

*theta += percent_delta_x * 360.0;
// *theta += sign;
DEBUG(*theta, lf);

if (mouse_pos -> x == settings.screen_width - 1)
	SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
else if (mouse_pos -> x == 0)
	SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);


/*
const double prev_theta = *theta;
*theta = ((double) mouse_pos -> x / settings.screen_width) * 360.0;
const double theta_v = fabs(to_radians(*theta - prev_theta));

if (mouse_pos -> x == settings.screen_width - 1)
	SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
else if (mouse_pos -> x == 0)
	SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
*/

const double prev_theta = 20, theta_v = 5;

/////

void update_theta_and_dir_and_plane(double* theta,
	VectorI* mouse_pos, VectorF* ref_dir, VectorF* ref_plane) {

	const int prev_mouse_x = mouse_pos -> x;
	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);
	const int mouse_delta_x = mouse_pos -> x - prev_mouse_x;

	const double percent_delta_x = (double) mouse_delta_x / settings.screen_width;

	const double prev_theta = *theta;

	/*
	int sign;
	if (mouse_delta_x < 0)
		sign = -1;
	else if (mouse_delta_x > 0)
		sign = 1;
	else
		sign = 0;
	*theta += sign;
	double theta_v = percent_delta_x * 0.05;
	*/

	*theta += percent_delta_x * 360.0;

	// DEBUG(theta_v, lf);

	// *theta += percent_delta_x * 360.0;
	// const double delta_rad_theta = fabs(to_radians(*theta - prev_theta));

	if (mouse_pos -> x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);

	VectorF dir = *ref_dir, plane = *ref_plane;

	double
		old_dir_x = dir[0], old_plane_x = plane[0],
		// cos_theta_v = cos(delta_rad_theta), sin_theta_v = sin(delta_rad_theta);
		cos_theta_v = cos(theta_v), sin_theta_v = sin(theta_v);

	if (prev_theta > *theta) {
		printf("Case A\n");
		dir[0] = dir[0] * cos_theta_v - dir[1] * sin_theta_v;
		dir[1] = old_dir_x * sin_theta_v + dir[1] * cos_theta_v;
		plane[0] = plane[0] * cos_theta_v - plane[1] * sin_theta_v;
		plane[1] = old_plane_x * sin_theta_v + plane[1] * cos_theta_v;
	}

	else if (prev_theta < *theta) {
		printf("Case B\n");
		dir[0] = dir[0] * cos_theta_v + dir[1] * sin_theta_v;
		dir[1] = old_dir_x * -sin_theta_v + dir[1] * cos_theta_v;
		plane[0] = plane[0] * cos_theta_v + plane[1] * sin_theta_v;
		plane[1] = old_plane_x * -sin_theta_v + plane[1] * cos_theta_v;
	}

	*ref_dir = dir;
	*ref_plane = plane;
}

/////

horizon_line = settings.half_screen_height - y_change;

/////

/*
+ (((player.jump.height * settings.screen_height) - billboard.height)
	/ billboard.dist),
*/

/*
+ (billboard.height / billboard.dist)
+ (player.jump.height * settings.screen_height / billboard.dist),
*/
// + (player.jump.height - billboard.height) / billboard.dist,

/////

inlinable void update_projection_distance(void) {
	double avg_half_dimensions =
		(double) (settings.half_screen_width + settings.half_screen_height) / 2.0;
	settings.projection_distance = avg_half_dimensions / tan(to_radians(settings.fov / 2.0));
}

/////

// const double shade = wall_height / settings.screen_height * current_level.shading_degree;

/////

void update_theta_and_dir_and_plane(double* theta,
	VectorI* mouse_pos) {

	//////////
	const int prev_mouse_x = mouse_pos -> x;
	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);
	if (prev_mouse_x == mouse_pos -> x) return;

	const double
		prev_theta = *theta,
		delta_theta = (double) (mouse_pos -> x - prev_mouse_x)
						/ settings.screen_width * 360.0;

	DEBUG(delta_theta, lf);

	*theta += delta_theta;

	if (mouse_pos -> x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
	//////////

	// VectorF dir_c = *floor_dir, plane_c = *floor_plane; // _c = copy
	VectorF floor_dir = settings.floor_dir, floor_plane = settings.floor_plane;
	// double old_dir_x = dir_c[0], old_plane_x = plane_c[0];
	const double old_dir_x = floor_dir[0], old_plane_x = floor_plane[0];
	const double theta_v = fabs(to_radians(delta_theta));
	// DEBUG(delta_theta, lf);
	const double cos_theta_v = cos(theta_v), sin_theta_v = sin(theta_v);

	if (prev_theta > *theta) {
		// printf("Left\n");
		floor_dir[0] = floor_dir[0] * cos_theta_v - floor_dir[1] * sin_theta_v;
		floor_dir[1] = old_dir_x * sin_theta_v + floor_dir[1] * cos_theta_v;
		floor_plane[0] = floor_plane[0] * cos_theta_v - floor_plane[1] * sin_theta_v;
		floor_plane[1] = old_plane_x * sin_theta_v + floor_plane[1] * cos_theta_v;
	}

	else if (prev_theta < *theta) {
		// printf("Right\n");
		floor_dir[0] = floor_dir[0] * cos_theta_v + floor_dir[1] * sin_theta_v;
		floor_dir[1] = old_dir_x * -sin_theta_v + floor_dir[1] * cos_theta_v;
		floor_plane[0] = floor_plane[0] * cos_theta_v + floor_plane[1] * sin_theta_v;
		floor_plane[1] = old_plane_x * -sin_theta_v + floor_plane[1] * cos_theta_v;
	}

	/*
	*floor_dir = dir_c;
	*floor_plane = plane_c;
	*/

	settings.floor_dir = floor_dir;
	settings.floor_plane = floor_plane;
}

/////

/*
.floor_dir = {-1.0, 0.0},

.floor_plane = {0.0, 0.66},
*/

/////