/*
const int bottom_pace_range = screen_height - init_y - pace;
const int top_pace_range = wall_pos.y + pace;
const int real_bottom_range = end_y - init_y;

printf("---\n");
printf("bottom, top range: %d, %d\n", bottom_pace_range, top_pace_range);
printf("real bottom range, and top - bottom difference: %d, %d\n",
	real_bottom_range, top_pace_range - bottom_pace_range);
printf("bottom + top + height: %d\n", bottom_pace_range + top_pace_range + wall_height);
printf("---\n");
*/

/////

/*
const int screen_x, const int point,
const double dist, const double new_x, const double new_y,
const double cos_theta, const double sin_theta,
const double cos_beta, const double player_x, const double player_y,
const double pace, const double y_pitch) {
*/

/*
In player:
pos, pace, pitch

In cast_data:
screen_x
point
dist
new_x
new_y
cos_theta
sin_theta
cos_beta
*/

const int wall_height = screen.projection_distance / cast_data.dist;

const SDL_Rect wall_pos = {
	cast_data.screen_x,
	half_screen_height - wall_height / 2 + cast_data.y_pitch,
	1,
	wall_height
};

const int wall_bottom = wall_pos.y + wall_pos.h;
SDL_Rect pace_wall = wall_pos; pace_wall.y += cast_data.pace_offset;

if (cast_data.point <= plain_wall_count) {

	/*
	int r, g, b;
	switch (cast_data.point) {
		case 1: r = 255, g = 255, b = 0; break;
		case 2: r = 0, g = 128, b = 128; break;
		case 3: r = 255, g = 165, b = 0; break;
		case 4: r = 255, g = 0, b = 0; break;
	}

	const double shade = calculate_shade(wall_height);
	draw_rectangle(&pace_wall, r * shade, g * shade, b * shade);
	*/
}

else {
	const Sprite wall = textured_walls[cast_data.point - (wall_count - textured_wall_count + 1)];
	const int tex_w = wall.surface -> w, tex_h = wall.surface -> h;
	const double
		diff_x = cast_data.new_x - floor(cast_data.new_x),
		diff_y = cast_data.new_y - floor(cast_data.new_y);
	const int on_x = close_to_whole(diff_y), on_y = close_to_whole(diff_x);

	int offset;
	if (on_x ^ on_y)
		offset = on_x
			? (int) (diff_x * tex_w) & tex_w - 1
			: (int) (diff_y * tex_h) & tex_h - 1;
	else
		offset = tex_w - 1;

	render_scanline(wall_height, wall, offset, &pace_wall);
}

/////

/*
const int wall_height, const SDL_Rect wall_pos, const int pace_offset,
const double cos_theta, const double sin_theta, const double cos_beta,
const double player_x, const double player_y, const double y_pitch, const double screen_x) {
*/

// const int wall_bottom = wall_pos.y + wall_pos.h;


/////

/*
const Sprite sprite = textured_walls[4];
const SDL_Surface* surface = sprite.surface;
const SDL_PixelFormat* format = surface -> format;
const void* pixels = surface -> pixels;
const int
	surface_pitch = surface -> pitch,
	bytes_per_pixel = format -> BytesPerPixel,
	sprite_w = sprite.surface -> w,
	sprite_h = sprite.surface -> h,
	end_y = screen_height - cast_data.pace_offset;
*/

// printf("%s\n", SDL_GetPixelFormatName(format -> format));

/*
for (int y = wall_bottom; y < end_y; y++) {
	const double floor_row = y - half_screen_height - cast_data.y_pitch;
	const double floor_straight_distance = 0.5 / floor_row * screen.projection_distance;
	const double floor_actual_distance = floor_straight_distance / cast_data.cos_beta;

	const double 
		hit_x = cast_data.cos_theta * floor_actual_distance + cast_data.player_x,
		hit_y = cast_data.sin_theta * floor_actual_distance + cast_data.player_y;

	const int
		tex_x = (int) ((hit_x - floor(hit_x)) * sprite_w) & sprite_w - 1,
		tex_y = (int) ((hit_y - floor(hit_y)) * sprite_h) & sprite_h - 1;

	// there's no wall here (of course), but this is used for the shading calculation
	const double shade = calculate_shade(screen.projection_distance / floor_actual_distance);

	Uint32 surface_pixel = get_surface_pixel(pixels, surface_pitch, bytes_per_pixel, tex_x, tex_y);
	SDL_Color pixel;
	SDL_GetRGB(surface_pixel, format, &pixel.r, &pixel.g, &pixel.b);

	// SDL_MapRGB is really slow for some textures
	surface_pixel = SDL_MapRGB(format, pixel.r * shade, pixel.g * shade, pixel.b * shade);

	const int floor_y = y + cast_data.pace_offset;
	if (floor_y > 0) *get_pixbuf_pixel(cast_data.screen_x, floor_y) = surface_pixel;
}
*/

/////

void draw_ceiling_ground_floor(const CastData cast_data) {

	////////// floor casting


}

/////

/*
const CastData cast_data = {
	screen_x, point, dist, new_x, new_y, cos_theta, sin_theta, cos_beta,
	player.pos.x, player.pos.y, player.pace.screen_offset, player.y_pitch.pitch
};

draw_ceiling_ground_floor(cast_data);
*/

/*
draw_ceiling_ground_floor(screen_x, point, dist, new_x, new_y,
	cos_theta, sin_theta, cos_beta, player.pos.x, player.pos.y,
	player.pace.screen_offset, player.y_pitch.pitch);
*/

/////

/*
const char* textured_wall_paths[textured_wall_count] = {
	"assets/wolf/colorstone.bmp", "assets/walls/cobblestone.bmp",
	"assets/walls/grass.bmp", "assets/walls/dial.bmp", "assets/walls/trinity.bmp"
};

for (int i = 0; i < textured_wall_count; i++)
	textured_walls[i] = load_sprite(textured_wall_paths[i]);
*/

/*
const char* sprite_paths[sprite_count] = {
	"assets/static/robot.bmp",
	"assets/static/tomato.bmp",
	"assets/static/bogo.bmp",
	"assets/static/zombieman.bmp",
	"assets/static/doomguy.bmp",
	"assets/static/ness.bmp",
	"assets/static/donkeykong.bmp"
};

for (int i = 0; i < sprite_count; i++)
	sprites[i] = load_sprite(sprite_paths[i]);
*/

/*
for (int i = 0; i < sprite_count; i++) free_sprite(sprites[i]);
for (int i = 0; i < textured_wall_count; i++) free_sprite(textured_walls[i]);
*/

/////

static Sprite textured_walls[textured_wall_count], sprites[sprite_count];

/////

/*
const Sprite load_sprite(const char* path) {
	SDL_Surface* surface = SDL_LoadBMP(path);
	if (surface == NULL)
		FAIL("Could not load a sprite: %s\n", path);

	SDL_PixelFormat* correct_format = SDL_AllocFormat(PIXEL_FORMAT);
	// SDL_Surface* converted_surface = SDL_ConvertSurface(surface, correct_format, 0);

	printf("Bitmap format for %s: %s\n", path, SDL_GetPixelFormatName(surface -> format -> format));

	Sprite sprite = {surface, SDL_CreateTextureFromSurface(screen.renderer_3D, surface)};
	sprite.path = path;
	return sprite;
}
*/

/////

/*
inlinable void free_sprite(const Sprite sprite) {
	SDL_FreeSurface(sprite.surface);
	SDL_DestroyTexture(sprite.texture);
}
*

/////

/*
if (shade > 1.0) shade = 1.0;
return shade;
*/

/////

What works with SDL_PIXELFORMAT_ARGB8888:
	textured_walls 0 (eagle or colorstone), 3 (bluestone or dial)
	sprites 0 (robot), 1 (tomato), 2 (bogo)

What doesn't work with that format:
	textured_walls 1 (my cobblestone), 2 (grass, three for pixel type)
	sprites 3 (zombieman), 4 (doomguy), 5 (ness)

All that work are 64 by 64
Those that won't work are:
	- my cobblestone (128 x 128)
	- grass (256 x 256)
	- zombieguy (285 x 335)
	- doomguy (328 x 448)
	- ness (750 x 1200)

Why is this limited to only (64 x 64) sprites?

textured wall formats:
	0 -> SDL_PIXELFORMAT_BGR24
	1 -> SDL_PIXELFORMAT_INDEX8
	2 -> SDL_PIXELFORMAT_INDEX8
	3 -> SDL_PIXELFORMAT_ARGB8888
	4 -> SDL_PIXELFORMAT_ARGB8888

sprite formats:
	0 -> SDL_PIXELFORMAT_ARGB8888
	1 -> SDL_PIXELFORMAT_ARGB8888
	2 -> SDL_PIXELFORMAT_ARGB8888
	3 -> SDL_PIXELFORMAT_ARGB8888
	4 -> SDL_PIXELFORMAT_ARGB8888
	5 -> SDL_PIXELFORMAT_ARGB8888
	6 -> SDL_PIXELFORMAT_ARGB8888

After switching formats, these work:
	textured_walls 0, 1, 2, 3, 4
	sprites 0, 1, 2

/////

typedef struct {
	const int screen_x, point;
	const double
		dist, new_x, new_y, cos_theta, sin_theta,
		cos_beta, player_x, player_y, pace_offset, y_pitch;
} CastData;

/////

Here is the new handle_input function (which I later discarded in favor of the old one, as it was faster)

/*
const int handle_input(Player* player, const Uint8* keys) {
	const int
		up = keys[SDL_SCANCODE_UP],
		down = keys[SDL_SCANCODE_DOWN],
		left = keys[SDL_SCANCODE_LEFT],
		right = keys[SDL_SCANCODE_RIGHT],
		turn_left = keys[SDL_SCANCODE_A],
		turn_right = keys[SDL_SCANCODE_D],
		look_up = keys[SDL_SCANCODE_W],
		look_down = keys[SDL_SCANCODE_S];

	const int
		moved = up || down || left || right,
		x_turned = turn_left || turn_right,
		y_turned = look_up || look_down;

	if (!(moved || x_turned || y_turned)) return 0;

	double *angle = &player -> angle,
			*x = &player -> pos.x, *y = &player -> pos.y,
			*prev_x = &player -> prev_pos.x,
			*prev_y = &player -> prev_pos.y;

	const double rad_angle = to_radians(*angle);

	if (moved) {
		const double
			move_x = lookup_cos(rad_angle) * move_speed_decr,
			move_y = lookup_sin(rad_angle) * move_speed_decr;

		if (up) *x += move_x, *y += move_y;
		if (down) *x -= move_x, *y -= move_y;
		if (left) *x += move_y, *y -= move_x;
		if (right) *x -= move_y, *y += move_x;

		if (is_a_wall(map[(int) *y][(int) *x]))
			*x = *prev_x, *y = *prev_y;
	}

	if (x_turned) {
		if (turn_left) *angle -= angle_turn;
		if (turn_right) *angle += angle_turn;

		if (*angle <= 0) *angle = 359;
		else if (*angle >= 360) *angle = 1;
	}

	if (y_turned) {
		const double
		 	y_pitch_step = player -> y_pitch.pitch_step,
			y_pitch_max = player -> y_pitch.pitch_max;

		double* y_pitch = &player -> y_pitch.pitch;

		if (look_up && *y_pitch <= y_pitch_max) *y_pitch += y_pitch_step;
		if (look_down && -*y_pitch <= y_pitch_max) *y_pitch -= y_pitch_step;
	}

	if (*prev_x != *x || *prev_y != *y) {
		Pace* pace = &player -> pace;

		if ((pace -> x += pace -> step_x) > two_pi)
			pace -> x = 0;

		pace -> sin_x = lookup_sin(pace -> x);
		pace -> screen_offset = (pace -> sin_x) * (screen_height / pace -> offset_converter);
	}
	*prev_x = *x, *prev_y = *y;

	return 1;
}
*/

/////