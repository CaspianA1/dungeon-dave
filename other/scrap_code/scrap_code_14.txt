/*
if (*angle > 360) *angle = 0;
else if (*angle < 0) *angle = 360;
*/

if (moved && (*prev_x != *x || *prev_y != *y)) {
	Pace* pace = &player -> pace;
	pace -> height += pace -> step * (pace -> up * 2 - 1); // branchless
	if (pace -> height > pace -> bound || pace -> height < -pace -> bound)
		pace -> up = !pace -> up;
}

typedef struct {
	int up;
	double height;
	const double step, bound;
} Pace;

Pace pace;

const double pace_bound = screen_height / pace_bound_divisor;

Player player = {{5, 5}, {0, 0}, 0, {0, 0, pace_bound / pace_step_speed, pace_bound}};

pace_step_speed = pace_bound_divisor / 2.0,

pace_bound_divisor = 35,

/////

SDL_Rect player_dot = {player.pos.x * width_ratio, player.pos.y * height_ratio, 5, 5};
draw_rectangle(screen.renderer_2D, &player_dot, 255, 0, 0);

/////

/*
for (double scr_x = 0, map_x = 0; scr_x < screen_width; scr_x += width_ratio, map_x++) {
	for (double scr_y = 0, map_y = 0; scr_y < screen_height; scr_y += height_ratio, map_y++) {
		if (is_a_wall(map[(int) map_y][(int) map_x])) {
			wall.x = scr_x, wall.y = scr_y;
			draw_rectangle(screen.renderer_2D, &wall, 210, 180, 140);
		}
	}
}
*/

/////

// https://stackoverflow.com/questions/53033971/how-to-get-the-color-of-a-specific-pixel-from-sdl-surface
/*
tried that but it didn't work as the get_pixel32 function only supports 32bit pixels
and i figured out my surface had 8bit per pixel.
found another function to get the pixel data for multiple pixel sizes.
*/

/////

inlinable void draw_rectangle(SDL_Renderer* renderer, const SDL_Rect* rect,
								const int r, const int g, const int b) {

	SDL_SetRenderTarget(renderer, screen.shape_buffer);
	SDL_SetRenderDrawColor(renderer, r, g, b, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(renderer, rect);
	SDL_RenderDrawRect(renderer, rect);
}

/////

// SDL_SetRenderTarget(screen.renderer_3D, screen.shape_buffer);

/////

/*
void draw_rectangle(SDL_Renderer* renderer, const SDL_Rect* rect, const int r, const int g, const int b) {
	SET_COLOR(renderer, r, g, b);
	SDL_RenderFillRect(renderer, rect);
	SDL_RenderDrawRect(renderer, rect);
}
*/

/////

else if (!handle_input(&player, keys)) {
	while (player.pace.x != 0) {
		const Uint32 pace_before = SDL_GetTicks();
		prepare_for_drawing();
		progress_pace(&player.pace);
		// draw_sprites(player);
		raycast(player);
		refresh();

		const int wait = max_delay - (SDL_GetTicks() - pace_before);
		if (wait > 0) SDL_Delay(wait);
	}
	continue;
}

/////

/*
tex_coord = y_state
	? (int) (tex_w * x_diff) & tex_w - 1
	: (int) (tex_h * y_diff) & tex_h - 1;
*/

/////

/*
int tex_coord;
if (i_new_y == 0 || (map_height % i_new_y == 0)) tex_coord = tex_ind(new_x, wall.surface -> w);
else if (i_new_x == 0 || (map_width % i_new_x == 0)) tex_coord = tex_ind(new_y, wall.surface -> h);
else tex_coord = 5;

render_scanline(dist, wall, tex_coord, &wall_pos);
*/

// if (i_new_x == 0 || i_new_y == 0) printf("Yurr\n");

/*
if (map_width % (int) ceil(new_x) == 0) tex_coord = tex_ind(new_x, wall.surface -> w);
else if (map_height % (int) ceil(new_y) == 0) tex_coord = tex_ind(new_y, wall.surface -> h);
else printf("Other case\n");
*/

/*
const Sprite wall = textured_walls[point - (wall_count - textured_wall_count + 1)];
const double x_diff = new_x - (int) new_x, y_diff = new_y - (int) new_y;
const int x_state = close_to_whole(x_diff),
	y_state = close_to_whole(y_diff),
	tex_w = wall.surface -> w,
	tex_h = wall.surface -> h;
int tex_coord;
if (x_state ^ y_state)
	tex_coord = y_state ? tex_ind(new_x, tex_w) : tex_ind(new_y, tex_h);
else
	tex_coord = tex_w - 1;
render_scanline(dist, wall, tex_coord, &wall_pos);
*/

/////

/*
printf("Hit x and y: %f, %f\n", new_x, new_y);
printf("Fmod x with width: %f\n", fmod(map_width, new_x));
printf("Fmod y with height: %f\n---\n", fmod(map_height, new_y));
*/

/*
const int i_new_x = new_x, i_new_y = new_y;

if (new_x == 0 || new_y == 0) printf("Zeroah\n");

const int
	x_state = i_new_x == 0 || doubles_eq(fmod(map_width, new_x), 0),
	y_state = i_new_y == 0 || doubles_eq(fmod(map_height, new_y), 0);

int tex_coord;

if (x_state) tex_coord = tex_ind(new_x, wall.surface -> w);
else if (y_state) tex_coord = tex_ind(new_y, wall.surface -> h);
else tex_coord = 0;

render_scanline(dist, wall, tex_coord, &wall_pos);
*/

/////

const int
	x_state = close_to_whole(new_x - (int) new_x),
	y_state = close_to_whole(new_y - (int) new_y);

int tex_coord;
if (x_state ^ y_state)
	tex_coord = y_state
		? tex_ind(new_y, wall.surface -> h)
		: tex_ind(new_x, wall.surface -> w);
else
	printf("None\n"), tex_coord = 0;

render_scanline(dist, wall, tex_coord, &wall_pos);

/////

/*
const int
	tex_x = ((int) ((new_x - (int) new_x) * tex_w) & tex_w - 1) % tex_w,
	tex_y = ((int) ((new_y - (int) new_y) * tex_h) & tex_h - 1) % tex_h;
*/

const int tex_x = (new_x - (int) new_x) * tex_w;

printf("y is %d, x is %d\n", tex_y, tex_x);

int offset;
if (tex_y >= tex_h || tex_y <= 1) printf("X\n"), offset = tex_x;
else if (tex_x >= tex_w || tex_x <= 1) printf("Y\n"), offset = tex_y;
else printf("Else\n"), offset = tex_x - 1;

render_scanline(dist, wall, tex_x, &wall_pos);

// int texX = int(wallX * double(texWidth));

/////

// printf("---\nNew x and y: %lf, %lf\n", new_x, new_y);

/*
double diff_x = new_x - (int) new_x, diff_y = new_y - (int) new_y;
if (diff_x > 0.5) diff_x = 1 - diff_x;
if (diff_y > 0.5) diff_y = 1 - diff_y;
*/

// printf("Diff x and y: %lf, %lf\n", diff_x, diff_y);

/*
const int on_x = close_to_whole(diff_x), on_y = close_to_whole(diff_y);

int offset;
if (on_x ^ on_y)
	offset = on_y
		? (int) (diff_x * tex_w) & tex_w - 1
		: (int) (diff_y * tex_h) & tex_h - 1;
else {
	// printf("Both, because diff x and y were %lf, %lf\n", diff_x, diff_y);
	// offset = tex_w - 1;
}

render_scanline(dist, wall, offset, &wall_pos);
*/

/////

/*
int shade = 1020 / dist; // (255 * 4) / dist
if (shade > 255) shade = 255;
SDL_SetTextureColorMod(sprite.texture, shade, shade, shade);

const SDL_Rect slice = {tex_coord, 0, 1, sprite.surface -> h};
SDL_RenderCopy(screen.renderer_3D, sprite.texture, &slice, pos);
*/

/////

darkening = 10.0,

/////

const double color_decr = dist * darkening;
// shade(&r, color_decr), shade(&g, color_decr), shade(&b, color_decr);
draw_rectangle(&wall_pos, r, g, b);

/////

/*
const static int max = map_width * map_width + map_height * map_height;
const double shade = (dist * dist) / max;
DEBUG(shade, lf);
*/

/*
SDL_SetRenderTarget(screen.renderer_3D, screen.shape_buffer);
const int shade = 255 * calculate_shade(dist);
DEBUG(shade, d);
SDL_SetTextureColorMod(sprite.texture, shade, shade, shade);
const SDL_Rect slice = {tex_coord, 0, 1, sprite.surface -> h};
SDL_RenderCopy(screen.renderer_3D, sprite.texture, &slice, pos);
*/

/////

profile:
	$(CC) $(CFLAGS) -Ofast -fprofile-instr-generate $(LDFLAGS)
	sudo dtrace bin/$(OUT)

/////