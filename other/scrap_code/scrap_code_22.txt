/*
printf("For the sprite with path %s, its angle is %lf, and my angle is %lf"
	", meaning that beta is %lf\n",
	sprite -> path, atan2(delta.y, delta.y), player_angle, sprite -> beta);
*/

///// The old handle_input:

const int handle_input(Player* player, const Uint8* keys) {
	const int
		forward = keys[SDL_SCANCODE_W], backward = keys[SDL_SCANCODE_S],
		left_strafe = keys[SDL_SCANCODE_A], right_strafe = keys[SDL_SCANCODE_D];
	const int strafe = left_strafe || right_strafe;
	const int moved = forward || backward || strafe;

	//////////

	KinematicBody* kinematic_body = &player -> kinematic_body;
	kinematic_body -> moving = moved;
	if (moved) kinematic_body -> time_at_move = SDL_GetTicks();

	player -> kinematic_body.moving = moved;
	if (moved) player -> kinematic_body.time_at_move = SDL_GetTicks();

	//////////

	VectorI
		*mouse_pos = &player -> mouse_pos,
		*prev_mouse_pos = &player -> prev_mouse_pos;

	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);

	// if no movement or mouse position is the same
	if (!(moved || mouse_pos -> x != prev_mouse_pos -> x || mouse_pos -> y != prev_mouse_pos -> y))
		return 0;

	//////////

	int* angle = &player -> angle;
	int* y_pitch = &player -> y_pitch;

	const double rad_angle = to_radians(*angle);

	VectorF* pos = &player -> pos;
	const VectorF
		old_pos = {pos -> x, pos -> y},
		move = {cos(rad_angle) * move_speed_decr, sin(rad_angle) * move_speed_decr};

	if (forward) pos -> x += move.x, pos -> y += move.y;
	if (backward) pos -> x -= move.x, pos -> y -= move.y;
	if (left_strafe) pos -> x += move.y, pos -> y -= move.x;
	if (right_strafe) pos -> x -= move.y, pos -> y += move.x;

	if (is_a_wall(map[(int) old_pos.y][(int) pos -> x])) pos -> x = old_pos.x;
	if (is_a_wall(map[(int) pos -> y][(int) old_pos.x])) pos -> y = old_pos.y;

	//////////

	*y_pitch = -mouse_pos -> y + half_screen_height;
	*angle += ((double) (mouse_pos -> x - prev_mouse_pos -> x) / screen_width) * 360;

	if (mouse_pos -> x == screen_width - 1)
		SDL_WarpMouseInWindow(screen.window_3D, 0, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window_3D, screen_width, mouse_pos -> y);

	prev_mouse_pos -> x = mouse_pos -> x;
	prev_mouse_pos -> y = mouse_pos -> y;

	//////////

	Domain* tilt = &player -> tilt;

	if (strafe) {
		tilt -> val += left_strafe ? -tilt -> step : tilt -> step;

		if (tilt -> val > tilt -> max)
			tilt -> val = tilt -> max;
		else if (tilt -> val < -tilt -> max)
			tilt -> val = -tilt -> max;
	}

	else if (tilt -> val + tilt -> step < 0) tilt -> val += tilt -> step;
	else if (tilt -> val - tilt -> step > 0) tilt -> val -= tilt -> step;

	//////////

	if (pos -> x != old_pos.x || pos -> y != old_pos.y) {
		Pace* pace = &player -> pace;

		if ((pace -> domain.val += pace -> domain.step) > two_pi) pace -> domain.val = 0;
		pace -> screen_offset = sin(pace -> domain.val) * (screen_height / pace -> offset_scaler);
	}

	//////////

	return 1;
}

/////

/*
SDL_PollEvent(&event);
if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE) {
	deinit_sprites(textured_walls, textured_wall_count);
	deinit_sprites(sprites, sprite_count);
	deinit_screen();
	return 0;
}

else if (!handle_input(&player, keys)) continue;
*/

/////

move_speed_decr = 0.08,
angle_turn = 2.0,
dist_step = 0.01,

/////

/*
// this is for saving the direction for a later drift
if (!kinematic_body -> going_forward) kinematic_body -> going_forward = forward;
if (!kinematic_body -> going_back) kinematic_body -> going_back = backward;

const double curr_secs = SDL_GetTicks() / 1000.0;
double velocity;

if (accelerate) {
	kinematic_body -> secs_since_move = curr_secs - kinematic_body -> secs_at_move;
	velocity = kinematic_body -> accel * kinematic_body -> secs_since_move;
	if (velocity > kinematic_body -> max_vel) velocity = kinematic_body -> max_vel;
}
else {
	double time_stop_delta = curr_secs - kinematic_body -> secs_at_stop;
	// DEBUG(time_stop_delta, lf);
	velocity = kinematic_body -> accel * time_stop_delta;
	DEBUG(velocity, lf);
}

const VectorF
	old_pos = {pos -> x, pos -> y},
	movement = {cos(rad_angle) * velocity, sin(rad_angle) * velocity};

if (kinematic_body -> going_forward) pos -> x += movement.x, pos -> y += movement.y;
if (kinematic_body -> going_back) pos -> x -= movement.x, pos -> y -= movement.y;
if (lstrafe) pos -> x += movement.y, pos -> y -= movement.x;
if (rstrafe) pos -> x -= movement.y, pos -> y += movement.x;

if (is_a_wall(map[(int) old_pos.y][(int) pos -> x])) pos -> x = old_pos.x;
if (is_a_wall(map[(int) pos -> y][(int) old_pos.x])) pos -> y = old_pos.y;
*/

/////

// https://www.softschools.com/formulas/physics/deceleration_formula/44/
// https://www.toppr.com/guides/physics-formulas/deceleration-formula/#:~:text=The%20deceleration%20will%20be%20computed,to%20identify%20the%20deceleration%20value.

/*
if (time_since_stop < kinematic_body -> secs_since_move) {
	const double time_delta_to_zero = kinematic_body -> secs_since_move - time_since_stop;
	DEBUG(time_delta_to_zero, lf);
	const double velocity = -kinematic_body -> accel * time_delta_to_zero;
	DEBUG(velocity, lf);

	const VectorF movement = {cos(rad_angle) * velocity, sin(rad_angle) * velocity};
	printf("Movement: {%lf, %lf}\n", movement.x, movement.y);

	if (kinematic_body -> was_going_forward) pos -> x += movement.x, pos -> y += movement.y;
	if (kinematic_body -> was_going_backward) pos -> x -= movement.x, pos -> y -= movement.y;
}
else
	printf("No\n");
*/

/////

/*
DEBUG(kinematic_body -> highest_vel, lf);
DEBUG(deceleration, lf);
DEBUG(time_since_stop, lf);
DEBUG(deceleration * time_since_stop, lf);
printf("---\n");
*/

// v = v0 + at

/////

const double deceleration = -kinematic_body -> highest_vel / time_since_stop;
DEBUG(deceleration, lf);

const double velocity = kinematic_body -> highest_vel + deceleration * time_since_stop;

if (time_since_stop <= kinematic_body -> secs_since_move) {
	const double velocity = -(-kinematic_body -> highest_vel + deceleration * time_since_stop);
	const VectorF movement = {cos(rad_angle) * velocity, sin(rad_angle) * velocity};

	if (kinematic_body -> was_going_forward) pos -> x += movement.x, pos -> y += movement.y;
	if (kinematic_body -> was_going_backward) pos -> x -= movement.x, pos -> y -= movement.y;
}

/////

//////////

const double t = curr_secs - kinematic_body -> secs_at_stop + 0.01; // time since stop
const double v0 = kinematic_body -> highest_vel, a = kinematic_body -> accel;

const double x = v0 * t + 0.5 * a * t * t;

const VectorF movement = {x, x};
pos -> x += movement.x, pos -> y += movement.y;

//////////

vf^2 = v0^2 + 2a (delta x)
(delta x) = -v0^2 -2a

0 = (kinematic_body.highest_vel)^2 + 2 (kinematic_body.accel) (delta x)
-(kinematic_body.highest_vel)^2 - 2 * kinematic_body.accel = delta x

how do I account for time?
vf = v0 + at
0 = v0 + at
0 - v0 = at
t = (0 - v0) / a

now, I have time to slow down
use that to find out the current step based on the segment time

do this instead:
x = x0 + v0t + 0.5at^2
*/

/////

// v = v0 + at

const double
	v0 = kinematic_body -> highest_vel,
	a = kinematic_body -> accel,
	t = curr_secs - kinematic_body -> secs_at_stop;

const double v = v0 + a * t;

const VectorF movement = {cos(rad_angle) * v, sin(rad_angle) * v};

if (kinematic_body -> was_going_forward)
	pos -> x += movement.x, pos -> y += movement.y;

/////

/*
v0 = kinematic_body -> highest_vel
vf = 0
t = curr_secs - kinematic_body -> secs_at_stop

(vf)^2 = (v0)^2 + 2aΔx
2aΔx = (vf)^2 - (v0)^2
Δx = ((vf)^2 - (v0)^2) / 2a
- distance traveled from drifting

x = x0 + v0t + 0.5at^2
*/

DEBUG(kinematic_body -> velocity, lf);

/*
const double
	// v0 = kinematic_body -> max_vel,
	v0 = 0.01,
	t = curr_secs - kinematic_body -> secs_at_stop,
	a = -kinematic_body -> accel;

const double x = v0 * t + 0.5 * a * t * t;
if (x > 0) {
	const VectorF movement = {cos(rad_angle) * x, sin(rad_angle) * x};
	pos -> x += movement.x, pos -> y += movement.y;
}
*/

/*
// v = v0 + at
const double delta_t = curr_secs - kinematic_body -> secs_at_stop;
const double velocity = -kinematic_body -> accel * delta_t;
DEBUG(velocity, lf);
*/

/////

// {0, 0, 0, 0, 0, .v = 0, .max_v = 0.08, 0, 0, .a = 0.04, .max_v = 0.08}, {0, 0} // kinematic_body, mouse_pos

/////

/*
if (mouse_pos -> x == prev_mouse_pos -> x && mouse_pos -> y == prev_mouse_pos -> y) {
	printf("Zero\n");
	printf("X curr and prev: %d, %d\n", mouse_pos -> x, prev_mouse_pos -> x);
	return 0;
}
*/

/////

// SDL_PixelFormat* correct_format = SDL_AllocFormat(PIXEL_FORMAT);

Sprite* sprites = calloc(amount, sizeof(Sprite));

for (int i = 0; i < amount; i++) {
	// const char* path = va_arg(paths, const char*);

	sprites[i] = init_sprite(va_arg(paths, const char*));


	/*
	SDL_Surface* unconverted_surface = SDL_LoadBMP(path);
	if (unconverted_surface == NULL) FAIL("Could not load a sprite: %s\n", path);
	SDL_Surface* converted_surface = SDL_ConvertSurface(unconverted_surface, correct_format, 0);
	SDL_FreeSurface(unconverted_surface);

	Sprite* sprite = &sprites[i];
	sprite -> surface = converted_surface;
	sprite -> texture = SDL_CreateTextureFromSurface(screen.renderer_3D, converted_surface);
	sprite -> path = path;
	*/
}

va_end(paths);
// SDL_FreeFormat(correct_format);

/////

/*
const int frames_per_col, const int frame_count) {

SDL_Surface* unconverted_surface = SDL_LoadBMP(path);
if (unconverted_surface == NULL) FAIL("Could not load a spritesheet: %s\n", path);

SDL_PixelFormat* correct_format = SDL_AllocFormat(PIXEL_FORMAT);
SDL_Surface* converted_surface = SDL_ConvertSurface(unconverted_surface, correct_format, 0);
SDL_FreeSurface(unconverted_surface);
SDL_FreeFormat(correct_format);

const Animation animation = {
	converted_surface, SDL_CreateTextureFromSurface(screen.renderer_3D, converted_surface),
	frames_per_row, frames_per_col, frame_count, path
};

return animation;
*/

/////

// Animation a = init_animation("assets/spritesheets/numbers.bmp", 3, 3, 7, 2);
// Animation a = init_animation("assets/spritesheets/carrot.bmp", 5, 3, 12, 5);

/////

/*
#include "dungeon_dave.h"
#include "utils.c"
#include "screen.c"
#include "audiovisual/audio.c"
#include "audiovisual/sprite.c"
#include "animation.c"
#include "input.c"
#include "floor_and_ceiling.c"
#include "render.c"
*/

/////