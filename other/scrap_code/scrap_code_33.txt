// draw_textured_wall(cast_data, dir, raised_wall);
// draw_scanline(current_level.textured_walls[cast_data.point - 1], 0, &raised_wall);

if (raised_wall.y > *smallest_wall_y) {
	offset = 10;
	// sprite_height = max_sprite_h;

	int amount_obscured = raised_wall.y - *smallest_wall_y + raised_wall.h;
	if (amount_obscured > raised_wall.y + max_sprite_h) continue;
	sprite_height = amount_obscured - max_sprite_h;
	raised_wall.h -= amount_obscured;

	/*
	printf("Continuing for %d\n", cast_data.point);
	continue;
	*/

	/*
	int amount_obscured = raised_wall.y - *smallest_wall_y;
	if (amount_obscured > raised_wall.y + max_sprite_h) continue;
	sprite_height = amount_obscured - max_sprite_h;
	*/
}
else {
	offset = 0;
	sprite_height = max_sprite_h;
	*smallest_wall_y = raised_wall.y;
}

/////

/*
if (raised_wall.y > *smallest_wall_y) {
	// obscured
	raised_wall.h -= 100;
}
else {
	// not obscured
	*smallest_wall_y = raised_wall.y;
}

/////

/*
const double h_change_ratio = raised_wall.h / prev_raised_wall_h;
sprite_height = max_sprite_offset * h_change_ratio;
*/

// sprite_height = max_sprite_offset - 1;
// sprite_height = max_sprite_offset - y_obscured;

/*
const int prev_h = raised_wall.h;
raised_wall.h -= y_obscured;
const double ratio = raised_wall.h / prev_h;
sprite_height = max_sprite_height * ratio;
offset = 0;
*/

/////

/*
const __m128d diff = {
	cast_data.hit[0] - floor(cast_data.hit[0]),
	cast_data.hit[1] - floor(cast_data.hit[1])
};

int sprite_offset;

if (close_to_whole(diff[0])) {
	const int y_offset = diff[1] * max_sprite_offset;
	sprite_offset = dir[0] < 0 ? max_sprite_offset - y_offset : y_offset;
}
else {
	const int x_offset = diff[0] * max_sprite_offset;
	sprite_offset = dir[1] > 0 ? max_sprite_offset - x_offset : x_offset;
}

const SDL_Rect slice = {sprite_offset, 0, 1, sprite_height};

SDL_RenderCopy(screen.renderer_3D, sprite.texture, &slice, &raised_wall);
*/

/////

SDL_Rect* src;
if (generic.is_animated) {
	possible_spritesheet_crop.x = possible_spritesheet_begin_x + offset;
	src = &possible_spritesheet_crop;
}
else src = NULL;

draw_scanline(billboard.sprite, -1, src, &screen_pos);

/////

/*
if (keys[SDL_SCANCODE_Z]) *height += 4;
if (keys[SDL_SCANCODE_X]) *height -= 4;

const double half_proj_dist = settings.projection_distance / 2.0;

if (*height >= half_proj_dist)
	*height = half_proj_dist - 1;
else if (*height <= -half_proj_dist)
	*height = -half_proj_dist + 1;
*/

/////

/*
const int v0 = 3;
const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;
jump -> height = (v0 * t) + (0.5 * g * t * t);

if (jump -> height < 0) {
	jump -> jumping = 0;
	jump -> height = 0;
}
*/

/////

// y = y0 + v0t + 0.5at^2

Why did the above equation never work?

/*
const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;
jump -> height = 0.5 * g * (t * t);

// jump -> height = ((jump -> v0 * t) + ((0.5 * g) * (t * t)));
jump -> height *= (double) settings.screen_height / current_level.max_point_height;

if (jump -> height < 0.0) {
	jump -> jumping = 0;
	jump -> height = 0.0;
}

DEBUG(jump -> height, lf);
*/

/*
const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;
jump -> height = (jump -> v0 + g * t) * t;
jump -> height *= (double) settings.screen_height / current_level.max_point_height;

if (jump -> height < 0.0) {
	jump -> jumping = 0;
	jump -> height = 0.0;
}
DEBUG(jump -> height, lf);
*/

/////

/*
const double v = jump -> v0 + g * t;
jump -> height = v * t;
jump -> height *= (double) settings.screen_height / current_level.max_point_height;
*/

/////

/*
jump -> height = (jump -> v0 * t) + (0.5 * g * t * t);
jump -> height *= (double) settings.screen_height / current_level.max_point_height;

if (jump -> height < 0.0) {
	jump -> jumping = 0;
	jump -> height = 0.0;
}
*/

/////

/*
// jump -> v = jump -> v0 + g * t;
jump -> height = (jump -> v0 + g * t) * t;
jump -> height *= (double) settings.screen_height / current_level.max_point_height;
*/

/////

// this scales to a resized screen width and height


/*
int width, height; // but this does not, so it's necessary to rescale it
SDL_GetWindowSize(screen.window_3D, &width, &height);
*/

/////

if (point_height > *curr_point_height) {

/////

/*
const byte player_point_height = player.jump.height / settings.half_screen_height;
// DEBUG(plr_pt_ht, d);

byte foo = player_point_height > *curr_point_height
	? player_point_height - *curr_point_height
	: 0;

DEBUG(foo, d);
*/

/////

/*
if (current_level.wall_data[(int) floor((*pos)[1])][(int) floor((*pos)[0])]) {
	(*pos)[1] = prev_pos[1];
	(*pos)[0] = prev_pos[0];
}
*/

/*
if (current_level.wall_data[(int) floor((*pos)[1])][(int) floor(prev_pos[0])])
	(*pos)[1] = round(prev_pos[1]) - 0.02 * -sideways_movement[1];

if (current_level.wall_data[(int) floor(prev_pos[1])][(int) floor((*pos)[0])])
	(*pos)[0] = round(prev_pos[0]) - 0.02 * -sideways_movement[0];
*/

/////

if ((*pos)[0] == prev_pos[0] && (*pos)[1] == prev_pos[1] && kinematic_body -> v == 0.0)
	return;

/////

/*
if ((*pos)[0] == prev_pos[0] && (*pos)[1] == prev_pos[1]) {
	printf("Still\n");
}
*/

/////

__m128d movement = {0, 0};

if (kinematic_body -> was_forward)
	(*pos)[0] += forward_back_movement[0], (*pos)[1] += forward_back_movement[1];

if (kinematic_body -> was_backward)
	(*pos)[0] -= forward_back_movement[0], (*pos)[1] -= forward_back_movement[1];

if (lstrafe)
	(*pos)[0] += sideways_movement[1], (*pos)[1] -= sideways_movement[0];

if (rstrafe)
	(*pos)[0] -= sideways_movement[1], (*pos)[1] += sideways_movement[0];

int y_hit = 0, x_hit = 0;

if (current_level.wall_data[(int) floor((*pos)[1])][(int) floor(prev_pos[0])])
	(*pos)[1] = prev_pos[1], y_hit = 1;

if (current_level.wall_data[(int) floor(prev_pos[1])][(int) floor((*pos)[0])])
	(*pos)[0] = prev_pos[0], x_hit = 1;

if (x_hit && y_hit) {
	printf("Corner\n");
	kinematic_body -> v = 0;
	kinematic_body -> moving_forward_or_back = 0;
	(*pos)[0] -= forward_back_movement[0];
	(*pos)[1] -= forward_back_movement[1];
}
else {
	printf("No corner\n");
}

/////

/*
kinematic_body -> v = 0;
kinematic_body -> moving_forward_or_back = 0;
const __m128d two_vec = VectorFF_memset(4);
const __m128d twice_direc = VectorFF_mul(movement, two_vec);
new_pos = VectorFF_sub(new_pos, twice_direc);
*/

/////

// this is a work in progress

/*
printf("---\nnew = {%lf, %lf}, prev = {%lf, %lf}\n",
	new_pos[0], new_pos[1], prev_pos[0], prev_pos[1]);
*/

/////

if (y_hit && x_hit) {
	printf("Corner\n");
	new_pos[0] -= movement[0];
	// new_pos[0] = floor(new_pos[0]);

	/*
	if (sideways_movement[0] > sideways_movement[1])
		new_pos[0] -= movement[0];
	else
		new_pos[1] -= movement[1];
	*/

/////

/*
const double move_speed_decr = 0.01;
const double
	move_x = move_speed_decr * cos(rad_theta),
	move_y = move_speed_decr * sin(rad_theta);

printf("move x, y: %lf, %lf\n", move_x, move_y);

if (forward) (*pos)[0] += move_x, (*pos)[1] += move_y;
if (backward) (*pos)[0] -= move_x, (*pos)[1] -= move_y;
*/

/*
if (lstrafe) pos[0] += move_y, pos[1] -= move_x;
if (rstrafe) pos[0] -= move_y, pos[1] += move_x;
*/

const double curr_time = SDL_GetTicks() / 1000.0;
const __m128d delta_time_vec = VectorFF_memset(curr_time - body -> last_tick_time);

body -> v += VectorFF_mul(body -> a, delta_time_vec);
DEBUG(body -> v[0], lf);

const __m128d movement_magnitude = {
	cos(rad_theta) * body -> v[0],
	sin(rad_theta) * body -> v[1]
};

__m128d movement = {0.0, 0.0};

if (forward)
	movement = VectorFF_add(movement, movement_magnitude);

if (backward)
	movement = VectorFF_sub(movement, movement_magnitude);

if (lstrafe)
	movement[0] += movement_magnitude[1], movement[1] -= movement_magnitude[0];

if (rstrafe)
	movement[0] -= movement_magnitude[1], movement[1] += movement_magnitude[0];

*pos = VectorFF_add(*pos, movement);

body -> last_tick_time = curr_time;

/////

/*
const double mu_k = 0.75;
const __m128d friction = VectorF_memset(mu_k * g);

v_change = VectorFF_sub(v_change, friction);
*/

/////

/*
physics plan:
	- against wall -> no pace
	- accumulate v, no reset
	- if on wall, set to old, if corner, glide
	- all direction speeds are the same
	- use friction
*/

/////

void update_pos_2(__m128d* pos, const __m128d prev_pos, Body2D* body,
	const double rad_theta, const int forward,
	const int backward, const int lstrafe, const int rstrafe) {

	const double curr_time = SDL_GetTicks() / 1000.0;
	const double dt = curr_time - body -> last_tick_time;
	const double v_addenum = body -> a * dt;

	const int moved = forward || backward || lstrafe || rstrafe;

	const __m128d velocity_vec = {
		v_addenum * cos(rad_theta), v_addenum * sin(rad_theta)
	};

	__m128d movement = {0.0, 0.0};

	if (forward)
		movement = VectorFF_add(movement, velocity_vec);

	if (backward)
		movement = VectorFF_sub(movement, velocity_vec);

	if (lstrafe)
		movement[0] += velocity_vec[1], movement[1] -= velocity_vec[0];

	if (rstrafe)
		movement[0] -= velocity_vec[1], movement[1] += velocity_vec[0];

	*pos = VectorFF_add(*pos, movement);

	/*
	const double new_v = sqrt(movement[0] * movement[0] + movement[1] * movement[1]);
	body -> v = new_v;
	*/

	body -> v += v_addenum;
	if (body -> v > body -> max_v) body -> v = body -> max_v;

	/////
	if (current_level.wall_data[(int) floor((*pos)[1])][(int) floor(prev_pos[0])])
		(*pos)[1] = prev_pos[1];

	if (current_level.wall_data[(int) floor(prev_pos[1])][(int) floor((*pos)[0])])
		(*pos)[0] = prev_pos[0];
	/////
}

/////

/*
typedef struct {
	double last_tick_time, a, v, max_v;
} Body2D;
*/

/////

// printf("fbm = {%lf, %lf}\n", forward_back_movement[0], forward_back_movement[1]);
// if (/* old = new*/)

/////

/*
int moving_forward_or_back, was_forward, was_backward;
double v, max_v_reached, time_of_move, time_of_stop;
const double a, limit_v, strafe_v;
*/

/////

/*
if (dir.x == 1) {

}

else if (dir.x == -1) {

}

if (dir.y == 1) {

}

else if (dir.y == -1) {

}
*/

/////

/*
printf("Align %lf to ", axis_val);
const double decimal_component = axis_val - (int) floor(axis_val);
const double aligned = round(decimal_component);
printf("%lf\n", aligned);
return aligned;
*/

/////

if (dir.x != 0) (*pos)[0] = align_navigator_axis((*pos)[0]);
if (dir.y != 0) (*pos)[1] = align_navigator_axis((*pos)[1]);

/////

// doesn't work on top side of map + certain corners
// printf("{%lf, %lf}\n", next_vertex.x, next_vertex.y);

/////

/*
const double decimal_component = axis_val - (int) floor(axis_val);
if (doubles_eq(decimal_component, 0.5)) return axis_val;
else if (decimal_component < 0.25) return round(axis_val);
else return round(axis_val) + 0.5;
*/

/////

__m128d p = *pos;
if (current_level.wall_data[(int) ceil(p[1])][(int) ceil(p[0])])
	printf("Corner clip\n");

/////

/*
const double
	dist_a = ((GenericBillboard*) a) -> billboard.dist,
	dist_b = ((GenericBillboard*) b) -> billboard.dist;
*/

/////

// const byte point = current_level.wall_data[(int) floor(curr_tile.y)][(int) floor(curr_tile.x)];

/////

static inline const byte VectorF_wall_point(const VectorF v) {
	return current_level.wall_data[(int) floor(v[1])][(int) floor(v[0])];
}

/////

/*
Permadi:
Draw the floor from the point of where the height changes occurs until the point where the top of the last wall slice is projected onto.
(Initially, the top of last wall slice will be the bottom of the projection plane.)
*/

// Perhaps SDL_RenderCopyEx if it's drawn first (the painter's algorithm)

const SDL_Rect top_side = {
	screen_x, raised_wall.y,
	settings.ray_column_width, 5
};
draw_colored_rect(0, 128, 0, &top_side);

/////

/*
// if (jump -> jumping) {
if (1) {
	const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;
	jump -> height = ((jump -> v0 * t) + (0.5 * g * (t * t))) * settings.screen_height;

	if (jump -> height < 0.0) {
		jump -> jumping = 0;
		jump -> height = 0.0;
	}
	else if (jump -> height > rel_floor_height && jump -> jumping) {
		jump -> jumping = 0;
		jump -> height = rel_floor_height;
	}
}
*/

/////

/*
const double v = jump -> v0 + g * t;

if (v < 0 || jump -> jumping) { // if falling or jumping
	jump -> height = ((jump -> v0 * t) + (0.5 * g * (t * t))) * settings.screen_height;
	DEBUG(jump -> height, lf);
}

if (jump -> height < 0.0) {
	printf("Reset\n");
	jump -> jumping = 0;
	jump -> height = 0.0;
}
*/

/////

if (keys[SDL_SCANCODE_L] && !jump -> jumping) {
	jump -> jumping = 1;
	jump -> time_at_jump = SDL_GetTicks() / 1000.0;
}

// jump -> height = 0;
jump -> jumping = 0;

printf("Hop\n");

// some slowdown

/*
const byte point = current_level.wall_data[(int) floor(pos[1])][(int) floor(pos[0])];
const byte point_height = current_level.get_point_height(point);

const double t = SDL_GetTicks() / 1000.0 - jump -> time_at_jump;
// const double v = jump -> v0 + g * t;
if (jump -> jumping) {
	jump -> height = ((jump -> v0 * t) + (0.5 * g * (t * t))) * settings.screen_height;

	if (jump -> height < 0.0) {
		jump -> jumping = 0;
		jump -> height = 0.0;
	}
}

if (jump -> height >= settings.screen_height) {

	if (point_height == 1 && point) {
		jump -> jumping = 0;
		jump -> height = settings.screen_height;
	}
	else if (!point) {
		jump -> jumping = 1;
	}
}
*/

/////