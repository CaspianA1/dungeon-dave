Enemy e = {&animations[0], 10};

while (1) {
	update_enemy(e, player);

/////

/*
ray_src = cast_data.hit;
ray_src.x += cast_data.ray_step.x;
ray_src.y += cast_data.ray_step.y;
*/

///// The old raycasting function:

/*
void raycast(const Player player) {
	const double player_angle = to_radians(player.angle);

	for (int screen_x = 0; screen_x < screen_width; screen_x += ray_column_width) {
		const double theta =
			atan((screen_x - half_screen_width) / screen.projection_distance) + player_angle;

		const VectorF ray_direction = {cos(theta), sin(theta)};
		const CastData cast_data = dda(player.pos, ray_direction);

		#ifdef MODE_2D
		SDL_RenderDrawLine(screen.renderer_2D,
			round(player.pos.x * width_ratio), round(player.pos.y * height_ratio),
			round(cast_data.hit.x * width_ratio), round(cast_data.hit.y * height_ratio));
		#endif

		const double cos_beta = cos(player_angle - theta);
		const double correct_dist = cast_data.dist * cos_beta;
		screen.z_buffer[screen_x] = correct_dist;

		const int wall_height = screen.projection_distance / correct_dist;

		const SDL_Rect wall = {
			screen_x,
			half_screen_height - wall_height / 2 + player.y_pitch + player.pace.screen_offset,
			ray_column_width, wall_height
		};


		draw_floor_and_ceil(player, ray_direction, wall, cos_beta);
		draw_wall(cast_data, ray_direction, wall);
	}
}
*/

///// The old DDA:


const CastData dda(const VectorF pos, const VectorF dir) {
	const VectorF unit_step_size = {fabs(1.0 / dir.x), fabs(1.0 / dir.y)};
	VectorI current_tile = {floor(pos.x), floor(pos.y)};
	VectorF ray_step, ray_length;

	if (dir.x < 0)
		ray_step.x = -1.0,
		ray_length.x = (pos.x - current_tile.x) * unit_step_size.x;
	else
		ray_step.x = 1.0,
		ray_length.x = (current_tile.x + 1.0 - pos.x) * unit_step_size.x;

	if (dir.y < 0)
		ray_step.y = -1.0,
		ray_length.y = (pos.y - current_tile.y) * unit_step_size.y;
	else
		ray_step.y = 1.0,
		ray_length.y = (current_tile.y + 1.0 - pos.y) * unit_step_size.y;

	double distance = 0;
	while (1) {
		if (ray_length.x < ray_length.y)
			distance = ray_length.x,
			current_tile.x += ray_step.x,
			ray_length.x += unit_step_size.x;
		else
			distance = ray_length.y,
			current_tile.y += ray_step.y,
			ray_length.y += unit_step_size.y;

		const byte point = map[(int) floor(current_tile.y)][(int) floor(current_tile.x)];
		if (point) {
			const CastData cast_data = {point, distance, 
				{dir.x * distance + pos.x, dir.y * distance + pos.y}, ray_step};
			return cast_data;
		}
	}
}

///// Random code:

// break;

/*
if (cast_data.dist == 0.0) {
	printf("Zero. Hit at x = %lf and y = %lf, from x = %lf and y = %lf.\n",
		cast_data.hit.x, cast_data.hit.y, ray_src.x, ray_src.y);
}

const double correct_dist = cast_data.dist * cos(player_angle - theta);

if (first_iteration) {
	screen.z_buffer[screen_x] = correct_dist;
	first_iteration = 0;
}

const int wall_height = screen.projection_distance / correct_dist;

SDL_Rect wall = {
	screen_x,
	half_screen_height - wall_height / 2 + player.y_pitch + player.pace.screen_offset,
	ray_column_width, wall_height
};

// printf("wall = {%d, %d, %d, %d}\n", wall.x, wall.y, wall.w, wall.h);

const int point_height = w_height(cast_data.point);
if (point_height > current_height) {
	wall.y -= wall_height * (cast_data.point == 5);
	draw_wall(cast_data, ray_direction, wall);
	current_height = point_height;
}

ray_src.x = cast_data.hit.x + cast_data.next_ray_step.x;
ray_src.y = cast_data.hit.y + cast_data.next_ray_step.y;

if (ray_src.x < 0 || ray_src.x >= map_width || ray_src.y < 0 || ray_src.y >= map_height)
	break;
*/

/////

/*
DEBUG(cast_data.point, d);

if (cast_data.hit.x < 0 || cast_data.hit.x >= map_width
	|| cast_data.hit.y < 0 || cast_data.hit.y >= map_height) {
	printf("Exit\n");
	break;
}
*/

/////

// draw_wall(cast_data, dir, wall);

/*
printf("Point, height: %d, %d\n", point, point_height);
if (point_height > curr_point_height) {
	wall.y -= wall_height;
	draw_wall(cast_data, dir, wall);
	bottom_wall_y = wall_height;
}
else {
	printf("Else\n");
	draw_wall(cast_data, dir, wall);
}
*/

/////

This method almost works:

// only draw one line per level
const int point_height = get_point_height(point);

if (point_height > curr_point_height) {
	last_wall_top = wall.y; // use this var
	curr_point_height = point_height;

	if (point_height != 1) { //  && screen.z_buffer[(int) screen_x] > distance) {
		draw_wall(cast_data, dir, wall);
	}

	wall.y -= wall_height * (point % 2 == 0);
	draw_wall(cast_data, dir, wall);
}

///// This code is najs:

const byte point_height = get_point_height(point, hit.x);
if (point_height > curr_point_height) {

	/*
	for (int i = 0; i < point_height && wall.y + wall.h >= 0; i++) {
		draw_wall(cast_data, dir, wall);
		wall.y -= wall_height;
	}
	curr_point_height = point_height;
}

///// This code works differently, oddly enough:

/*
printf("---\n");
const byte point_height = get_point_height(point);
if (point_height > curr_point_height) {
	for (byte i = curr_point_height; i < point_height; i++) {
		draw_wall(cast_data, dir, wall);
		wall.y -= wall_height;
		printf("Normal wall: {%d, %d, %d, %d}\n", wall.x, wall.y, wall.w, wall.h);

		SDL_Rect raised_wall = wall;
		raised_wall.y -= wall_height * i;
		printf("Raised wall: {%d, %d, %d, %d}\n", raised_wall.x, raised_wall.y, raised_wall.w, raised_wall.h);
	}

	curr_point_height = point_height;
}
*/

/////

/*
if (point == 11) {
	printf("Sand; top_y_wall = %ld\n", top_y_wall);
}
else if (point == 5) {
	printf("Bluestone; top_y_wall = %ld\n", top_y_wall);
}
*/

if (raised_wall.y + raised_wall.h < 0) break;

/*
else if (raised_wall.y < top_y_wall)
	top_y_wall = raised_wall.y;
*/
// if (point == 5) continue;

/////

// lowest_wall_y = wall.y - wall_height * (point_height - 1);

/////