void update_theta_and_dir_and_plane(double* theta,
	VectorI* mouse_pos) {

	//////////
	const int prev_mouse_x = mouse_pos -> x;
	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);
	if (prev_mouse_x == mouse_pos -> x) return;

	const double
		prev_theta = *theta,
		delta_theta = (double) (mouse_pos -> x - prev_mouse_x) / settings.screen_width * 360.0;

	*theta += delta_theta;

	if (mouse_pos -> x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
	//////////

	VectorF floor_dir = settings.floor_dir, floor_plane = settings.floor_plane;

	const double
		old_dir_x = floor_dir[0],
		old_plane_x = floor_plane[0],
		theta_v = fabs(to_radians(delta_theta));

	const double cos_theta_v = cos(theta_v), sin_theta_v = sin(theta_v);

	if (prev_theta > *theta) {
		floor_dir[0] = floor_dir[0] * cos_theta_v - floor_dir[1] * sin_theta_v;
		floor_dir[1] = old_dir_x * sin_theta_v + floor_dir[1] * cos_theta_v;
		floor_plane[0] = floor_plane[0] * cos_theta_v - floor_plane[1] * sin_theta_v;
		floor_plane[1] = old_plane_x * sin_theta_v + floor_plane[1] * cos_theta_v;
	}

	else if (prev_theta < *theta) {
		floor_dir[0] = floor_dir[0] * cos_theta_v + floor_dir[1] * sin_theta_v;
		floor_dir[1] = old_dir_x * -sin_theta_v + floor_dir[1] * cos_theta_v;
		floor_plane[0] = floor_plane[0] * cos_theta_v + floor_plane[1] * sin_theta_v;
		floor_plane[1] = old_plane_x * -sin_theta_v + floor_plane[1] * cos_theta_v;
	}

	/*
	*floor_dir = dir_c;
	*floor_plane = plane_c;
	*/

	/*
	settings.floor_dir = floor_dir;
	settings.floor_plane = floor_plane;
	*/

	const double rad_theta = to_radians(*theta);
	const VectorF actual = {cos(rad_theta), sin(rad_theta)};
	const VectorF reversed = {actual[1], -actual[0]};

	settings.floor_dir = actual;
	settings.floor_plane = reversed;
}

/////

void floorcast(const Player player) {	
	const VectorF
		pos = player.pos,
		dir = settings.floor_dir,
		plane = settings.floor_plane;

	// DEBUG_VECF(dir);

	const double o = to_radians(player.angle);
	const VectorF other = {cos(o), sin(o)};

	// printf("floor_dir = {%lf, %lf}, natural = {%lf, %lf}\n", dir[0], dir[1], other[0], other[1]);
	printf("plane = {%lf, %lf}, dir = {%lf, %lf}\n", plane[0], plane[1], dir[0], dir[1]);

	const VectorF
		width_vec = VectorF_memset(settings.screen_width),
		ray_dir_begin = VectorFF_sub(dir, plane),
		ray_dir_diff = VectorFF_mul(plane, VectorF_memset(2.0));

	// byte** tex_hit_data = current_level.floor_data;

	const SDL_Surface* surface = current_level.textured_walls[5].surface;
	const VectorF tex_w = VectorF_memset(surface -> w);

	const int max_offset = tex_w[0] - 1;

	// y change in screen space
	const double y_change = player.pace.screen_offset + player.z_pitch;

	/*
	const double horizon_line = settings.half_screen_height - y_change;
	const double p_height_ratio =
		player.jump.height * settings.screen_height / settings.projection_distance;
	*/

	for (int y = -y_change; y < settings.screen_height - y_change; y++) {
		const int row = abs(y - settings.half_screen_height);

		// int opp_h = 0.5 + (y < horizon_line ? -p_height_ratio : p_height_ratio);
		// VectorF opp_h_vec = VectorF_memset(opp_h);
		// const VectorF row_dist = VectorF_memset((double) opp_h * settings.screen_height / row);

		const VectorF row_dist = VectorF_memset((double) settings.half_screen_height / row);
		const VectorF step = VectorFF_div(VectorFF_mul(row_dist, ray_dir_diff), width_vec);
		VectorF ray_pos = VectorFF_add(VectorFF_mul(ray_dir_begin, row_dist), pos);

		for (int x = 0; x < settings.screen_width; x++) {
			const VectorF cell = {floor(ray_pos[0]), floor(ray_pos[1])};

			/*
			if (cell[0] <= 1.0 || cell[0] >= current_level.map_width - 1.0
				|| cell[1] <= 1.0 || cell[1] >= current_level.map_height - 1.0)
				continue;
			*/

			/*
			const byte point = tex_hit_data[(int) cell[1]][(int) cell[0]];
			const SDL_Surface* surface = current_level.textured_walls[point - 1].surface;
			const VectorF tex_w = VectorF_memset(surface -> w);
			const int max_offset = tex_w[0] - 1;
			*/

			const VectorF tex_offset = VectorFF_mul(tex_w, VectorFF_sub(ray_pos, cell));

			*get_pixbuf_pixel(x, y + y_change) = get_surface_pixel(
				surface -> pixels, surface -> pitch,
				(int) tex_offset[0] & max_offset,
				(int) tex_offset[1] & max_offset);

			ray_pos = VectorFF_add(ray_pos, step);
		}
	}
}

/////

/*
const double rad_theta = to_radians(*theta);
const VectorF actual = {cos(rad_theta), sin(rad_theta)};
const VectorF reversed = {actual[1], -actual[0]};

settings.floor_dir = actual;
settings.floor_plane = reversed;
*/

/////

/*
settings.floor_dir[0] = -1.0;
settings.floor_dir[1] = 0.0;
*/

settings.floor_dir[0] = 1.0;
settings.floor_plane[1] = 0.0;
settings.floor_plane[0] = 0.0;


/////

inlinable void update_projection_distance(void) {
	const double tan_half_fov = tan(to_radians(settings.fov / 2.0));
	settings.floor_plane[1] = tan_half_fov;
	settings.projection_distance = settings.half_screen_width / tan_half_fov;
}

/////

/*
const double horizon_line = settings.half_screen_height - y_change;
const double p_height_ratio =
	player.jump.height * settings.screen_height / settings.projection_distance;
*/

for (int y = -y_change; y < settings.screen_height - y_change; y++) {
	const int row = abs(y - settings.half_screen_height);

	// int opp_h = 0.5 + (y < horizon_line ? -p_height_ratio : p_height_ratio);
	// VectorF opp_h_vec = VectorF_memset(opp_h);
	// const VectorF row_dist = VectorF_memset((double) opp_h * settings.screen_height / row);

/////

// VectorF floor_dir, floor_plane;

/////

VectorF cell = {floor(ray_pos[0]), floor(ray_pos[1])};
if (cell[0] < 0.0) cell[0] = current_level.map_width - cell[0];
else if (cell[0] >= current_level.map_width) cell[0] = 

if (cell[1] < 0.0) cell[1] = current_level.map_height - cell[1];


/*
if (cell[0] <= 1.0 || cell[0] >= current_level.map_width - 1.0
	|| cell[1] <= 1.0 || cell[1] >= current_level.map_height - 1.0)
	continue;
*/

/////

const byte point = tex_hit_data[(int) cell[1]][(int) cell[0]];
const SDL_Surface* surface = current_level.textured_walls[point - 1].surface;
const VectorF tex_w = VectorF_memset(surface -> w);
const int max_offset = tex_w[0] - 1;

/////

/*
if (cell[0] <= 1.0 || cell[0] >= current_level.map_width - 1.0
	|| cell[1] <= 1.0 || cell[1] >= current_level.map_height - 1.0)
	continue;
*/

/*
const Uint32 src = get_surface_pixel(
	surface -> pixels, surface -> pitch,
	(int) tex_offset[0] & max_offset,
	(int) tex_offset[1] & max_offset);

*get_pixbuf_pixel(x, y + y_change) = src;

// DEBUG(settings.screen_height - reshifted_y - 1, d);
// *get_pixbuf_pixel(x, settings.screen_height - (y + 1)) = src;
// *get_pixbuf_pixel(x, 599) = src;

const int opposite_y = settings.screen_height - y - 1;
*get_pixbuf_pixel(x, opposite_y + y_change) = src;

ray_pos = VectorFF_add(ray_pos, step);
*/

/////

/*
if (cell[0] <= 1.0 || cell[0] >= current_level.map_width - 1.0
	|| cell[1] <= 1.0 || cell[1] >= current_level.map_height - 1.0)
	continue;
*/


/////

/*
DEBUG_VECF(dir);
DEBUG_VECF(plane);
printf("---\n");
*/

/////

//
const double jh = player.jump.height;
const double rh = jh * settings.screen_height / 8.0;

/*
const double p_height_ratio = jh
	* settings.screen_height / settings.projection_distance;
*/

//

/////

static double a = 5;
if (keys[SDL_SCANCODE_T]) a += 0.1;
if (keys[SDL_SCANCODE_Y]) a -= 0.1;
DEBUG(a, lf);

/////

/*
player.pace.screen_offset = 0;
player.z_pitch = 0;
*/

/////

/*
if (jump -> height > jump -> max_height)
	jump -> max_height = jump -> height;
*/

if (jump -> height < 0.0) {
	jump -> jumping = 0;
	jump -> height = 0.0;
}

// keep track of the max height reached to get rid of the clipping issue

/*
else if (jump -> height < wall_point_height
	&& jump -> max_height > wall_point_height
	&& (jump -> v0 + g * t) < 0.0) {
*/

else if (jump -> height < wall_point_height
	&& (jump -> v0 + g * t) < 0.0) {
	jump -> jumping = 0;
	jump -> start_height = wall_point_height;
	jump -> height = jump -> start_height;
}

/*
else if (doubles_eq(jump -> height, wall_point_height)) {

}
*/

/////

if (jump -> height < wall_point_height
	&& jump -> highest_height > wall_point_height
	&& (jump -> v0 + g * t) < 0.0) {

	/*
	if (jump -> highest_height > wall_point_height) {
		printf("Accept\n");
	}
	else {
		printf("Reject\n");
	}
	*/

	printf("Cancel jumping\n");
	jump -> jumping = 0;
	jump -> start_height = wall_point_height;
	jump -> height = jump -> start_height;
	jump -> highest_height = jump -> height - 0.5;
}
else {
	printf("ELSE\n");
	if (jump -> height < wall_point_height) {
		printf("Below it\n");
	}
}

/////

// const double height = current_level.max_point_height - player.jump.height -2.0;
/*
static double height = 0;

const static unsigned height_buttons[] = {
	SDL_SCANCODE_0, SDL_SCANCODE_1,
	SDL_SCANCODE_2, SDL_SCANCODE_3,
	SDL_SCANCODE_4, SDL_SCANCODE_5
};
*/

// needed, from the bottom to the almost top (for the ceiling): 2, 1, 0

/*
for (int i = 0; i < 6; i++)
	if (keys[height_buttons[i]]) {
		printf("Set to %d\n", i);
		height = i;
	}
*/

/////

/*
const double beta = atan((x - settings.half_screen_width)
	/ settings.proj_dist);

const double straight_dist = pos_z / row * settings.proj_dist;
const double actual_dist = straight_dist / fabs(cos(beta));
*/
// const double actual_dist = 0.2;
// DEBUG(beta, lf);
// DEBUG(actual_dist, lf);

/////

/*
if (cell[0] < 0.0 || cell[0] > current_level.map_width
	|| cell[1] < 0.0 || cell[1] > current_level.map_height)
	continue;
*/

/////

/*
if (pos[0] * pos[1] < 20.0) return 1.4;
else if (pos[0] >= 3.5 && pos[0] <= 6.5) return 2.2;
return fabs(sin(pos[0])) * 3.0;
*/
return 3.0;

/////

	const static VectorF
		pillar_center = {4.5, 11.5},
		halves = {0.5, 0.5};

	/*
	if (VectorFF_sub(pos, pillar_center) > halves)
		return 2.7;
	*/

	if (VectorFF_eq(pos, halves)) return 2.7;

	else return 1.0;

/////

#define VectorFF_eq(a, b) _mm_movemask_ps(_mm_cmpeq_epi32(a, b))

/////

const VectorF
	less_than_or_eq = _mm_cmp_pd(a, b, 17),
	greater_than_or_eq = _mm_cmp_pd(a, b, 29);

DEBUG_VECF(less_than_or_eq);

return 1;

/////

// comparison: https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=901,899,735&cats=Compare
inlinable byte VectorFF_close(const VectorF a, const VectorF b, const double y) {
	return fabs(a[0] - b[0]) < y && fabs(a[1] - b[1]) < y;
}

/////

/*
else if (pos[0] >= 16.0 && pos[0] <= 17.5
	&& pos[1] >= 16.5 && pos[1] <=)
*/

/*
const VectorF tunnel_entrance_diff = VectorFF_diff(pos, tunnel_entrance);
if (tunnel_entrance_diff[0] <= 2.51 && tunnel_entrance_diff[1] < 2.5) {
	return 3.5 - ((tunnel_entrance_diff[0] + tunnel_entrance_diff[1]) / 2.0);
}
*/

/////

/*
else if ()

else if (pos[0] - 16.0 < almost_zero && pos[1] - 21.0 < almost_zero)

// if (pos[0] >= 15.99 && pos[0] <= 20.99 && pos[1] >= 0.99 && pos[1] <= 5.99)
// if (pos[0] >= 15.9999 && pos[0] <= 20.99)
	return fabs(tan(pos[0] - pos[1]));
*/

/*
origin: {20.0, 5.0}
dest: {15.0, 1.0}
*/

// (x − a)^2 + (y - b)^2 = r^2

// return fabs(tan(pos[0] + pos[1]));

/////

/*
origin: {20.0, 5.0}
dest: {15.0, 1.0}
*/

// (x − a)^2 + (y - b)^2 = r^2

// return fabs(tan(pos[0] + pos[1]));

/////