// This is working without pacing!
for (int y = 0; y < half_screen_height; y++) {
	const double floor_straight_distance = 0.5 / y * screen.projection_distance;
	const double floor_actual_distance = floor_straight_distance / cos_beta;

	const double 
		hit_x = cos_theta * floor_actual_distance + player.pos.x,
		hit_y = sin_theta * floor_actual_distance + player.pos.y;

	const int
		tex_x = (int) ((hit_x - floor(hit_x)) * sprite_w) & sprite_w - 1,
		tex_y = (int) ((hit_y - floor(hit_y)) * sprite_h) & sprite_h - 1;

	Uint32 surface_pixel = get_surface_pixel(pixels, surface_pitch, bytes_per_pixel, tex_x, tex_y);
	SDL_Color pixel;
	SDL_GetRGB(surface_pixel, format, &pixel.r, &pixel.g, &pixel.b);

	// there's no wall here (of course), but this is used for the shading calculation
	const double shade = calculate_shade(screen.projection_distance / floor_actual_distance);
	surface_pixel = SDL_MapRGB(format, pixel.r * shade, pixel.g * shade, pixel.b * shade);

	const int ground_y = half_screen_height + y;
	*get_pixbuf_pixel(wall_pos.x, ground_y) = surface_pixel;

	const int roof_y = half_screen_height - y;
	*get_pixbuf_pixel(wall_pos.x, roof_y) = surface_pixel;
}

/////

// I don't need to change where I draw the floor, only which intersection points I come across

/////

void draw_floor_or_ceiling(const int start, const int end, const double cos_beta,
	const void* pixels, const int surface_pitch, const int bpp, const int sprite_w,
	const int sprite_h);

/////

$(CC) $(CFLAGS) $(DEBUG) --coverage -fprofile-arcs $(LDFLAGS)
mv *.gcno 

# -f
gcov $(OUT).gcno #  > /dev/null
# mkdir -p bin/profiling
# mv *.gcov *.gcno bin/profiling

/////

- profiling: dtrace, sample, or instruments:
	- https://gist.github.com/loderunner/36724cc9ee8db66db305

/////

if (curr_cast.x > screen_width - 1 || curr_cast.y > screen_height - 1
	|| curr_cast.x < 0 || curr_cast.y < 0) {

	const CastData fail = {100};
	return fail;
}

/////

/*
if (doubles_eq(dir.x, 0)) printf("Dir x, zero\n");
if (doubles_eq(dir.y, 0)) printf("Dir y, zero\n");
*/

// printf("Normalized delta, {%lf, %lf}\n", normalized_delta.x, normalized_delta.y);

/*
if (curr_cast.x > screen_width - 1 || curr_cast.y > screen_height - 1
	|| curr_cast.x < 0 || curr_cast.y < 0)
	printf("Out of bounds: %lf, %lf. Point = %d\n", curr_cast.x, curr_cast.y, point);
*/

/////

/*
if (event.type == SDL_QUIT) {
	deinit();
	return 0;
}
*/

/////

/*
inlinable void draw_2D_dot(const double x, const double y, const byte r, const byte g, const byte b) {
	const SDL_Rect dot = {x * width_ratio, y * height_ratio, 5, 5};
	SDL_SetRenderDrawColor(screen.renderer_2D, 255, 0, 0, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer_2D, &dot);
}
*/

/////

const Vector normalized_delta = {1.0 / dir.x, dir.y == 0 ? 1 : 1.0 / dir.y};

/////

void raycast_2(const Player player) {
	const double rad_player_angle = to_radians(player.angle);

	int screen_x = 0;

	// theta must not have a constant step
	for (double theta = player.angle - half_fov; theta < player.angle + half_fov; theta += theta_step) {
		const double rad_theta = to_radians(theta);
		const double sin_theta = sin(rad_theta), cos_theta = cos(rad_theta);

		const Vector ray_direction = {cos_theta, sin_theta};
		const CastData collision = dda(player.pos, ray_direction);

		const double cos_beta = cos(rad_player_angle - rad_theta);
		screen.z_buffer[screen_x] = collision.dist * cos_beta;

		const int wall_height = screen.projection_distance / collision.dist;

		const SDL_Rect wall = {
			screen_x,
			half_screen_height - wall_height / 2 + player.y_pitch.val,
			1, wall_height
		};

		SDL_Rect pace_wall = wall; pace_wall.y += player.pace.screen_offset;

		if (collision.point <= plain_wall_count)
			draw_untextured_wall(wall_height, collision.point, pace_wall);
		else
			draw_textured_wall(wall_height, collision.point, pace_wall, collision.hit.x, collision.hit.y);

		draw_floor(wall, player, cos_theta, sin_theta, cos_beta);

		screen_x++;
	}
	draw_sprites(player);
}

/////

Vector normalized_delta;
if (dir.x == 0) normalized_delta.x = 0; else normalized_delta.x = 1.0 / dir.x;
if (dir.y == 0) normalized_delta.y = 0; else normalized_delta.y = 1.0 / dir.y;

/////

const double rad_player_angle = to_radians(player.angle);

for (int x = 0; x < screen_width; x++) {
	const double theta = atan2(x, half_fov) + rad_player_angle;
	const Vector ray_direction = {cos(theta), sin(theta)};

	const CastData ray = dda(player.pos, ray_direction);
	const double actual_dist = ray.dist * cos(rad_player_angle - theta);

	const int wall_height = screen.projection_distance / actual_dist;
	const SDL_Rect wall = {
		x,
		half_screen_height - wall_height / 2 + player.y_pitch.val,
		1, wall_height
	};

	draw_untextured_wall(wall_height, 1, wall);
}

/////

const CastData dda(const Vector pos, const Vector dir) {
	const Vector normalized_delta = {1.0 / dir.x, 1.0 / dir.y};

	const int
		dir_x_negative = dir.x < 0.0,
		dir_y_negative = dir.y < 0.0;

	const Vector step = {dir_x_negative ? -1 : 1, dir_y_negative ? -1 : 1};

	Vector next = {
		 (dir_x_negative ? ceil(pos.x) : floor(pos.x)) + step.x,
		 (dir_y_negative ? ceil(pos.y) : floor(pos.y)) + step.y
	};

	double dist = 0.0;

	while (1) {
		const Vector curr_cast = {
			dir.x * dist + pos.x,
			dir.y * dist + pos.y
		};

		const byte point = map[(int) curr_cast.y][(int) curr_cast.x];

		#ifdef MODE_2D
		const SDL_Rect dot = {curr_cast.x * width_ratio, curr_cast.y * height_ratio, 1, 1};
		SDL_RenderFillRect(screen.renderer_2D, &dot);
		#endif

		if (is_a_wall(point)) {
			const CastData hit = {point, dist, {curr_cast.x, curr_cast.y}};
			return hit;
		}

		const Vector delta = {
			normalized_delta.x * (next.x - pos.x),
			normalized_delta.y * (next.y - pos.y)
		};

		dist = delta.x < delta.y ? delta.x : delta.y;
		if (delta.x == dist) next.x += step.x;
		if (delta.y == dist) next.y += step.y;
	}
}

/////

const CastData dda(const Vector pos, const Vector dir) {
	const Vector normalized_delta = {1.0 / dir.x, 1.0 / dir.y};

	const int
		dir_x_negative = dir.x < 0.0,
		dir_y_negative = dir.y < 0.0;

	const Vector step = {dir_x_negative ? -1 : 1, dir_y_negative ? -1 : 1};

	Vector next = {
		 (dir_x_negative ? ceil(pos.x) : floor(pos.x)) + step.x,
		 (dir_y_negative ? ceil(pos.y) : floor(pos.y)) + step.y
	};

	double dist = 0.0;

	while (1) {
		const Vector curr_cast = {
			dir.x * dist + pos.x,
			dir.y * dist + pos.y
		};

		const byte point = map[(int) curr_cast.y][(int) curr_cast.x];

		#ifdef MODE_2D
		const SDL_Rect dot = {curr_cast.x * width_ratio, curr_cast.y * height_ratio, 1, 1};
		SDL_RenderFillRect(screen.renderer_2D, &dot);
		#endif

		if (is_a_wall(point)) {
			const CastData hit = {point, dist, {curr_cast.x, curr_cast.y}};
			return hit;
		}

		const Vector delta = {
			normalized_delta.x * (next.x - pos.x),
			normalized_delta.y * (next.y - pos.y)
		};

		dist = delta.x < delta.y ? delta.x : delta.y;
		if (delta.x == dist) next.x += step.x;
		if (delta.y == dist) next.y += step.y;
	}
}

/////

inlinable const Vector vec_add(const Vector a, const Vector b) {
	Vector sum = {a.x + b.x, a.y + b.y};
	return sum;
}

inlinable const Vector vec_mul(const Vector a, const Vector b) {
	Vector product = {a.x * b.x, a.y * b.y};
	return product;
}

/////

const double slope = dir.y / dir.x, inverse_slope = dir.x / dir.y;

const VectorF unit_step_size = { // vRayUnitStepSize
	// sqrt(1.0 + slope * slope), sqrt(1.0 + inverse_slope * inverse_slope)

	fabs(1 / dir.x), fabs(1 / dir.y)
};

/////

const VectorF unit_step_size = { fabs(1 / dir.x), fabs(1 / dir.y)}; // vRayUnitStepSize
VectorI current_tile = {floor(pos.x), floor(pos.y)}; // vMapCheck
VectorF ray_step, ray_length; // vStep, vRayLength1D

/////

int offset;
if (side_collision.x) offset = (int) (diff.x * (max_offset + 1)) & max_offset;
else offset = (int) (diff.y * (max_offset + 1)) & max_offset;

/////

// unsigned int screen_x = 0;

// for (double theta = player.angle - half_fov; theta < player.angle + half_fov; theta += theta_step) {

/////

// const double cos_theta, const double sin_theta, const double cos_beta) {

/////

theta_step = (double) fov / screen_width,

// half_fov = fov / 2.0,

/////