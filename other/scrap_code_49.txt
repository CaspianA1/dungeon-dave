if (hit[0] < 1.0 || hit[1] < 1.0 || hit[0] > current_level.map_width - 1.0
	|| hit[1] > current_level.map_height - 1.0) {
	printf("Escape\n");
	break;
}

/////

/*
Uint32* const src_row = (Uint32*) ((Uint8*) texture -> pixels + surface_offset.y * screen.pixel_pitch);
Uint32 src = *(src_row + surface_offset.x);
*/

/////

// #define VectorF_memset _mm_set1_pd
// #define VectorFF_add _mm_add_pd
// #define VectorFF_sub _mm_sub_pd
// #define VectorFF_mul _mm_mul_pd
// #define VectorFF_div _mm_div_pd

/////

typedef __m256d VectorF2; // four doubles

/////

return (DataDDA) {
	0.0, 0, 0, origin, dir, unit_step_size, ray_length, ray_step, curr_tile
};

/////

void fast_affine_floor(const vec pos, const double full_jump_height,
	const double pace, double y_shift, const int y_pitch) {

	const double opp_h = 0.5 + full_jump_height / settings.proj_dist;
	if (y_shift < 0.0) y_shift = 0.0;

	printf("---\n");
	// const long begin = y_shift;
	// const long other = (Uint8*) begin;

	// Uint32* row = (Uint32*) ((Uint8*) screen.pixels +  * screen.pixel_pitch);
	// const int row_step = y_shift * screen.pixel_pitch;

	const int pixbuf_row_step = (int) screen.pixel_pitch;
	Uint32* pixbuf_row = (Uint32*) ((Uint8*) screen.pixels + (int) (y_shift + 20) * screen.pixel_pitch);

	// `y_shift - pace` may go outside the map boundaries; limit this domain
	for (int y = y_shift - pace; y < settings.screen_height - pace; y++) {//, pixbuf_row += pixbuf_row_step) {
		const int pace_y = y + pace;

		const int row = y - settings.half_screen_height - y_pitch + 1;
		if (row == 0) continue;
		const double straight_dist = opp_h / row * settings.proj_dist;

		// Uint32* const pixbuf_row = (Uint32*) ((Uint8*) screen.pixels + pace_y * screen.pixel_pitch); // move this out
		// DEBUG((void*) pixbuf_row, p);

		for (int screen_x = 0; screen_x < settings.screen_width; screen_x += settings.ray_column_width) {
			if (screen.wall_bottom_buffer[screen_x] >= pace_y + 1) continue;

			const double actual_dist = straight_dist / screen.cos_beta_buffer[screen_x];
			const vec hit = vec_line_pos(pos, screen.dir_buffer[screen_x], actual_dist);
			const byte wall_point = map_point(current_level.wall_data, hit[0], hit[1]);
			if (current_level.get_point_height(wall_point, hit)) continue;

			draw_from_hit(hit, actual_dist, screen_x, pixbuf_row);
		}
	}
}

/////

/*
__m64 foo = {1};
__m64i bar;
__m128i baz;
__v1di a;
__v2si b;
__v4hi c;
__v8qi d;
*/

__v2si john = {1, 2, 3};
DEBUG(sizeof(john), zu);
DEBUG(sizeof(int), zu);

/////

typedef int ivec[2];
// typedef __v2si ivec;

/////

inlinable byte ivec_out_of_bounds(const ivec v) {
	return v.x < 0 || v.x > current_level.map_width - 1 || v.y < 0 || v.y > current_level.map_height - 1;
}

/////

/*
DEBUG(sizeof(DataDDA), zu);
DEBUG(sizeof(short), zu);
DEBUG(sizeof(int), zu);
DEBUG(sizeof(ivec), zu);
DEBUG(sizeof(int_fast16_t), zu);
*/

/////

// typedef int_fast16_t smallint;

/////

inlinable void fn_over_val_buffers(void* (*fn) (void*)) {
	const size_t sizes[4] = {sizeof(float), sizeof(float), sizeof(float), sizeof(vec)};
	const void* buffers[4] = {&val_buffers.depth, &val_buffers.cos_beta, &val_buffers.wall_bottom, &val_buffers.dir};
	for (byte i = 0; i < 4; i++) {
		buffers[i] = fn(buffers[i]);
	}
}

/////

/*
typedef struct {
	float *depth, *cos_beta, *wall_bottom;
	vec* dir;
} ValBuffers;
*/

/////

/*
val_buffers.depth = wrealloc(val_buffers.depth, new_width * sizeof(float));
val_buffers.cos_beta = wrealloc(val_buffers.cos_beta, new_width * sizeof(float));
val_buffers.wall_bottom = wrealloc(val_buffers.wall_bottom, new_width * sizeof(float));
val_buffers.dir = wrealloc(val_buffers.dir, new_width * sizeof(vec));
*/

/////

/*
const int // src_height can be divided to determine what fraction is shown at once
	src_y = skybox.max_height * (1.0 - look_up_percent),
	src_height = skybox.max_height * look_up_percent; // make more elegant
*/

int src_y, src_height;

if (keys[SDL_SCANCODE_T]) {
	src_height = skybox.max_height * look_up_percent;
	src_y = skybox.max_height - src_height;
}

else {
	src_y = skybox.max_height * (1.0 - look_up_percent);
	src_height = skybox.max_height * look_up_percent; // make more elegant
}

/////

// "../../Aseprite/Palace City Skybox.bmp"

/////

/*
// move this out of the loop
// Uint32* const pixbuf_row = (Uint32*) ((Uint8*) screen.pixels + pace_y * screen.pixel_pitch); 
const unsigned long readable_pixbuf_row = (unsigned long) pixbuf_row;
DEBUG(readable_pixbuf_row, lu);
*/

/*
Uint32* const reference_row = (Uint32*) ((Uint8*) screen.pixels + pace_y * screen.pixel_pitch); 
DEBUG((unsigned long) reference_row, lu);
DEBUG((unsigned long) pixbuf_row, lu);

unsigned long row_difference = (unsigned long) pixbuf_row - (unsigned long) reference_row;
DEBUG(row_difference, lu);
printf("-\n");
*/

/////