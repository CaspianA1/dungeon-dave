// const double sigma = 1.0 / 273.0; // std dev of this gaussian distribution

/*
const int kernel[5][5] = {
	{1, 4, 7, 4, 1},
	{4, 16, 26, 16, 4},
	{7, 26, 41, 26, 7},
	{4, 16, 26, 16, 4},
	{1, 4, 7, 4, 1}
};
*/

/////

// const double kernel_val = kernel[kernel_y_offset + 2][kernel_x_offset + 2];

/*
sum[0] += r * kernel_val;
sum[1] += g * kernel_val;
sum[2] += b * kernel_val;
*/

/////

/*
sum[0] *= sigma;
sum[1] *= sigma;
sum[2] *= sigma;
*/

/*
sum[0] /= 25;
sum[1] /= 25;
sum[2] /= 25;
*/

/////

inlinable Uint32* read_surface_pixel(const SDL_Surface* const surface, const int x, const int y, const int bpp) {
	return (Uint32*) ((Uint8*) surface -> pixels + y * surface -> pitch + x * bpp);
}

Uint32 getpixel(SDL_Surface *surface, const int x, const int y) {
   const int bpp = surface->format->BytesPerPixel;
   return (Uint32*) ((Uint8 *)surface->pixels + y * surface->pitch + x * bpp);

            return *(Uint32 *)p;
            break;

        default:
            return 0;       /* shouldn't happen, but avoids warnings */
      }
}

Uint32 get_gaussian_for_pixel(SDL_Surface* const mipmap, const int x, const int y) {
	// double sum[4] = {0.0, 0.0, 0.0};

	/*
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;
	*/

	return getpixel(mipmap, x, y);
	// return *read_surface_pixel(mipmap, x, y, bpp);

	/*
	for (int kernel_y_offset = -2; kernel_y_offset <= 2; kernel_y_offset++) {
		const int mipmap_y_offset = y + kernel_y_offset;
		if (mipmap_y_offset < 0 || mipmap_y_offset >= mipmap -> h) continue;

		for (int kernel_x_offset = -2; kernel_x_offset <= 2; kernel_x_offset++) {
			const int mipmap_x_offset = x + kernel_x_offset;
			if (mipmap_x_offset < 0 || mipmap_x_offset >= mipmap -> w) continue;

			Uint32* const pixel = read_surface_pixel(mipmap, x + kernel_x_offset, y + kernel_y_offset, bpp);

			byte r, g, b, a;
			SDL_GetRGBA(*pixel, mipmap -> format, &r, &g, &b, &a);

			sum[0] = r;
			sum[1] = g;
			sum[2] = b;
			sum[2] = a;
		}
	}

	sum[0] /= 8;
	sum[1] /= 8;
	sum[2] /= 8;

	return SDL_MapRGBA(format, sum[0], sum[1], sum[2], sum[3]);
	*/
}

/* https://aryamansharda.medium.com/image-filters-gaussian-blur-eb36db6781b1
https://computergraphics.stackexchange.com/questions/39/how-is-gaussian-blur-implemented */
void apply_gaussian_blur(SDL_Surface* mipmap, const SDL_Rect depth_crop, const byte save) {
	SDL_Surface* const blurred_dest = SDL_CreateRGBSurfaceWithFormat(0, depth_crop.w, depth_crop.h, 32, PIXEL_FORMAT);

	const int bpp = mipmap -> format -> BytesPerPixel;
	for (int y = depth_crop.y, dest_y = 0; y < depth_crop.y + depth_crop.h; y++, dest_y++) {
		for (int x = depth_crop.x, dest_x = 0; x < depth_crop.x + depth_crop.w; x++, dest_x++)
			*read_surface_pixel(blurred_dest, dest_x, dest_y, bpp) = get_gaussian_for_pixel(mipmap, x, y);
			// *getpixel(blurred_dest, x, y) = *getpixel(mipmap, x, y);
	}

	if (save) SDL_SaveBMP(blurred_dest, "out.bmp");
}

void gauss_test(void) {
	SDL_Surface* const image = SDL_LoadBMP("assets/walls/dirt.bmp");
	apply_gaussian_blur(image, (SDL_Rect) {0, 0, image -> w, image -> h}, 1);
	SDL_FreeSurface(image);
}

/////

// const Uint32 center = get_pixel(sfc_blur, x, y);
// const Uint32 alpha = (get_pixel(sfc_blur, x, y) & 0xFF000000) >> 31;
// const Uint32 alpha = 0xFF000000;
// how to extract the alpha channel?

// const Uint32 alpha = 0xFF000000;
// const Uint32 alpha = get_bits(get_pixel(sfc_blur, x, y), 0, 8);

// const Uint32 blurred_pixel = out[3] | (out[0] << 16) | (out [1] << 8) | out[2];

/////

/*
const byte
	r = (byte) (pixel >> 16),
	g = (byte) (pixel >> 8),
	b = (byte) pixel;
sum += (color) {r, g, b, 0xFF000000};
*/

/*
const byte
	r = get_bits(pixel, 16, 23),
	g = get_bits(pixel, 8, 15),
	b = get_bits(pixel, 0, 8);

sum += (color) {r, g, b, 0xFF000000};
*/

/////

/*
qsort;
heapsort;
radixsort;
psort;
mergesort;
setprogname;
*/

/////

/*
DEBUG_RECT(dest);
DEBUG(surface -> w, d);
DEBUG(surface -> h, d);
printf("-\n");
*/

/////

inlinable int ivec_ind(const ivec v, const byte i) {
	return i ? v.y : v.x;
}

/////

inlinable int* ivec_val(ivec* const v, const byte i) {
	return i ? &v -> y : &v -> x;
}

/////

/* a statemap is just a matrix of bits. I didn't call it
a bitmat because that sounds too much like bitmap.

also, a chunk is a 32-bit number. each chunk can hold 32 states. */

typedef uint32_t chunk_t;

typedef struct {
	ivec size;
	chunk_t* const data;
} StateMap;

/////

/*
const int num_bits_unpadded = width * height;
DEBUG(num_bits_unpadded, d);
const int num_bytes_unpadded = num_bits_unpadded / sizeof(chunk_t);
DEBUG(num_bytes_unpadded, d);
return (StateMap) {0};
*/

/*
const ivec dimensions_in_bytes = {
	width / sizeof(chunk_t),
	height / sizeof(chunk_t)
};

DEBUG(width * height, d);
DEBUG(width * height / sizeof(chunk_t), d);

DEBUG_IVEC(dimensions_in_bytes);

const size_t data_size = dimensions_in_bytes.x * dimensions_in_bytes.y / sizeof(chunk_t);
const StateMap statemap = {dimensions_in_bytes, calloc(data_size, sizeof(chunk_t))};
return statemap;
*/

/////

/*
// 00000000000000000000000000000000 = 32 zeros
print_bits(0b00000000000000000000000000000000);
putchar('\n');
*/

/*
for (size_t y = 0; y < statemap.size.y / sizeof(chunk_t); y++) {
	for (size_t x = 0; x < statemap.size.x / sizeof(chunk_t); x++) {
		const chunk_t chunk = statemap.data[y * statemap.size.x + x];
		print_bits(chunk);
		putchar('|');
	}
	putchar('\n');
}
*/

/////

/*
void statemap_test(void) {
	const StateMap statemap = init_statemap(20, 20); 
	print_statemap(statemap);

	exit(0);
}

bytes_across = 2
bytes_down = 2
total_bytes = 4
000000000|000000000|
000000000|000000000|
*/

/////

/*
const int total_bits = bits_across * bits_down;
DEBUG(total_bits, d);
const int total_bytes = ceil(total_bits / 8);
DEBUG(total_bytes, d);

StateMap statemap = {
	.byte_dimensions = {ceil(bits_across / 8.0), ceil(bits_down / 8.0)}
};

DEBUG_IVEC(statemap.byte_dimensions);

statemap.data = malloc(total_bytes);
memset(statemap.data, 0, total_bytes);

return statemap;
*/

/////