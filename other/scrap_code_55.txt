// const double sigma = 1.0 / 273.0; // std dev of this gaussian distribution

/*
const int kernel[5][5] = {
	{1, 4, 7, 4, 1},
	{4, 16, 26, 16, 4},
	{7, 26, 41, 26, 7},
	{4, 16, 26, 16, 4},
	{1, 4, 7, 4, 1}
};
*/

/////

// const double kernel_val = kernel[kernel_y_offset + 2][kernel_x_offset + 2];

/*
sum[0] += r * kernel_val;
sum[1] += g * kernel_val;
sum[2] += b * kernel_val;
*/

/////

/*
sum[0] *= sigma;
sum[1] *= sigma;
sum[2] *= sigma;
*/

/*
sum[0] /= 25;
sum[1] /= 25;
sum[2] /= 25;
*/

/////

inlinable Uint32* read_surface_pixel(const SDL_Surface* const surface, const int x, const int y, const int bpp) {
	return (Uint32*) ((Uint8*) surface -> pixels + y * surface -> pitch + x * bpp);
}

Uint32 getpixel(SDL_Surface *surface, const int x, const int y) {
   const int bpp = surface->format->BytesPerPixel;
   return (Uint32*) ((Uint8 *)surface->pixels + y * surface->pitch + x * bpp);

            return *(Uint32 *)p;
            break;

        default:
            return 0;       /* shouldn't happen, but avoids warnings */
      }
}

Uint32 get_gaussian_for_pixel(SDL_Surface* const mipmap, const int x, const int y) {
	// double sum[4] = {0.0, 0.0, 0.0};

	/*
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;
	*/

	return getpixel(mipmap, x, y);
	// return *read_surface_pixel(mipmap, x, y, bpp);

	/*
	for (int kernel_y_offset = -2; kernel_y_offset <= 2; kernel_y_offset++) {
		const int mipmap_y_offset = y + kernel_y_offset;
		if (mipmap_y_offset < 0 || mipmap_y_offset >= mipmap -> h) continue;

		for (int kernel_x_offset = -2; kernel_x_offset <= 2; kernel_x_offset++) {
			const int mipmap_x_offset = x + kernel_x_offset;
			if (mipmap_x_offset < 0 || mipmap_x_offset >= mipmap -> w) continue;

			Uint32* const pixel = read_surface_pixel(mipmap, x + kernel_x_offset, y + kernel_y_offset, bpp);

			byte r, g, b, a;
			SDL_GetRGBA(*pixel, mipmap -> format, &r, &g, &b, &a);

			sum[0] = r;
			sum[1] = g;
			sum[2] = b;
			sum[2] = a;
		}
	}

	sum[0] /= 8;
	sum[1] /= 8;
	sum[2] /= 8;

	return SDL_MapRGBA(format, sum[0], sum[1], sum[2], sum[3]);
	*/
}

/* https://aryamansharda.medium.com/image-filters-gaussian-blur-eb36db6781b1
https://computergraphics.stackexchange.com/questions/39/how-is-gaussian-blur-implemented */
void apply_gaussian_blur(SDL_Surface* mipmap, const SDL_Rect depth_crop, const byte save) {
	SDL_Surface* const blurred_dest = SDL_CreateRGBSurfaceWithFormat(0, depth_crop.w, depth_crop.h, 32, PIXEL_FORMAT);

	const int bpp = mipmap -> format -> BytesPerPixel;
	for (int y = depth_crop.y, dest_y = 0; y < depth_crop.y + depth_crop.h; y++, dest_y++) {
		for (int x = depth_crop.x, dest_x = 0; x < depth_crop.x + depth_crop.w; x++, dest_x++)
			*read_surface_pixel(blurred_dest, dest_x, dest_y, bpp) = get_gaussian_for_pixel(mipmap, x, y);
			// *getpixel(blurred_dest, x, y) = *getpixel(mipmap, x, y);
	}

	if (save) SDL_SaveBMP(blurred_dest, "out.bmp");
}

void gauss_test(void) {
	SDL_Surface* const image = SDL_LoadBMP("assets/walls/dirt.bmp");
	apply_gaussian_blur(image, (SDL_Rect) {0, 0, image -> w, image -> h}, 1);
	SDL_FreeSurface(image);
}

/////

// const Uint32 center = get_pixel(sfc_blur, x, y);
// const Uint32 alpha = (get_pixel(sfc_blur, x, y) & 0xFF000000) >> 31;
// const Uint32 alpha = 0xFF000000;
// how to extract the alpha channel?

// const Uint32 alpha = 0xFF000000;
// const Uint32 alpha = get_bits(get_pixel(sfc_blur, x, y), 0, 8);

// const Uint32 blurred_pixel = out[3] | (out[0] << 16) | (out [1] << 8) | out[2];

/////

/*
const byte
	r = (byte) (pixel >> 16),
	g = (byte) (pixel >> 8),
	b = (byte) pixel;
sum += (color) {r, g, b, 0xFF000000};
*/

/*
const byte
	r = get_bits(pixel, 16, 23),
	g = get_bits(pixel, 8, 15),
	b = get_bits(pixel, 0, 8);

sum += (color) {r, g, b, 0xFF000000};
*/

/////

/*
qsort;
heapsort;
radixsort;
psort;
mergesort;
setprogname;
*/

/////

/*
DEBUG_RECT(dest);
DEBUG(surface -> w, d);
DEBUG(surface -> h, d);
printf("-\n");
*/

/////

inlinable int ivec_ind(const ivec v, const byte i) {
	return i ? v.y : v.x;
}

/////

inlinable int* ivec_val(ivec* const v, const byte i) {
	return i ? &v -> y : &v -> x;
}

/////

/* a statemap is just a matrix of bits. I didn't call it
a bitmat because that sounds too much like bitmap.

also, a chunk is a 32-bit number. each chunk can hold 32 states. */

typedef uint32_t chunk_t;

typedef struct {
	ivec size;
	chunk_t* const data;
} StateMap;

/////

/*
const int num_bits_unpadded = width * height;
DEBUG(num_bits_unpadded, d);
const int num_bytes_unpadded = num_bits_unpadded / sizeof(chunk_t);
DEBUG(num_bytes_unpadded, d);
return (StateMap) {0};
*/

/*
const ivec dimensions_in_bytes = {
	width / sizeof(chunk_t),
	height / sizeof(chunk_t)
};

DEBUG(width * height, d);
DEBUG(width * height / sizeof(chunk_t), d);

DEBUG_IVEC(dimensions_in_bytes);

const size_t data_size = dimensions_in_bytes.x * dimensions_in_bytes.y / sizeof(chunk_t);
const StateMap statemap = {dimensions_in_bytes, calloc(data_size, sizeof(chunk_t))};
return statemap;
*/

/////

/*
// 00000000000000000000000000000000 = 32 zeros
print_bits(0b00000000000000000000000000000000);
putchar('\n');
*/

/*
for (size_t y = 0; y < statemap.size.y / sizeof(chunk_t); y++) {
	for (size_t x = 0; x < statemap.size.x / sizeof(chunk_t); x++) {
		const chunk_t chunk = statemap.data[y * statemap.size.x + x];
		print_bits(chunk);
		putchar('|');
	}
	putchar('\n');
}
*/

/////

/*
void statemap_test(void) {
	const StateMap statemap = init_statemap(20, 20); 
	print_statemap(statemap);

	exit(0);
}

bytes_across = 2
bytes_down = 2
total_bytes = 4
000000000|000000000|
000000000|000000000|
*/

/////

/*
const int total_bits = bits_across * bits_down;
DEBUG(total_bits, d);
const int total_bytes = ceil(total_bits / 8);
DEBUG(total_bytes, d);

StateMap statemap = {
	.byte_dimensions = {ceil(bits_across / 8.0), ceil(bits_down / 8.0)}
};

DEBUG_IVEC(statemap.byte_dimensions);

statemap.data = malloc(total_bytes);
memset(statemap.data, 0, total_bytes);

return statemap;
*/

/////

void statemap_test(void) {
	const StateMap statemap = init_statemap(32, 34); // 32 * 32 bits = 1024 bits = 256 bytes
	// *statemap_byte(statemap, 1, 1) = 0b11111111;
	// *statemap_byte(statemap, 2, 1) = 0b11111111;
	// set_statemap_bit(statemap, 17, 1);
	set_statemap_bit(statemap, 9, 31);

	print_statemap(statemap);

	exit(0);
}

/////

byte set_nth_bit_with_status(byte* const bits, const int bits_x, const int bits_y) {
	byte* const bits = statemap_byte(statemap, bits_x / 8, bits_y);
	const byte nth_bit = bits_x % 8;
	

	set_nth_bit(bits, nth_bit);

	/*
	// const byte status = nth_bit_is_set(*bits, n);
	set_nth_bit(bits, n);
	return status;
	*/
}

/////

void statemap_test(void) {
	StateMap statemap = init_statemap(32, 32);
	set_statemap_bit(statemap, 20, 0);
	printf("%d\n", statemap_bit_set(statemap, 20, 0));
	print_statemap(statemap);
	exit(0);
}

/////

DEBUG(red_fade, d);
DEBUG(black_fade_1, d);
DEBUG(black_fade_2, d);
printf("r = %d, g = %d, b = %d\n---\n", r, g, b);

/////

/*
const double sink_speed = 1.0 / log((*p_height - min_base_height_offset) - base_height);
*p_height += sink_speed;
*/

/*
const double sink_speed = ((*p_height - min_base_height_offset) - base_height) / 10.0;
*p_height -= sink_speed;
*angle += sink_speed * 360.0;
*/

/////

/*
const byte base_height = current_level.get_point_height(map_point(current_level.wall_data, pos[0], pos[1]), pos);
const double min_base_height_offset = -0.25 * (base_height + 1);
if (*p_height > base_height + min_base_height_offset) {
	const double sink_speed = (*p_height - min_base_height_offset - base_height) / 20.0;
	*p_height -= sink_speed;
	*angle += sink_speed * 360.0;
}

DEBUG(*p_height, lf);
*/

/////

// as val b4 = 12449 -> 12440 -> 12440 -> 12425 -> 12421 -> 12404

/////

/*
itinerary:
fast floor shading
non-clipping pathfinding
*/

///// the old get_wall_tex_offset:

const int max_offset = width - 1;

if (side) {
	const int x_offset = (hit[0] - (int) hit[0]) * max_offset;
	return (dir[1] > 0.0) ? max_offset - x_offset : x_offset;
}
else {
	const byte cond = keys[SDL_SCANCODE_C] ? (dir[0] < 0.0) : (dir[1] > 0.0);

	const int y_offset = (hit[1] - (int) hit[1]) * max_offset;
	return cond ? max_offset - y_offset : y_offset;
}

/////

/*
char percent_str[5]; // max 4 characters = 100% + null terminator
sprintf(percent_str, "%d%%", (byte) (hp / init_hp * 100));
const SDL_Color color = {toggle.r, toggle.g, toggle.b, SDL_ALPHA_OPAQUE};

const int avg_dimensions = (settings.screen_width + settings.screen_height) / 2;
TTF_Font* font = TTF_OpenFont(STD_GUI_FONT_PATH, avg_dimensions / 20);
SDL_Surface* const surface = TTF_RenderText_Solid(font, percent_str, color);
SDL_Texture* const texture = SDL_CreateTextureFromSurface(screen.renderer, surface);
SDL_RenderCopy(screen.renderer, texture, NULL, NULL);
*/

// when to free texture? thru fns init_hud_vals, reinit_hud_vals, and deinit_hud_vals?

/////

/*
SDL_Rect full_wall = {
	settings.screen_width - width_scale * cur, settings.screen_height - height_scale * 2,
	width_scale, height_scale
};

DEBUG_RECT(full_wall);

SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
SDL_RenderFillRect(screen.renderer, &full_wall);
*/

/*
const int x_add = settings.screen_width - minimap_width;
DEBUG(x_add, d);

DEBUG(minimap_width, d);
DEBUG(map_x * current_level.map_size.x);
*/

/////

/*
const int minimap_height = settings.screen_height / settings.minimap_scale;
const int minimap_top = settings.screen_height - minimap_height;

SDL_FRect test_rect = {300, minimap_top, 20, minimap_height};
SDL_RenderFillRectF(screen.renderer, &test_rect);
*/

/*
const SDL_Rect hp_box = {300, minimap_size[0], minimap_size, minimap_size[1]};
SDL_RenderCopy(screen.renderer, hud_resources.hp_texture, NULL, &hp_box);
o*/

/////