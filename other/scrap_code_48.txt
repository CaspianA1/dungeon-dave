/*
const byte point =
	(hit[0] < 0.0 || hit[1] < 0.0 || hit[0] > current_level.map_width - 1.0 || hit[1] > current_level.map_height - 1.0)
	? current_level.out_of_bounds_point : map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
*/

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

inlinable Uint32 shade_ARGB_pixel(const VectorF hit, const double actual_dist) {
	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	const byte r = (hit >> 16) & r_mask, g = (hit >> 8) & g_mask, b = hit & b_mask;

	const byte shaded_r = r * 
}

inlinable void draw_from_hit(const VectorF hit, const double actual_dist, const int screen_x, const int pace_y) {
	const VectorI floored_hit = VectorF_floor(hit);

	const byte point = map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
	const SDL_Surface* const surface = current_level.walls[point - 1].surface;
	const int max_offset = surface -> w - 1;

	const VectorI surface_offset = {
		(hit[0] - floored_hit.x) * max_offset,
		(hit[1] - floored_hit.y) * max_offset
	};

	Uint32 src = get_surface_pixel(surface -> pixels, surface -> pitch, surface_offset.x, surface_offset.y);

	#ifdef SHADING_ENABLED
	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);

	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	// const byte r = get_bits(src, 16, 23) * shade, g = get_bits(src, 8, 15) * shade, b = get_bits(src, 0, 8) * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;
	#else
	(void) actual_dist;
	#endif

/////

inlinable Uint32* get_pixbuf_row(const int y) { // for texture
	return ((Uint32*) ((Uint8*) screen.pixels + y * screen.pixel_pitch));
}

/////

const SDL_FRect screen_pos = {
	pace,
	fabs(pace) + (y_pitch < 0 ? 0 : y_pitch) +
	settings.screen_height * screen_y_shift_percent_down,
	settings.screen_width,
	settings.screen_height
};

/////

/*
inlinable VectorI VectorF_round(const VectorF vf) {
	return (VectorI) {(int) round(vf[0]), (int) round(vf[1])};
}
*/

/////

/*
// draw_ceiling_plane(player);
draw_floor_plane(player); // fix
refresh_and_clear_temp_buf();
*/

/////

// https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-28-graphics-pipeline-performance

/////

/*
DEBUG(y_shift, lf);
const SDL_FRect to_draw = {0, y_shift - pace, settings.screen_width, settings.screen_height - pace};
DEBUG_FRECT(to_draw);

y = y_shift - pace
e = scr_height - pace

h = e - y
h = (scr_height - pace) - (y_shift - pace)
h = scr_height - pace - y_shift + pace
h = scr_height - y_shift
*/

/////

// const SDL_Rect pixbuf_draw_region = {0, y_shift - pace, settings.screen_width, settings.screen_height - y_shift};
// const SDL_Rect pixbuf_draw_region = {0, settings.half_screen_width, settings.screen_width, settings.screen_height};
// const SDL_Rect pixbuf_draw_region = {0, y_shift - pace, settings.screen_width, settings.screen_height};

/////

printf("pixbuf_draw_region = {%d, %d, %d, %d}\n",
	pixbuf_draw_region.x, pixbuf_draw_region.y, pixbuf_draw_region.w, pixbuf_draw_region.h);

/////

// SDL_SetRenderDrawColor(screen.renderer, toggle.r * shade, toggle.g * shade, toggle.b * shade, SDL_ALPHA_OPAQUE);
/*
wall.x = map_x * width_scale;
wall.y = map_y * height_scale;
*/
// SDL_RenderFillRect(screen.renderer, &wall);

/////

/*
GUI gui = {
	.num_messages = num_messages,
	has_sprite_background,
	msg_color,
	
	messages,
	wmalloc(num_messages * sizeof(Message)),
	font, {
		.msg_color = msg_color,
		.background = {background_r, background_g, background_b, SDL_ALPHA_OPAQUE},
		.border = {border_r, border_g, border_b, SDL_ALPHA_OPAQUE}
	}
};
*/

/////

/*
gui.background.whole_colors = {
	.center = {
		va_arg(gui_data, unsigned),
		va_arg(gui_data, unsigned),
		va_arg(gui_data, unsigned),
		SDL_ALPHA_OPAQUE
	},
	.border = {
		va_arg(gui_data, unsigned),
		va_arg(gui_data, unsigned),
		va_arg(gui_data, unsigned),
		SDL_ALPHA_OPAQUE
	}
};
*/

/////

/*
int SDL_QueryTexture(SDL_Texture * texture,
                     Uint32 * format, int *access,
                     int *w, int *h);
*/

SDL_TextureAccess access;
int a = SDL_QueryTexture(s.texture, screen.pixel_format, &access, NULL, NULL);
DEBUG(a, d);
DEBUG(access, d);

/////

#define VectorF2_memset _mm256_set1_pd
#define VectorFF2_add _mm256_add_pd
#define VectorFF2_mul _mm256_mul_pd

// http://ftp.neutrino.es/x86InstructionSet/VINSERTF128.html
inlinable VectorF2 VectorF2_line_pos(const VectorF pos, const VectorF dir, const VectorF slopes) {
	const VectorF2
		slopes_as_vec2 = {slopes[0], slopes[0], slopes[1], slopes[1]},
		dir_as_vec2 = {dir[0], dir[1], dir[0], dir[1]},
		pos_as_vec2 = {pos[0], pos[1], pos[0], pos[1]};

	return VectorFF2_add(VectorFF2_mul(dir_as_vec2, slopes_as_vec2), pos_as_vec2);
}

/*
vector operations needed:
	subtraction of int-based vectors (not together): {a[0] - b[0], a[1] - b[1]}
	distance: sqrt(a[0] * a[0] + b[1] * b[1])
	
	texture offset: {a[0] - floor(a[0]) * m, a[1] - floor(a[1]) * m}
	unit step size: {fabs(1.0 / a[0]), fabs(1.0 / a[1])}
	truncation: {(int) floor(a[0]), (int) floor(a[1])}
	delta between floating-point and int-based vectors: {fabs(v[0] - i[0]), fabs(v[1] - i[1])}

	handy functions: https://chryswoods.com/vector_c++/emmintrin.html

	also, make VectorI to an intrinsic at some point (need the right type first)

done:
	subtraction of floating-point vectors
	ray equation: {a[0] * d + p[0], a[1] * d + p[1]}
*/

///// 36,000 bytes for all buffers

size_t a = sizeof(float) + sizeof(double) + sizeof(double) + sizeof(VectorF);
size_t b = a * settings.screen_width;
DEBUG(b, zu);

/////

byte r, g, b;

if (keys[SDL_SCANCODE_F])
	r = (byte) (src >> 16) * shade,
	g = (byte) (src >> 8) * shade,
	b = (byte) src * shade;
else
	r = get_bits(src, 16, 23) * shade,
	g = get_bits(src, 8, 15) * shade,
	b = get_bits(src, 0, 8) * shade;

// const byte r = get_bits(src, 16, 23) * shade, g = get_bits(src, 8, 15) * shade, b = get_bits(src, 0, 8) * shade;

/////