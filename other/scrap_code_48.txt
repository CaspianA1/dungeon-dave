/*
const byte point =
	(hit[0] < 0.0 || hit[1] < 0.0 || hit[0] > current_level.map_width - 1.0 || hit[1] > current_level.map_height - 1.0)
	? current_level.out_of_bounds_point : map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
*/

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

inlinable Uint32 shade_ARGB_pixel(const VectorF hit, const double actual_dist) {
	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	const byte r = (hit >> 16) & r_mask, g = (hit >> 8) & g_mask, b = hit & b_mask;

	const byte shaded_r = r * 
}

inlinable void draw_from_hit(const VectorF hit, const double actual_dist, const int screen_x, const int pace_y) {
	const VectorI floored_hit = VectorF_floor(hit);

	const byte point = map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
	const SDL_Surface* const surface = current_level.walls[point - 1].surface;
	const int max_offset = surface -> w - 1;

	const VectorI surface_offset = {
		(hit[0] - floored_hit.x) * max_offset,
		(hit[1] - floored_hit.y) * max_offset
	};

	Uint32 src = get_surface_pixel(surface -> pixels, surface -> pitch, surface_offset.x, surface_offset.y);

	#ifdef SHADING_ENABLED
	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);

	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	// const byte r = get_bits(src, 16, 23) * shade, g = get_bits(src, 8, 15) * shade, b = get_bits(src, 0, 8) * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;
	#else
	(void) actual_dist;
	#endif

/////