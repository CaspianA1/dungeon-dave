/*
const byte point =
	(hit[0] < 0.0 || hit[1] < 0.0 || hit[0] > current_level.map_width - 1.0 || hit[1] > current_level.map_height - 1.0)
	? current_level.out_of_bounds_point : map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
*/

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

/////

inlinable byte get_bits(const Uint32 value, const byte offset, const byte n) {
	return (value >> offset) & ((1 << n) - 1);
}

inlinable Uint32 shade_ARGB_pixel(const VectorF hit, const double actual_dist) {
	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	const byte r = (hit >> 16) & r_mask, g = (hit >> 8) & g_mask, b = hit & b_mask;

	const byte shaded_r = r * 
}

inlinable void draw_from_hit(const VectorF hit, const double actual_dist, const int screen_x, const int pace_y) {
	const VectorI floored_hit = VectorF_floor(hit);

	const byte point = map_point(current_level.floor_data, floored_hit.x, floored_hit.y);
	const SDL_Surface* const surface = current_level.walls[point - 1].surface;
	const int max_offset = surface -> w - 1;

	const VectorI surface_offset = {
		(hit[0] - floored_hit.x) * max_offset,
		(hit[1] - floored_hit.y) * max_offset
	};

	Uint32 src = get_surface_pixel(surface -> pixels, surface -> pitch, surface_offset.x, surface_offset.y);

	#ifdef SHADING_ENABLED
	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);

	static const byte
		r_mask = (byte) (1 << 23) - 1,
		g_mask = (byte) (1 << 15) - 1,
		b_mask = (byte) (1 << 8) - 1;

	// const byte r = get_bits(src, 16, 23) * shade, g = get_bits(src, 8, 15) * shade, b = get_bits(src, 0, 8) * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;
	#else
	(void) actual_dist;
	#endif

/////

inlinable Uint32* get_pixbuf_row(const int y) { // for texture
	return ((Uint32*) ((Uint8*) screen.pixels + y * screen.pixel_pitch));
}

/////

const SDL_FRect screen_pos = {
	pace,
	fabs(pace) + (y_pitch < 0 ? 0 : y_pitch) +
	settings.screen_height * screen_y_shift_percent_down,
	settings.screen_width,
	settings.screen_height
};

/////

/*
inlinable VectorI VectorF_round(const VectorF vf) {
	return (VectorI) {(int) round(vf[0]), (int) round(vf[1])};
}
*/

/////

/*
// draw_ceiling_plane(player);
draw_floor_plane(player); // fix
refresh_and_clear_temp_buf();
*/

/////

// https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-28-graphics-pipeline-performance

/////

/*
DEBUG(y_shift, lf);
const SDL_FRect to_draw = {0, y_shift - pace, settings.screen_width, settings.screen_height - pace};
DEBUG_FRECT(to_draw);

y = y_shift - pace
e = scr_height - pace

h = e - y
h = (scr_height - pace) - (y_shift - pace)
h = scr_height - pace - y_shift + pace
h = scr_height - y_shift
*/

/////

// const SDL_Rect pixbuf_draw_region = {0, y_shift - pace, settings.screen_width, settings.screen_height - y_shift};
// const SDL_Rect pixbuf_draw_region = {0, settings.half_screen_width, settings.screen_width, settings.screen_height};
// const SDL_Rect pixbuf_draw_region = {0, y_shift - pace, settings.screen_width, settings.screen_height};

/////

printf("pixbuf_draw_region = {%d, %d, %d, %d}\n",
	pixbuf_draw_region.x, pixbuf_draw_region.y, pixbuf_draw_region.w, pixbuf_draw_region.h);

/////