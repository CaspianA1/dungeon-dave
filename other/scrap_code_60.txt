// figure out why there is no red when the player height is 0
void draw_at_height_change(const int screen_x, const double last_wall_top, const double curr_wall_bottom, const byte point_height) {
	// from curr wall bottom (farther away) to last wall top

	if (last_wall_top < curr_wall_bottom) return;

	void draw_colored_rect(const byte, const byte, const byte, const double, const SDL_Rect* const);


	// if (screen_x == 200) {
	if (1) {
		SDL_SetRenderDrawColor(screen.renderer, (point_height == 1) ? 120 : 255, 0, 0, SDL_ALPHA_OPAQUE);
		SDL_RenderDrawLine(screen.renderer, screen_x, curr_wall_bottom, screen_x, last_wall_top);

		const SDL_Rect curr_wall_bottom_dot = {screen_x, curr_wall_bottom, 5, 5};
		draw_colored_rect(255, 165, 0, 1.0, &curr_wall_bottom_dot);

		const SDL_Rect last_wall_top_dot = {screen_x, last_wall_top, 5, 5};
		draw_colored_rect(0, 255, 0, 1.0, &last_wall_top_dot);
	}
}

// draw_at_height_change(screen_x, last_wall_top, height_change_y + height_change_h, point_height);

/////

// draw_at_height_change(screen_x, last_wall_top, height_change_y + height_change_h, point_height);

/////

static byte alpha = 0;

while (1) {
	if (keys[SDL_SCANCODE_T]) alpha++;
	if (keys[SDL_SCANCODE_Y]) alpha--;
	// SDL_SetTextureAlphaMod(current_level.walls[0].texture, alpha);
	SDL_SetTextureAlphaMod(enemies[0].animation_data.sprite.texture, alpha);

///// Y-shift vertical aim testing:

/*
y shift measurement:

640 x 480:
45 degrees = 0.64666 of total down look
1 degree = 0.0006958834627161104 of total down look

for full screen, 45 degrees = close to 0.78 of total down look

---

- the percentage of down look depends on the screen size, which is frustrating
- moving half of a wall unit down when 1 unit away from the wall = 45 degrees
- find how far I have looked down the wall
- the taller the screen, the larger angle range, so the percentage is not important, just the amount
*/

int main(void) {
	Player player;
	Weapon weapon;
	load_all_defaults(load_level_1, &player, &weapon);

	if (display_title_screen() == Exit) deinit_all(&player, &weapon);
	play_sound(&current_level.background_sound, 1);
	p = init_psprite("assets/walls/dune.bmp");

	while (1) {
		const Uint32 before = SDL_GetTicks();
		if (keys[SDL_SCANCODE_C]) DEBUG_VEC(player.pos);

		/*
		if (keys[SDL_SCANCODE_T]) {
			player.pos = (vec) {round(player.pos[0]), round(player.pos[1])};
		}
		*/

		const InputStatus input_status = handle_input(&player, player.is_dead);
		if (input_status == Exit) deinit_all(&player, &weapon);

		update_screen_dimensions(&player.y_pitch, player.mouse_pos.y);

		const double wall_y_shift = settings.half_screen_height + player.y_pitch + player.pace.screen_offset;

		/*
		//////////
		player.pace.screen_offset = 0;
		const double wall_y_shift = settings.half_screen_height + player.y_pitch + player.pace.screen_offset;
		const double y_shift = wall_y_shift - settings.half_screen_height;
		const double y_shift_percent = -y_shift / settings.half_screen_height;
		DEBUG(y_shift_percent, lf);
		//////////
		*/

		prepare_for_drawing();
		draw_skybox(player.angle, wall_y_shift);
		// draw_colored_floor(wall_y_shift);

		#ifndef PLANAR_MODE
		const double full_jump_height = player.jump.height * settings.screen_height; // screen height b/c height is vertical
		raycast(&player, wall_y_shift, full_jump_height);

		draw_things(&player, wall_y_shift);

		#ifndef DISABLE_ENEMIES
		if (!player.is_dead) update_all_enemy_instances(&player, &weapon);
		#endif

		use_weapon_if_needed(&weapon, &player, input_status);
		#else
		fill_val_buffers_for_planar_mode(player.angle);
		#endif

		if (player.is_dead && death_effect(&player))
			deinit_all(&player, &weapon);

		fast_affine_floor(0, player.pos, player.jump.height, player.pace.screen_offset, wall_y_shift, player.y_pitch);

		teleport_player_if_needed(&player);

		/*
		//////////
		SDL_Rect center_line = {0, settings.half_screen_height, settings.screen_width, 5};
		draw_colored_rect(255, 0, 0, 1.0, &center_line);
		//////////
		*/

		refresh(&player, wall_y_shift);
		tick_delay(before);
	}
}

///// An old image blurrer:

/*
void blur_portion_2(SDL_Surface* const image, SDL_Rect crop, const int blur_size) {
	SDL_Surface* const blurred_crop = SDL_CreateRGBSurfaceWithFormat(0, crop.w, crop.h, 32, PIXEL_FORMAT);
	SDL_LockSurface(blurred_crop);
	SDL_LockSurface(image);

	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;
 	for (int y = crop.y; y < crop.y + crop.h; y++) {
		for (int x = crop.x; x < crop.x + crop.w; x++) {
			const color4 sum =
				rgba_from_pixel(image, x - 1, y + 1) +
				rgba_from_pixel(image, x + 0, y + 1) +
				rgba_from_pixel(image, x + 1, y + 1) +
				rgba_from_pixel(image, x - 1, y + 0) +
				rgba_from_pixel(image, x + 0, y + 0) +
				rgba_from_pixel(image, x + 1, y + 0) +
				rgba_from_pixel(image, x - 1, y - 1) +
				rgba_from_pixel(image, x + 0, y - 1) +
				rgba_from_pixel(image, x + 1, y - 1);

			byte out[4] = {
				sum[0] / 9,
				sum[1] / 9,
				sum[2] / 9,
				sum[3] / 9
			};

			// if (out[0] == 0 && out[1] == 0 && out[2] == 0 && out[3] == 0) {
				// printf("RGBA is zeroes. dest x = %d, dest y = %d for crop size {%d, %d}\n", x - crop.x, y - crop.y, crop.w, crop.h);
			// }

			// out[0] = 0;
			// out[1] = 0;
			// out[2] = 0;
			// out[3] = 0;

			// printf("out = {%d, %d, %d, %d}\n", out[0], out[1], out[2], out[3]);

			const Uint32 blurred_pixel = SDL_MapRGBA(format, out[0], out[1], out[2], out[3]); 
			*read_surface_pixel(blurred_crop, x - crop.x, y - crop.y, bpp) = blurred_pixel;

		}
	}

	SDL_UnlockSurface(blurred_crop);
	SDL_UnlockSurface(image);

	// system("mkdir imgs");
	// static byte id = 0;
	// char buf[16];
	// sprintf(buf, "imgs/out_%d.bmp", id);
	// SDL_SaveBMP(blurred_crop, buf);
	// id++;

	SDL_BlitSurface(blurred_crop, NULL, image, &crop);
	SDL_FreeSurface(blurred_crop);
}
*/

///// An old, not used function:

typedef __v4si color4;

color4 rgba_from_pixel(const SDL_Surface* const image, int x, int y) {
	if (x < 0) x = 0;
	else if (x >= image -> w) x = image -> w - 1;

	if (y < 0) y = 0;
	else if (y >= image -> h) y = image -> h - 1;

	const SDL_PixelFormat* const format = image -> format;
	const Uint32 pixel = *read_surface_pixel(image, x, y, format -> BytesPerPixel);
	byte r, g, b, a;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return (color4) {r, g, b, a};
}

/////

/*
printf("kernel = {\n\t{%lf, %lf, %lf},\n\t{%lf, %lf, %lf},\n\t{%lf, %lf, %lf}\n}\n",
	kernel[0][0], kernel[0][1], kernel[0][2],
	kernel[1][0], kernel[1][1], kernel[1][2],
	kernel[2][0], kernel[2][1], kernel[2][2]);
*/

/////