// figure out why there is no red when the player height is 0
void draw_at_height_change(const int screen_x, const double last_wall_top, const double curr_wall_bottom, const byte point_height) {
	// from curr wall bottom (farther away) to last wall top

	if (last_wall_top < curr_wall_bottom) return;

	void draw_colored_rect(const byte, const byte, const byte, const double, const SDL_Rect* const);


	// if (screen_x == 200) {
	if (1) {
		SDL_SetRenderDrawColor(screen.renderer, (point_height == 1) ? 120 : 255, 0, 0, SDL_ALPHA_OPAQUE);
		SDL_RenderDrawLine(screen.renderer, screen_x, curr_wall_bottom, screen_x, last_wall_top);

		const SDL_Rect curr_wall_bottom_dot = {screen_x, curr_wall_bottom, 5, 5};
		draw_colored_rect(255, 165, 0, 1.0, &curr_wall_bottom_dot);

		const SDL_Rect last_wall_top_dot = {screen_x, last_wall_top, 5, 5};
		draw_colored_rect(0, 255, 0, 1.0, &last_wall_top_dot);
	}
}

// draw_at_height_change(screen_x, last_wall_top, height_change_y + height_change_h, point_height);

/////

// draw_at_height_change(screen_x, last_wall_top, height_change_y + height_change_h, point_height);

/////

static byte alpha = 0;

while (1) {
	if (keys[SDL_SCANCODE_T]) alpha++;
	if (keys[SDL_SCANCODE_Y]) alpha--;
	// SDL_SetTextureAlphaMod(current_level.walls[0].texture, alpha);
	SDL_SetTextureAlphaMod(enemies[0].animation_data.sprite.texture, alpha);

///// Y-shift vertical aim testing:

/*
y shift measurement:

640 x 480:
45 degrees = 0.64666 of total down look
1 degree = 0.0006958834627161104 of total down look

for full screen, 45 degrees = close to 0.78 of total down look

---

- the percentage of down look depends on the screen size, which is frustrating
- moving half of a wall unit down when 1 unit away from the wall = 45 degrees
- find how far I have looked down the wall
- the taller the screen, the larger angle range, so the percentage is not important, just the amount
*/

int main(void) {
	Player player;
	Weapon weapon;
	load_all_defaults(load_level_1, &player, &weapon);

	if (display_title_screen() == Exit) deinit_all(&player, &weapon);
	play_sound(&current_level.background_sound, 1);
	p = init_psprite("assets/walls/dune.bmp");

	while (1) {
		const Uint32 before = SDL_GetTicks();
		if (keys[SDL_SCANCODE_C]) DEBUG_VEC(player.pos);

		/*
		if (keys[SDL_SCANCODE_T]) {
			player.pos = (vec) {round(player.pos[0]), round(player.pos[1])};
		}
		*/

		const InputStatus input_status = handle_input(&player, player.is_dead);
		if (input_status == Exit) deinit_all(&player, &weapon);

		update_screen_dimensions(&player.y_pitch, player.mouse_pos.y);

		const double wall_y_shift = settings.half_screen_height + player.y_pitch + player.pace.screen_offset;

		/*
		//////////
		player.pace.screen_offset = 0;
		const double wall_y_shift = settings.half_screen_height + player.y_pitch + player.pace.screen_offset;
		const double y_shift = wall_y_shift - settings.half_screen_height;
		const double y_shift_percent = -y_shift / settings.half_screen_height;
		DEBUG(y_shift_percent, lf);
		//////////
		*/

		prepare_for_drawing();
		draw_skybox(player.angle, wall_y_shift);
		// draw_colored_floor(wall_y_shift);

		#ifndef PLANAR_MODE
		const double full_jump_height = player.jump.height * settings.screen_height; // screen height b/c height is vertical
		raycast(&player, wall_y_shift, full_jump_height);

		draw_things(&player, wall_y_shift);

		#ifndef DISABLE_ENEMIES
		if (!player.is_dead) update_all_enemy_instances(&player, &weapon);
		#endif

		use_weapon_if_needed(&weapon, &player, input_status);
		#else
		fill_val_buffers_for_planar_mode(player.angle);
		#endif

		if (player.is_dead && death_effect(&player))
			deinit_all(&player, &weapon);

		fast_affine_floor(0, player.pos, player.jump.height, player.pace.screen_offset, wall_y_shift, player.y_pitch);

		teleport_player_if_needed(&player);

		/*
		//////////
		SDL_Rect center_line = {0, settings.half_screen_height, settings.screen_width, 5};
		draw_colored_rect(255, 0, 0, 1.0, &center_line);
		//////////
		*/

		refresh(&player, wall_y_shift);
		tick_delay(before);
	}
}

///// An old image blurrer:

/*
void blur_portion_2(SDL_Surface* const image, SDL_Rect crop, const int blur_size) {
	SDL_Surface* const blurred_crop = SDL_CreateRGBSurfaceWithFormat(0, crop.w, crop.h, 32, PIXEL_FORMAT);
	SDL_LockSurface(blurred_crop);
	SDL_LockSurface(image);

	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;
 	for (int y = crop.y; y < crop.y + crop.h; y++) {
		for (int x = crop.x; x < crop.x + crop.w; x++) {
			const color4 sum =
				rgba_from_pixel(image, x - 1, y + 1) +
				rgba_from_pixel(image, x + 0, y + 1) +
				rgba_from_pixel(image, x + 1, y + 1) +
				rgba_from_pixel(image, x - 1, y + 0) +
				rgba_from_pixel(image, x + 0, y + 0) +
				rgba_from_pixel(image, x + 1, y + 0) +
				rgba_from_pixel(image, x - 1, y - 1) +
				rgba_from_pixel(image, x + 0, y - 1) +
				rgba_from_pixel(image, x + 1, y - 1);

			byte out[4] = {
				sum[0] / 9,
				sum[1] / 9,
				sum[2] / 9,
				sum[3] / 9
			};

			// if (out[0] == 0 && out[1] == 0 && out[2] == 0 && out[3] == 0) {
				// printf("RGBA is zeroes. dest x = %d, dest y = %d for crop size {%d, %d}\n", x - crop.x, y - crop.y, crop.w, crop.h);
			// }

			// out[0] = 0;
			// out[1] = 0;
			// out[2] = 0;
			// out[3] = 0;

			// printf("out = {%d, %d, %d, %d}\n", out[0], out[1], out[2], out[3]);

			const Uint32 blurred_pixel = SDL_MapRGBA(format, out[0], out[1], out[2], out[3]); 
			*read_surface_pixel(blurred_crop, x - crop.x, y - crop.y, bpp) = blurred_pixel;

		}
	}

	SDL_UnlockSurface(blurred_crop);
	SDL_UnlockSurface(image);

	// system("mkdir imgs");
	// static byte id = 0;
	// char buf[16];
	// sprintf(buf, "imgs/out_%d.bmp", id);
	// SDL_SaveBMP(blurred_crop, buf);
	// id++;

	SDL_BlitSurface(blurred_crop, NULL, image, &crop);
	SDL_FreeSurface(blurred_crop);
}
*/

///// An old, not used function:

typedef __v4si color4;

color4 rgba_from_pixel(const SDL_Surface* const image, int x, int y) {
	if (x < 0) x = 0;
	else if (x >= image -> w) x = image -> w - 1;

	if (y < 0) y = 0;
	else if (y >= image -> h) y = image -> h - 1;

	const SDL_PixelFormat* const format = image -> format;
	const Uint32 pixel = *read_surface_pixel(image, x, y, format -> BytesPerPixel);
	byte r, g, b, a;
	SDL_GetRGBA(pixel, format, &r, &g, &b, &a);
	return (color4) {r, g, b, a};
}

/////

/*
printf("kernel = {\n\t{%lf, %lf, %lf},\n\t{%lf, %lf, %lf},\n\t{%lf, %lf, %lf}\n}\n",
	kernel[0][0], kernel[0][1], kernel[0][2],
	kernel[1][0], kernel[1][1], kernel[1][2],
	kernel[2][0], kernel[2][1], kernel[2][2]);
*/

///// Overengineered:

typedef struct {
	const byte axis;
	const int boundary, out_of_bounds_move;
} MouseBound;

const MouseBound mouse_bounds[4] = {
	{0, settings.screen_width - 1, 1}, // if mouse on right edge, move to left edge
	{0, 0, settings.screen_width - 1}, // if mouse on left edge, move to right edge
	{1, 0, 0}, // if mouse on top edge, stay there
	{1, settings.screen_height - 1, settings.screen_height - 1} // if mouse on bottom edge, stay there
};

byte axes_checked[2] = {0, 0};

for (byte i = 0; i < 4; i++) {
	const MouseBound bound = mouse_bounds[i];
	if (axes_checked[bound.axis]) continue;

	const int pos_component_to_check = bound.axis ? mouse_pos -> y : mouse_pos -> x;

	if (*pos_component_to_check == bound.boundary) {
		printf("Met boundary for axis %d, for boundary %d, so moving to %d\n",
			bound.axis, bound.boundary, bound.out_of_bounds_move);

		// SDL_WarpMouseInWindow(screen.window, )
		if (bound.axis) {
			SDL_WarpMouseInWindow(screen.window, _, _);
		}

		// *pos_component_to_check = bound.out_of_bounds_move;

		axes_checked[bound.axis] = 1;
	}
}

/*
if (mouse_pos -> x == settings.screen_width - 1)
	SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
else if (mouse_pos -> x == 0)
	SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
*/

//////////

/////

inlinable void update_mouse_and_theta(double* const theta, ivec* const mouse_pos) {

	/*
	const int prev_mouse_x = mouse_pos -> x;
	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);

	if (prev_mouse_x == mouse_pos -> x) return;

	*theta = (double) mouse_pos -> x / settings.screen_width * 360.0;

	if (mouse_pos -> x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
	*/

	// mouse y locking is not working
	// SDL_SetRelativeMouseMode(SDL_TRUE);

	/*
	if (mouse_pos -> y == settings.screen_height - 1)
		SDL_WarpMouseInWindow(screen.window, mouse_pos -> x, settings.screen_height - 2);
	else if (mouse_pos -> y < 5) {
		printf("Warping from 0 to 1\n");
		SDL_WarpMouseInWindow(screen.window, mouse_pos -> x, 5);
	}
	*/
}

/////

inlinable void update_mouse_and_theta_and_y_pitch(double* const theta, int* const y_pitch, ivec* const _mouse_pos) {
	(void) theta;
	(void) _mouse_pos;

	SDL_SetRelativeMouseMode(SDL_TRUE);

	/*
	ivec mouse_pos;
	SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);

	if (mouse_pos.x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos.y);
	else if (mouse_pos.x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos.y);

	if (mouse_pos.y == 0) {
		SDL_SetRelativeMouseMode(SDL_TRUE);
		// SDL_WarpMouseInWindow(screen.window, mouse_pos.x, 20);
	}
	else
		SDL_SetRelativeMouseMode(SDL_FALSE);

	DEBUG_IVEC(mouse_pos);

	*y_pitch = -mouse_pos.y + settings.half_screen_height;
	*/

	/*
	DEBUG_IVEC(mouse_pos);

	if (keys[SDL_SCANCODE_G]) {
		puts("Warping");
		SDL_WarpMouseInWindow(screen.window, 0, 0);
	}
	*/

	/*
	const int prev_mouse_x = mouse_pos -> x;
	SDL_GetMouseState(&mouse_pos -> x, &mouse_pos -> y);

	if (prev_mouse_x == mouse_pos -> x) return;

	*theta = (double) mouse_pos -> x / settings.screen_width * 360.0;

	if (mouse_pos -> x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos -> y);
	else if (mouse_pos -> x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos -> y);
	*/

	// mouse y locking is not working
	// SDL_SetRelativeMouseMode(SDL_TRUE);

	/*
	if (mouse_pos -> y == settings.screen_height - 1)
		SDL_WarpMouseInWindow(screen.window, mouse_pos -> x, settings.screen_height - 2);
	else if (mouse_pos -> y < 5) {
		printf("Warping from 0 to 1\n");
		SDL_WarpMouseInWindow(screen.window, mouse_pos -> x, 5);
	}
	*/
}

/////

inlinable void update_mouse_and_theta_and_y_pitch(double* const theta, int* const y_pitch, ivec* const _mouse_pos) {
	(void) theta;
	(void) y_pitch;
	(void) _mouse_pos;

	// SDL_SetWindowGrab(screen.window, !keys[KEY_ESCAPE_WINDOW]);

	ivec mouse_pos;
	SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);
	DEBUG_IVEC(mouse_pos);

	// SDL_SetRelativeMouseMode(SDL_TRUE);
}

/////

inlinable void update_mouse_and_theta_and_y_pitch(double* const theta, int* const y_pitch, ivec* const _mouse_pos) {
	printf("Checking\n");

	/*
	static Toggle toggle = {0, 0, KEY_ESCAPE_WINDOW};\
	if (!update_toggle(&toggle)) {
		printf("Should not escape window\n");
		return;
	}
	*/

	toggledef(KEY_ESCAPE_WINDOW, 0); // if can escape window, don't control anything

	DEBUG(toggle.enabled, d);

	printf("Should escape window\n");

	(void) theta;
	(void) y_pitch;
	(void) _mouse_pos;

	ivec mouse_pos;
	SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);

	// const byte can_escape_window = keys[KEY_ESCAPE_WINDOW];

		/*
		at_right_boundary = mouse_pos.x == settings.screen_width - 1,
		at_left_boundary = mouse_pos.x == 0,
		at_upper_boundary = mouse_pos.y == settings.screen_height - 1,
		at_lower_boundary = mouse_pos.y == 0;
		*/

	// SDL_ShowCursor(can_escape_window);

	/*
	if (!can_escape_window) {
		// if mouse outside of window, don't do this
		if (mouse_pos.x == settings.screen_width - 1)
			SDL_WarpMouseInWindow(screen.window, 1, mouse_pos.y);
		else if (mouse_pos.x == 0)
			SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos.y);

		if (mouse_pos.y == settings.screen_height - 1)
			SDL_WarpMouseInWindow(screen.window, mouse_pos.x, settings.screen_height - 1);
		else if (mouse_pos.y == 0)
			SDL_WarpMouseInWindow(screen.window, mouse_pos.x, 0);
	}
	*/
}

/////

/*
at_right_boundary = mouse_pos.x == settings.screen_width - 1,
at_left_boundary = mouse_pos.x == 0,
at_upper_boundary = mouse_pos.y == settings.screen_height - 1,
at_lower_boundary = mouse_pos.y == 0;
*/


/////

inlinable void update_theta_and_y_pitch(double* const theta, int* const y_pitch, ivec* const _mouse_pos) {
	puts("Checking");
	toggledef(KEY_ESCAPE_WINDOW, 0); // if can escape window, return

	DEBUG(toggle.enabled, d);

	puts("Should not escape window");

	(void) theta;
	(void) y_pitch;
	(void) _mouse_pos;

	ivec mouse_pos;
	SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);

	if (mouse_pos.x == settings.screen_width - 1)
		SDL_WarpMouseInWindow(screen.window, 1, mouse_pos.y);
	else if (mouse_pos.x == 0)
		SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos.y);

	if (mouse_pos.y == settings.screen_height - 1)
		SDL_WarpMouseInWindow(screen.window, mouse_pos.x, settings.screen_height - 1);
	else if (mouse_pos.y == 0)
		SDL_WarpMouseInWindow(screen.window, mouse_pos.x, 0);

	*theta = (double) mouse_pos.x / settings.screen_width * 360.0;
	*y_pitch = -mouse_pos.y + settings.half_screen_height;
}

/////

/*
vec vec_tex_offset(const vec pos, const vec tex_size);
const vec tex_pos = vec_tex_offset(pos, (vec) {10 * 10, 10 * 10});
return (double) lm.data[(int) (tex_pos[1] * lm.size.x + tex_pos[0])];
*/

/*
const ivec int_pos = ivec_from_vec(pos);
return (double) lm.data[int_pos.y * lm.size.x + int_pos.x];
*/

/*
const ivec int_pos = ivec_from_vec(pos);
return lm.data[int_pos.y * lm.size.x + int_pos.x] / 255.0;
*/

/*
static double p;
const byte pressed = keys[SDL_SCANCODE_T];
if (pressed) {
	p += 0.000001;
	DEBUG(p, lf);
}

// return lm.data[(int) (p * lm.size.x + p)] / 255.0;
// return lm.data[(int) (pos[1] * lm.size.x + pos[0])] / 255.0;
*/

/////