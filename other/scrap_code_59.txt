void blur_image_portion(SDL_Surface* const image, SDL_Rect crop, const int blur_size) { // box blur
	typedef __v4si color4;

	const int src_w = image -> w, src_h = image -> h;
	SDL_Surface* const blurred_crop = SDL_CreateRGBSurfaceWithFormat(0, crop.w, crop.h, 32, PIXEL_FORMAT);
	SDL_LockSurface(blurred_crop);
	SDL_LockSurface(image);

	static byte first = 1;

	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;
 	for (int y = crop.y; y < crop.y + crop.h; y++) {
		for (int x = crop.x; x < crop.x + crop.w; x++) {
			color4 sum = {0, 0, 0, 0};
			int blur_sum_factor = 0;
			for (int py = -blur_size; py <= blur_size; py++) {
				for (int px = -blur_size; px <= blur_size; px++) {

					/*
					int x1 = x + px, y1 = y + py;
					clamp_axis_val(&x1, src_w);
					clamp_axis_val(&y1, src_h);
					*/

					/*
					const int x1 = x + px, y1 = y + py;
					if (x1 < 0 || y1 < 0) continue;
					else if (x1 >= src_w || y1 >= src_h) break;
					*/

					int x1 = x + px, y1 = y + py;

					const byte
						x1_small = x1 < 0,
						y1_small = y1 < 0,
						x1_big = x1 >= src_w,
						y1_big = y1 >= src_h;

					clamp_axis_val(&x1, src_w);
					clamp_axis_val(&y1, src_h);

					const Uint32 pixel = *read_surface_pixel(image, x1, y1, bpp);

					byte r, g, b, a;
					SDL_GetRGBA(pixel, format, &r, &g, &b, &a);

					if (x1_small || y1_small || x1_big || y1_big) {
						blur_sum_factor = 9;
						sum = (color4) {r * 9, g * 9, b * 9, a * 9};
					}
					else {
						sum += (color4) {r, g, b, a};
						blur_sum_factor++;
					}
				}
			}

			// TODO: figure out why the edges are close to black

			if (blur_sum_factor == 0) blur_sum_factor = 1;
			const Uint16 out[4] = {
				sum[0] / blur_sum_factor,
				sum[1] / blur_sum_factor,
				sum[2] / blur_sum_factor,
				sum[3] / blur_sum_factor
			};

			const Uint32 blurred_pixel = SDL_MapRGBA(format, out[0], out[1], out[2], out[3]);
			*read_surface_pixel(blurred_crop, x - crop.x, y - crop.y, bpp) = blurred_pixel;
		}
	}

	first = 0;

	SDL_UnlockSurface(blurred_crop);
	SDL_UnlockSurface(image);

	SDL_BlitSurface(blurred_crop, NULL, image, &crop);
	SDL_FreeSurface(blurred_crop);
}

/////

inlinable void clamp_axis_val(int* const val, const int axis_size) {
	if (*val < 0) *val = 0;
	else if (*val >= axis_size) *val = axis_size - 1;
}

/////

/*
levels w/ bad mipmap sizes:
- forever_maze (ivy.bmp) (done)
- level_1 (cobblestone_2.bmp, stone_2.bmp, hieroglyphics.bmp) (done)
- red_room (red_room_floor.bmp, red_curtains.bmp) (done)
*/

/////

SDL_SetRenderDrawColor(screen.renderer, teleporter_color.r, teleporter_color.g, teleporter_color.b, SDL_ALPHA_OPAQUE);

// DEBUG(fuzz_ticks, d);

for (byte i = 0; i < num_fuzz_dots_on_screen; i++) {
	// const byte dot_size = (rand() % (settings.avg_dimensions / 20)) / ((fuzz_ticks + 1) / 4);
	byte dot_size = (rand() % (settings.avg_dimensions / 20)) * (fuzz_ticks / ticks_for_teleporter_fuzz);


	// DEBUG(dot_size, d);

	// DEBUG((double) fuzz_ticks / ticks_for_teleporter_fuzz, lf);

	// DEBUG(log(num_fuzz_dots_on_screen), lf);
	// DEBUG(log(fuzz_ticks), lf);

	const SDL_Rect dot_pos = {
		rand() % settings.screen_width, rand() % settings.half_screen_height,
		dot_size, dot_size
	};

	SDL_RenderFillRect(screen.renderer, &dot_pos);
}

/*
SDL_Rect rand_fuzz_pos = {
	rand() % settings.screen_width, rand() % settings.screen_height,
	settings.screen_width >> 1, settings.screen_height >> 1
};
*/

/*
printf("I am here\n");
SDL_RenderCopy(screen.renderer, teleporter_fuzz.texture, NULL, NULL);
*/

/////

/*
const vec wall_y_components = handle_ray((DataRaycast) {
	&last_wall_y, player_angle, theta, ray.dist, wall_y_shift, full_jump_height,
	player -> pos, hit, dir, point, point_height, ray.side, at_first_hit, &last_point_height, screen_x});
*/

/////

// origin and dir are braced b/c vec -> double[2], and the arrays can't be copied directly

/////

//////////

inlinable void double_array_apply(double (*fn) (double), double* const array, const byte length) {
	for (byte i = 0; i < length; i++) array[i] = fn(array[i]);
}

/////

if (d -> screen_x == 200) {
	DEBUG(*d -> last_wall_y, lf);
	// DEBUG(smallest_wall_y, lf);
	puts("---");
	// at this point, *d -> last_wall_y equals the top of the wall
}

double projected_wall_top = *d -> last_wall_y;
double projected_wall_bottom = last_last_wall_y;

align_from_out_of_vert_bounds(&projected_wall_top);
align_from_out_of_vert_bounds(&projected_wall_bottom);
for (double y = round(projected_wall_top); y < round(projected_wall_bottom); y++)
	set_statemap_bit(occluded_by_walls, d -> screen_x, y);

/*
SDL_Rect test = {d -> screen_x, *d -> last_wall_y, 10, 10};
SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
SDL_RenderFillRect(screen.renderer, &test);
*/

//////////

/*
align_from_out_of_vert_bounds(&wall_top);
align_from_out_of_vert_bounds(&wall_bottom);
*/

// void set_statemap_bit(const StateMap, const int, const int);
// for (double y = round(wall_top); y < round(wall_bottom); y++) set_statemap_bit(occluded_by_walls, screen_x, y);


/////

void statemap_test(void) {
	StateMap statemap = init_statemap(20, 20);
	set_statemap_bit(statemap, 0, 0);
	set_statemap_bit(statemap, 15, 15);

	// check get_statemap_bit by printing each bit - it is probably incorrect

	print_statemap(statemap);
	deinit_statemap(statemap);
}

/////

/*
SDL_SetRenderDrawColor(screen.renderer, 0, 0, 255, SDL_ALPHA_OPAQUE);
SDL_RenderDrawLine(screen.renderer, d -> screen_x, projected_wall_top, d -> screen_x, projected_wall_bottom);
*/

/////

// DEBUG(wall_h_sum, lf);

double projected_wall_top = *d -> last_wall_y;
double projected_wall_bottom = projected_wall_top + wall_h_sum;

align_from_out_of_vert_bounds(&projected_wall_top);
align_from_out_of_vert_bounds(&projected_wall_bottom);
for (double y = round(projected_wall_top); y < round(projected_wall_bottom); y++)
	set_statemap_bit(occluded_by_walls, d -> screen_x, y);

// the top is right, the bottom is wrong
void draw_colored_rect(const byte, const byte, const byte, const double, const SDL_Rect* const);

const SDL_Rect top = {d -> screen_x, projected_wall_top, 10, 10};
// draw_colored_rect(255, 0, 0, 1.0, &top); // red

const SDL_Rect bottom = {d -> screen_x, projected_wall_bottom, 10, 5};
// draw_colored_rect(0, 0, 255, 1.0, &bottom); // blue
//

//////////


/////

if (tilt.val >= -tilt.step - 0.01 && tilt.val <= tilt.step + 0.01) {
	// the occlusion problem only shows up in first two cases below
	if (keys[SDL_SCANCODE_T]) SDL_RenderCopy(screen.renderer, screen.pixel_buffer, NULL, NULL);

	else if (keys[SDL_SCANCODE_Y]) {
		SDL_RenderCopy(screen.renderer, screen.shape_buffer, NULL, NULL);
		SDL_RenderCopy(screen.renderer, screen.pixel_buffer, NULL, NULL);
	}
	else {
		SDL_RenderCopy(screen.renderer, screen.pixel_buffer, NULL, NULL); // copy everything?
		SDL_RenderCopy(screen.renderer, screen.shape_buffer, NULL, NULL);
	}
}

/////