void blur_image_portion(SDL_Surface* const image, SDL_Rect crop, const int blur_size) { // box blur
	typedef __v4si color4;

	const int src_w = image -> w, src_h = image -> h;
	SDL_Surface* const blurred_crop = SDL_CreateRGBSurfaceWithFormat(0, crop.w, crop.h, 32, PIXEL_FORMAT);
	SDL_LockSurface(blurred_crop);
	SDL_LockSurface(image);

	static byte first = 1;

	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;
 	for (int y = crop.y; y < crop.y + crop.h; y++) {
		for (int x = crop.x; x < crop.x + crop.w; x++) {
			color4 sum = {0, 0, 0, 0};
			int blur_sum_factor = 0;
			for (int py = -blur_size; py <= blur_size; py++) {
				for (int px = -blur_size; px <= blur_size; px++) {

					/*
					int x1 = x + px, y1 = y + py;
					clamp_axis_val(&x1, src_w);
					clamp_axis_val(&y1, src_h);
					*/

					/*
					const int x1 = x + px, y1 = y + py;
					if (x1 < 0 || y1 < 0) continue;
					else if (x1 >= src_w || y1 >= src_h) break;
					*/

					int x1 = x + px, y1 = y + py;

					const byte
						x1_small = x1 < 0,
						y1_small = y1 < 0,
						x1_big = x1 >= src_w,
						y1_big = y1 >= src_h;

					clamp_axis_val(&x1, src_w);
					clamp_axis_val(&y1, src_h);

					const Uint32 pixel = *read_surface_pixel(image, x1, y1, bpp);

					byte r, g, b, a;
					SDL_GetRGBA(pixel, format, &r, &g, &b, &a);

					if (x1_small || y1_small || x1_big || y1_big) {
						blur_sum_factor = 9;
						sum = (color4) {r * 9, g * 9, b * 9, a * 9};
					}
					else {
						sum += (color4) {r, g, b, a};
						blur_sum_factor++;
					}
				}
			}

			// TODO: figure out why the edges are close to black

			if (blur_sum_factor == 0) blur_sum_factor = 1;
			const Uint16 out[4] = {
				sum[0] / blur_sum_factor,
				sum[1] / blur_sum_factor,
				sum[2] / blur_sum_factor,
				sum[3] / blur_sum_factor
			};

			const Uint32 blurred_pixel = SDL_MapRGBA(format, out[0], out[1], out[2], out[3]);
			*read_surface_pixel(blurred_crop, x - crop.x, y - crop.y, bpp) = blurred_pixel;
		}
	}

	first = 0;

	SDL_UnlockSurface(blurred_crop);
	SDL_UnlockSurface(image);

	SDL_BlitSurface(blurred_crop, NULL, image, &crop);
	SDL_FreeSurface(blurred_crop);
}

/////

inlinable void clamp_axis_val(int* const val, const int axis_size) {
	if (*val < 0) *val = 0;
	else if (*val >= axis_size) *val = axis_size - 1;
}

/////

/*
levels w/ bad mipmap sizes:
- forever_maze (ivy.bmp) (done)
- level_1 (cobblestone_2.bmp, stone_2.bmp, hieroglyphics.bmp) (done)
- red_room (red_room_floor.bmp, red_curtains.bmp) (done)
*/

/////

SDL_SetRenderDrawColor(screen.renderer, teleporter_color.r, teleporter_color.g, teleporter_color.b, SDL_ALPHA_OPAQUE);

// DEBUG(fuzz_ticks, d);

for (byte i = 0; i < num_fuzz_dots_on_screen; i++) {
	// const byte dot_size = (rand() % (settings.avg_dimensions / 20)) / ((fuzz_ticks + 1) / 4);
	byte dot_size = (rand() % (settings.avg_dimensions / 20)) * (fuzz_ticks / ticks_for_teleporter_fuzz);


	// DEBUG(dot_size, d);

	// DEBUG((double) fuzz_ticks / ticks_for_teleporter_fuzz, lf);

	// DEBUG(log(num_fuzz_dots_on_screen), lf);
	// DEBUG(log(fuzz_ticks), lf);

	const SDL_Rect dot_pos = {
		rand() % settings.screen_width, rand() % settings.half_screen_height,
		dot_size, dot_size
	};

	SDL_RenderFillRect(screen.renderer, &dot_pos);
}

/*
SDL_Rect rand_fuzz_pos = {
	rand() % settings.screen_width, rand() % settings.screen_height,
	settings.screen_width >> 1, settings.screen_height >> 1
};
*/

/*
printf("I am here\n");
SDL_RenderCopy(screen.renderer, teleporter_fuzz.texture, NULL, NULL);
*/

/////

/*
const vec wall_y_components = handle_ray((DataRaycast) {
	&last_wall_y, player_angle, theta, ray.dist, wall_y_shift, full_jump_height,
	player -> pos, hit, dir, point, point_height, ray.side, at_first_hit, &last_point_height, screen_x});
*/

/////

// origin and dir are braced b/c vec -> double[2], and the arrays can't be copied directly

/////