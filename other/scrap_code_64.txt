/* (void) point;
const double p = 0.0000001; // if used again, the map_point calls must be dereferenced
return map_point(current_level.heightmap, pos[0] - p, pos[1] - p); */

// return map_point(current_level.heightmap, pos[0] + p, pos[1] - p);
// return map_point(current_level.heightmap, pos[0] - p, pos[1] + p);
// return map_point(current_level.heightmap, pos[0] + p, pos[1] + p);

// return map_point(current_level.heightmap, pos[0], pos[1]);
// return map_point(current_level.heightmap, pos[0] - p, pos[1]);
// return map_point(current_level.heightmap, pos[0] + p, pos[1]);
// return map_point(current_level.heightmap, pos[0], pos[1] - p);
// return map_point(current_level.heightmap, pos[0], pos[1] + p);

/////

// pos[0] -= almost_almost_zero; // good for left side
// pos[0] += almost_almost_zero; // good for right side
// pos[0] -= almost_almost_zero;

/*
const double x_diff = ceil(pos[0]) - pos[0];
if (doubles_eq(x_diff, almost_zero) && !doubles_eq(x_diff, 0.0)) {
	printf("Case: %lf\n", pos[0]);
	pos[0] -= almost_almost_zero;
}
*/

/////

/*
const double x_diff = ceil(pos[0]) - pos[0];
if (x_diff < almost_almost_zero) {
	DEBUG(x_diff, lf);
	pos[0] += almost_almost_zero;
}
*/

/////

// if (ceil(pos[0]) - pos[0] == 0.0) pos[0] += almost_almost_zero; // right side fix

/*
else if (floor(pos[0] - pos[0]) == 0.0) {
	pos[0] -= almost_almost_zero; // left side fix
}
*/

/* all bad:
if (ceil(pos[0] - pos[0]) == 0.0) pos[0] += almost_almost_zero; // right side fix
else if (floor(pos[0] - pos[0]) == 0.0) {
	pos[0] -= almost_almost_zero; // left side fix
}

if (floor(pos[1] - pos[1]) == 0.0) pos[1] -= almost_almost_zero; // top side fix
else if (ceil(pos[1] - pos[1]) == 0.0) pos[1] += almost_almost_zero; // bottom side fix
*/

/*
const byte
	bottom_left_fix = floor(pos[1] - pos[1]) == 0.0,
	top_right_fix = ceil(pos[0] - pos[0]) == 0.0;

if (bottom_left_fix && !top_right_fix) // fixes bottom and left side
	pos += (vec) {-almost_almost_zero, almost_almost_zero};

else if (top_right_fix && !bottom_left_fix) // fixes top and right side
	pos += (vec) {almost_almost_zero, -almost_almost_zero};
*/

/////

/* all bad:
if (ceil(pos[0] - pos[0]) == 0.0) pos[0] += almost_almost_zero; // right side fix
else if (floor(pos[0] - pos[0]) == 0.0) {
	pos[0] -= almost_almost_zero; // left side fix
}

if (floor(pos[1] - pos[1]) == 0.0) pos[1] -= almost_almost_zero; // top side fix
else if (ceil(pos[1] - pos[1]) == 0.0) pos[1] += almost_almost_zero; // bottom side fix
*/

/*
const byte
	bottom_left_fix = floor(pos[1] - pos[1]) == 0.0,
	top_right_fix = ceil(pos[0] - pos[0]) == 0.0;

if (bottom_left_fix && !top_right_fix) // fixes bottom and left side
	pos += (vec) {-almost_almost_zero, almost_almost_zero};

else if (top_right_fix && !bottom_left_fix) // fixes top and right side
	pos += (vec) {almost_almost_zero, -almost_almost_zero};
*/

/////

// else if (doubles_eq(floor(pos[0]) - pos[0], 0.0)) pos[0] -= almost_almost_zero;

// DEBUG(floor(pos[0] - pos[0]), lf);

// if (doubles_eq(ceil(pos[1]) - pos[1], 0.0)) pos[1] += almost_almost_zero; // bottom side fix

///// A bunch of experiments, with some probably good ideas in there:

#ifdef HM_TEST

(void) point;

// pos += (vec) {almost_almost_zero, -almost_almost_zero}; // good for top and right side
// pos += (vec) {-almost_almost_zero, almost_almost_zero}; // good for left and bottom side
// pos += (vec) {almost_almost_zero, almost_almost_zero}; // good for right and bottom side
// pos += (vec) {-almost_almost_zero, -almost_almost_zero}; // good for top and left side

/* good sign changes:	
	sub pos[1]: top, add pos[1]: bottom
	sub pos[0]: left, add pos[0]: right */

//////////

// if (doubles_eq(ceil(pos[0]) - pos[0], 0.0)) pos[0] += almost_almost_zero; // right side fix
// if (doubles_eq(ceil(pos[1]) - pos[1], 0.0)) pos[1] += almost_almost_zero; // bottom side fix
// each version works fine wihtout the branch, but I'm figuring that I'll have to figure out which side to fix

// if (doubles_eq(floor(pos[1]) - pos[1], 0.0)) pos[1] -= almost_almost_zero;
if ((floor(pos[1]) - pos[1]) < almost_almost_zero && floor(pos[1]) - pos[1] >= 0.0) {
	printf("Here: %lf\n", floor(pos[1]) - pos[1]);
	pos[0] += almost_almost_zero;
}

/////

/*
static double offset = 0.0;
const double step = 0.001;
if (keys[SDL_SCANCODE_T]) offset -= step;
if (keys[SDL_SCANCODE_Y]) offset += step;
if (keys[SDL_SCANCODE_U]) offset = 0.0;
*/

///// This is not used anymore:

/*
void randomize_map(const Level level, byte* const md, const byte* const points, const byte len_points) {
	for (int x = 0; x < current_level.map_size.x; x++) {
		for (int y = 0; y < current_level.map_size.y; y++)
			md[y * level.map_size.x + x] = points[rand() % len_points];
	}
}
*/

/////

const byte
	x_part = half_size[0] - diff[0] + almost_zero - 3.0,
	y_part = half_size[1] - diff[1] + almost_zero - 3.0;

return (x_part + y_part) >> 1;

/*
const double half_x_size = current_level.map_size.x / 2.0;
const double x_diff = fabs(pos[0] - half_x_size);
return half_x_size - x_diff + almost_zero - 3;
*/

/////

/*
made heightmaps for:
	- palace
	- pyramid
	- debug level
	- fleckenstein
	- forever maze
	- level 1
	- mipmap hallway
	- red room

left:
*/

///// All of the point height functions:

inlinable byte get_airship_point_height(const byte point, const vec pos) {
	(void) pos;
	return point;
}

inlinable byte get_debug_level_point_height(const byte point, const vec pos) {
	(void) pos;
	if (point == 5 || point == 6) return 1;
	return point;
}

inlinable byte get_fleckenstein_point_height(const byte point, const vec pos) {
	switch (point) {
		case 1:
			if (pos[1] < 19.0001) return 5;
			else if (pos[1] < 24.0001) return 24.0001 - pos[1];
			else return 5;

		case 2: return 3;

		case 3:
			if (pos[1] < 21.0001) return 9;
			else return 6;

		case 4: return 6;

		default: return point;
	}
}

inlinable byte get_maze_point_height(const byte point, const vec pos) {
	(void) pos;
	switch (point) {
		case 1: return 3;
		default: return point;
	}
}

inlinable byte get_level_1_point_height(const byte point, const vec pos) {
	switch (point) {
		case 0: return 0;
		case 1: return 3; // cobblestone edges
		case 3: case 5: return 2; // stone, hieroglyphics
		case 4: return (pos[0] < 5.0001) ? 5 : 1;
		default: return 1;
	}
}

inlinable byte get_hallway_point_height(const byte point, const vec pos) {
	(void) pos;
	return point;
}


// #define HM_TEST

// sides: 0 = left and right, 1 = top and bottom; determining which fourth side will allow the heightmap to work

inlinable byte get_palace_point_height(const byte point, vec pos) {
	#ifdef HM_TEST

	(void) point;

	// pos += (vec) {almost_almost_zero, -almost_almost_zero}; // good for top and right side
	// pos += (vec) {-almost_almost_zero, almost_almost_zero}; // good for left and bottom side
	// pos += (vec) {almost_almost_zero, almost_almost_zero}; // good for right and bottom side
	// pos += (vec) {-almost_almost_zero, -almost_almost_zero}; // good for top and left side

	/* good sign changes:
		sub pos[1]: top, add pos[1]: bottom
		sub pos[0]: left, add pos[0]: right */

	//////////

	// if (doubles_eq(ceil(pos[0]) - pos[0], 0.0)) pos[0] += almost_almost_zero; // right side fix
	// if (doubles_eq(ceil(pos[1]) - pos[1], 0.0)) pos[1] += almost_almost_zero; // bottom side fix
	// each version works fine wihtout the branch, but I'm figuring that I'll have to figure out which side to fix

	// maybe different additions based on the wall side or direction?

	//////////

	return *map_point(current_level.heightmap, pos[0], pos[1]);

	#else

	if (point == 1) {
		if (pos[0] <= 8.9999 && pos[1] <= 5.9999) return 3;
		else return 5;
	}

	else if (point == 2) {
		if (pos[1] <= 9.9999) return 1;
		else if (pos[0] >= 21.0001 || pos[1] <= 10.9999) return 2;
		return 3;
	}

	else if (point == 6) {
		if (pos[0] <= 3.9999) return pos[0] + 0.0001;
		else if (pos[0] <= 13.0001) return 3;
		return 2;
	}

	else if (point == 7) {
		if (pos[1] >= 30.9999) return 2;
		return 1;
	}

	switch (point) {
		case 3: return 6;
		case 4: return 3;
		case 5: return 8; // 6 before
		case 8: return 1;
		case 9: return 2;
		case 10: return 10;
		default: return point;
	}

	#endif
}

inlinable byte get_pyramid_point_height(const byte point, const vec pos) {
	if (point != 2) return point;

	const vec half_size = {current_level.map_size.x / 2.0, current_level.map_size.y / 2.0};
	vec diff = pos - half_size;
	diff = (vec) {fabs(diff[0]), fabs(diff[1])};

	const vec slopes_to_center = half_size - diff + vec_fill(0) - vec_fill(3.0);
	return (slopes_to_center[0] + slopes_to_center[1]) / 2.0;
}

inlinable byte get_red_room_point_height(const byte point, const vec pos) {
	(void) pos;
	return (point == 2) ? 3 : 0;
}

/////

// this expects a short sound
inlinable void set_sound_volume_from_dist(const Sound* const sound, const double dist) {
	/*
	double percent_audible = 1.0 - (dist / max_sound_dist);
	DEBUG(percent_audible, lf);
	*/

	/*
	double percent_audible = 1.0 - dist / max_sound_dist;
	DEBUG(percent_audible, lf);
	if (percent_audible < min_percent_audible) percent_audible = min_percent_audible; // can't let stuff get too quiet
	Mix_VolumeChunk(sound -> type.short_sound, percent_audible * MIX_MAX_VOLUME);
	*/

	double percent_close = 1.0 - (dist / max_sound_dist);
	if (percent_close < 0.0) percent_close = 0.0;
	DEBUG(percent_close, lf);
}

///// The old branch-y tilt code:

/*
if (strafe) {
	tilt -> val += lstrafe ? tilt -> step : -tilt -> step;

	if (tilt -> val > tilt -> max)
		tilt -> val = tilt -> max;
	else if (tilt -> val < -tilt -> max)
		tilt -> val = -tilt -> max;
}

else if (tilt -> val + tilt -> step < 0.0) tilt -> val += tilt -> step;
else if (tilt -> val - tilt -> step > 0.0) tilt -> val -= tilt -> step;
*/

/////

double to_degrees(const double radians) {
	return radians * 180 / M_PI;
}

///// The old pyramid heightmap:

static const byte heightmap[map_height][map_width] = {
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
	{1, 20,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20,1},
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{1, 0, 0, 0, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 1},
	{1, 0, 0, 0, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 0, 0, 0, 1},
	{1, 0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 0, 0, 0, 1},
	{1, 0, 0, 0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 0, 0, 0, 1},
	{1, 0, 0, 0, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 0, 0, 0, 1},
	{1, 0, 0, 0, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 0, 0, 0, 1},
	{1, 0, 0, 0, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 0, 0, 0, 1},
	{1, 0, 0, 0, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 0, 0, 0, 1},
	{1, 0, 0, 0, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,10,9, 9, 8, 8, 7, 7, 6, 6, 5, 0, 0, 0, 1},
	{1, 0, 0, 0, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,11,10,10,9, 9, 8, 8, 7, 7, 6, 6, 0, 0, 0, 1},
	{1, 0, 0, 0, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,11,11,11,10,10,9, 9, 8, 8, 7, 7, 6, 0, 0, 0, 1},
	{1, 0, 0, 0, 6, 7, 7, 8, 8, 9, 9, 10,10,11,11,20,11,11,10,10,9, 9, 8, 8, 7, 7, 0, 0, 0, 1},
	{1, 0, 0, 0, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,11,11,11,10,10,9, 9, 8, 8, 7, 7, 6, 0, 0, 0, 1},
	{1, 0, 0, 0, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,11,10,10,9, 9, 8, 8, 7, 7, 6, 6, 0, 0, 0, 1},
	{1, 0, 0, 0, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,10,10,9, 9, 8, 8, 7, 7, 6, 6, 5, 0, 0, 0, 1},
	{1, 0, 0, 0, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 0, 0, 0, 1},
	{1, 0, 0, 0, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 0, 0, 0, 1},
	{1, 0, 0, 0, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 0, 0, 0, 1},
	{1, 0, 0, 0, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 0, 0, 0, 1},
	{1, 0, 0, 0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 0, 0, 0, 1},
	{1, 0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 0, 0, 0, 1},
	{1, 0, 0, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 1},
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{1, 20,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20,1},
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

/////

wall_data[28][1] = 3;
wall_data[1][28] = 3;
wall_data[1][1] = 3;
wall_data[28][28] = 3;

/////

SDL_RendererInfo info;
SDL_GetRendererInfo(screen.renderer, &info);
printf("name = \"%s\", flags = %u, tex_formats = %u, max tex size = {%d, %d}\n",
	info.name, info.flags, info.num_texture_formats, info.max_texture_width, info.max_texture_height);

///// The old mouse code:

/*
ivec mouse_pos;
SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);

if (mouse_pos.x == settings.screen_width - 1)
	SDL_WarpMouseInWindow(screen.window, 1, mouse_pos.y);
else if (mouse_pos.x == 0)
	SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos.y);

if (mouse_pos.y == settings.screen_height - 1)
	SDL_WarpMouseInWindow(screen.window, mouse_pos.x, settings.screen_height - 1);
else if (mouse_pos.y == 0)
	SDL_WarpMouseInWindow(screen.window, mouse_pos.x, 0);

*theta = (double) mouse_pos.x / settings.screen_width * two_pi;
*y_pitch = -mouse_pos.y + settings.half_screen_height;
*/

/////