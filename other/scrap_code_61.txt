/* // The floating-point version of the pixel shader:
static const double one_over_255 = 1.0 / 255.0;
const double shade = byte_shade * one_over_255;

const byte r = (byte) (pixel >> 16) * shade, g = (byte) (pixel >> 8) * shade, b = (byte) pixel * shade;
return 0xFF000000 | (r << 16) | (g << 8) | b;
*/

/////

/*
byte valid_neighbor_indices = 0;
for (byte i = 0; i < 4; i++) {
	const ivec neighbor = four_neighbors[i];
	if (neighbor.x > 0 && neighbor.y > 0 && neighbor.x < orig_size.x && neighbor.y < orig_size.y)
		set_nth_bit(&valid_neighbor_indices, i);
}
// weighted average = arithmetic mean here b/c weights are equal
*/

/////

/*
void bilinear_test(void) {
	SDL_Surface* const unconverted_image = SDL_LoadBMP("assets/walls/horses.bmp");
	SDL_Surface* const image = SDL_ConvertSurfaceFormat(unconverted_image, PIXEL_FORMAT, 0);
	SDL_FreeSurface(unconverted_image);

	const byte scale = 3;
	const byte dec_scale = scale - 1;

	SDL_Surface* const unfiltered = SDL_CreateRGBSurfaceWithFormat(0, image -> w >> dec_scale, image -> h >> dec_scale, 32, PIXEL_FORMAT);
	SDL_BlitScaled(image, NULL, unfiltered, NULL);
	SDL_SaveBMP(unfiltered, "unfiltered.bmp");
	SDL_FreeSurface(unfiltered);

	SDL_Surface* const filtered = bilinear_downscale_by_2(image, scale); // not fully working yet
	SDL_SaveBMP(filtered, "filtered.bmp");
	SDL_FreeSurface(filtered);

	exit(0);
}

SDL_Surface* bilinear_downscale_by_2(const SDL_Surface* const orig, const byte scale_factor) {
	const byte dec_scale_factor = scale_factor - 1;
	const int orig_size = orig -> w;
	const int downscaled_size = orig_size >> dec_scale_factor;

	SDL_Surface* const filtered = SDL_CreateRGBSurfaceWithFormat(0, downscaled_size, downscaled_size, 32, PIXEL_FORMAT);
	const SDL_PixelFormat* const format = filtered -> format;
	const int bpp = format -> BytesPerPixel;

	const byte inc_across = 1 << dec_scale_factor;

	for (int y = 0; y < orig_size; y += inc_across) {
		for (int x = 0; x < orig_size; x += inc_across) {
			const ivec four_neighbors[4] = {{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}; // as a cross
			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < orig_size && neighbor.y < orig_size) {
					const Uint32 neighbor_val = *read_surface_pixel(orig, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			*read_surface_pixel(filtered, x >> dec_scale_factor, y >> dec_scale_factor, bpp) = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
		}
	}
	return filtered;
}
*/

/////

// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_next_mipmap_level(const SDL_Surface* const mipmap, const SDL_Rect last_dest, const SDL_Rect dest) {
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;

	for (int last_y = last_dest.y; last_y < last_dest.y + last_dest.h; last_y++) {
		for (int last_x = last_dest.x; last_x < last_dest.x + last_dest.w; last_x++) {
			const ivec four_neighbors[4] = {
				{last_x - 1, last_y}, {last_x + 1, last_y},
				{last_x, last_y - 1}, {last_x, last_y + 1}
			}; // a cross

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < last_dest.w && neighbor.y < last_dest.w) {
					const Uint32 neighbor_val = *read_surface_pixel(mipmap, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}

				// *read_surface_pixel(filtered, x >> dec_scale_factor, y >> dec_scale_factor, bpp) =

				/*
				*read_surface_pixel(mipmap, )
					SDL_MapRGBA(format, sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
						sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
				*/

				/* write from the last dest to the current one
				maybe I should iterate over the curr dest instead
				*/
			}
		}
	}
}

/////

// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_next_mipmap_level(SDL_Surface* const mipmap, const SDL_Rect last_dest, SDL_Rect dest) {
	/*
	DEBUG_RECT(last_dest);
	DEBUG_RECT(dest);
	SDL_BlitScaled(mipmap, NULL, mipmap, &dest);
	*/

	/*
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;

	for (int y = dest.y, last_y = last_dest.y; y < dest.y + dest.h; y++, last_y += 2) {
		for (int x = dest.x, last_x = last_dest.x; x < dest.x + dest.w; x++, last_x += 2) {

			const ivec four_neighbors[4] = {
				{last_x - 1, last_y}, {last_x + 1, last_y},
				{last_x, last_y - 1}, {last_x, last_y + 1}
			}; // a plus sign shape

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < last_dest.w && neighbor.y < last_dest.w) {
					const Uint32 neighbor_val = *read_surface_pixel(mipmap, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			printf("x = %d, y = %d\n", x, y);
			*read_surface_pixel(mipmap, x, y, bpp) = SDL_MapRGBA(format, sum[0] / valid_neighbor_sum,
				sum[1] / valid_neighbor_sum, sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
		}
	}
	*/
}

/////

/*
// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	if (depth == 0) {
		SDL_BlitScaled(image, NULL, mipmap, &dest);
		return;
	}

	const int src_sample_step = 1 << depth;
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	for (int src_y = 0, dest_y = dest.y; src_y < src_size; src_y += src_sample_step, dest_y++) {
		for (int src_x = 0, dest_x = dest.x; src_x < src_size; src_x += src_sample_step, dest_x++) {
			const ivec four_neighbors[4] = { // sample coordinates from the source
				{src_x - 1, src_y}, {src_x + 1, src_y},
				{src_x, src_y - 1}, {src_x, src_y + 1}
			};

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				// if the sample coordinate is within the bounds of the src image
				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < src_size && neighbor.y < src_size) {
					const Uint32 neighbor_val = *read_surface_pixel(image, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			const Uint32 filtered_pixel = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);

			*read_surface_pixel(mipmap, dest_x, dest_y, bpp) = filtered_pixel;
		}
	}
}
*/

void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	(void) depth;
	// SDL_BlitScaled(image, NULL, mipmap, &dest); // for nearest-neighbor, this works

	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	static byte first = 1;

	for (int dy = dest.y; dy < dest.y + dest.h; dy++) {
		const int rel_dy = dy - dest.y;
		for (int dx = dest.x; dx < dest.x + dest.w; dx++) {
			const int rel_dx = dx - dest.x;

			const ivec sample_src_coords = {rel_dx >> depth, rel_dy >> depth};
			if (first) DEBUG_IVEC(sample_src_coords);
			// *read_surface_pixel(mipmap, dx, dy, bpp) = SDL_MapRGBA(format, 255, 0, 0, 255); // fills the mipmap with red
		}
	}
	puts("-");

	if (first) first = 0;
}

/////

/*
// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	if (depth == 0) {
		SDL_BlitScaled(image, NULL, mipmap, &dest);
		return;
	}

	const int src_sample_step = 1 << depth;
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	for (int src_y = 0, dest_y = dest.y; src_y < src_size; src_y += src_sample_step, dest_y++) {
		for (int src_x = 0, dest_x = dest.x; src_x < src_size; src_x += src_sample_step, dest_x++) {
			const ivec four_neighbors[4] = { // sample coordinates from the source
				{src_x - 1, src_y}, {src_x + 1, src_y},
				{src_x, src_y - 1}, {src_x, src_y + 1}
			};

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				// if the sample coordinate is within the bounds of the src image
				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < src_size && neighbor.y < src_size) {
					const Uint32 neighbor_val = *read_surface_pixel(image, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			const Uint32 filtered_pixel = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);

			*read_surface_pixel(mipmap, dest_x, dest_y, bpp) = filtered_pixel;
		}
	}
}
*/

void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	(void) depth;
	// SDL_BlitScaled(image, NULL, mipmap, &dest); // for nearest-neighbor, this works

	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	static byte first = 1;

	for (int dy = dest.y; dy < dest.y + dest.h; dy++) {
		const int rel_dy = dy - dest.y;
		for (int dx = dest.x; dx < dest.x + dest.w; dx++) {
			const int rel_dx = dx - dest.x;

			const ivec sample_src_coords = {rel_dx >> depth, rel_dy >> depth};
			if (first) DEBUG_IVEC(sample_src_coords);
			// *read_surface_pixel(mipmap, dx, dy, bpp) = SDL_MapRGBA(format, 255, 0, 0, 255); // fills the mipmap with red
		}
	}
	puts("-");

	if (first) first = 0;
}

///// The old psprite code:

// p = init_psprite("assets/walls/grass.bmp");

/*
PSprite init_psprite(const char* const path) {
	SDL_Surface* const unconverted_surface = SDL_LoadBMP(path);
	if (unconverted_surface == NULL) FAIL("Could not load a surface with the path of %s\n", path);
	SDL_Surface* const surface = SDL_ConvertSurfaceFormat(unconverted_surface, PIXEL_FORMAT, 0);
	if (surface == NULL) FAIL("Could not convert a surface type for path %s\n", path);

	SDL_FreeSurface(unconverted_surface);
	SDL_LockSurface(surface);

	const ivec size = {surface -> w, surface -> h};

	PSprite p = {
		.texture = SDL_CreateTexture(screen.renderer, PIXEL_FORMAT, SDL_TEXTUREACCESS_STREAMING, size.x, size.y),
		.size = size.x
	};

	SDL_LockTexture(p.texture, NULL, &p.pixels, &p.pitch);

	// SDL_UpdateTexture(p.texture, NULL, surface -> pixels, surface -> pitch);

	// memcpy(p.pixels, surface -> pixels, p.pitch * size.y);
	SDL_UnlockTexture(p.texture);

	SDL_UnlockSurface(surface);
	SDL_FreeSurface(surface);

	return p;
}
*/

/* for mesa.bmp
static byte print_bad = 1;
const Uint32 top = read_texture_row(p.pixels, p.pitch, 0)[0];
if (top != 4293837722 && print_bad) {
	printf("Schlecht; reads = %llu\n", reads);
	// 8427098
	print_bad = 0;
}
*/

const vec offset = vec_tex_offset(hit, ground.size.x);
// Uint32 pixel = read_texture_row(p.pixels, p.pitch, offset[1])[(long) offset[0]];
Uint32 pixel = read_surface_pixel(ground.pixels, offset[0], offset[1], ground.) {


/////

#define deinit_psprite(p) SDL_DestroyTexture(p.texture);

/////

typedef struct {
	void* pixels;
	int pitch, size; // for pixelwise access, equal dimensions are needed
	SDL_Texture* texture;
} PSprite; // pixelwise access

///// Old lerp code for floorcast.c:

vec lerp_floor(const vec pos, const double straight_dist, vec* const hit) {
	const BufferVal
		start_buf_val = val_buffer[0],
		end_buf_val = val_buffer[settings.screen_width - 1];

	const double
		start_actual_dist = straight_dist * (double) start_buf_val.one_over_cos_beta,
		end_actual_dist = straight_dist * (double) end_buf_val.one_over_cos_beta;

	const vec
		start_hit = vec_line_pos(pos, start_buf_val.dir, start_actual_dist),
		end_hit = vec_line_pos(pos, end_buf_val.dir, end_actual_dist);

	const vec step = (end_hit - start_hit) / vec_fill(settings.screen_width);
	*hit = start_hit;

	return step;
}

vec hit;
const vec step = lerp_floor(pos, straight_dist, &hit);

const vec hit = vec_line_pos(pos, buffer_val.dir, actual_dist);
// hit = align_vec_from_out_of_bounds(hit);

hit += step;

/////

/*
void antialias_test(void) {
	SDL_Surface* const unconverted_image = SDL_LoadBMP("assets/walls/horses.bmp");
	SDL_Surface* const image = SDL_ConvertSurfaceFormat(unconverted_image, PIXEL_FORMAT, 0);
	SDL_FreeSurface(unconverted_image);

	const byte scale = 3;
	const byte dec_scale = scale - 1;

	SDL_Surface* const unfiltered = SDL_CreateRGBSurfaceWithFormat(0, image -> w >> dec_scale, image -> h >> dec_scale, 32, PIXEL_FORMAT);
	SDL_BlitScaled(image, NULL, unfiltered, NULL);
	SDL_SaveBMP(unfiltered, "unfiltered.bmp");
	SDL_FreeSurface(unfiltered);

	SDL_Surface* antialiased_downscale_by_2(const SDL_Surface* const, const byte);
	SDL_Surface* const filtered = antialiased_downscale_by_2(image, scale);
	SDL_SaveBMP(filtered, "filtered.bmp");
	SDL_FreeSurface(filtered);

	exit(0);
}
*/

/////

const ivec pixel_group[4] = {
	{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}
};

/////