/* // The floating-point version of the pixel shader:
static const double one_over_255 = 1.0 / 255.0;
const double shade = byte_shade * one_over_255;

const byte r = (byte) (pixel >> 16) * shade, g = (byte) (pixel >> 8) * shade, b = (byte) pixel * shade;
return 0xFF000000 | (r << 16) | (g << 8) | b;
*/

/////

/*
byte valid_neighbor_indices = 0;
for (byte i = 0; i < 4; i++) {
	const ivec neighbor = four_neighbors[i];
	if (neighbor.x > 0 && neighbor.y > 0 && neighbor.x < orig_size.x && neighbor.y < orig_size.y)
		set_nth_bit(&valid_neighbor_indices, i);
}
// weighted average = arithmetic mean here b/c weights are equal
*/

/////

/*
void bilinear_test(void) {
	SDL_Surface* const unconverted_image = SDL_LoadBMP("assets/walls/horses.bmp");
	SDL_Surface* const image = SDL_ConvertSurfaceFormat(unconverted_image, PIXEL_FORMAT, 0);
	SDL_FreeSurface(unconverted_image);

	const byte scale = 3;
	const byte dec_scale = scale - 1;

	SDL_Surface* const unfiltered = SDL_CreateRGBSurfaceWithFormat(0, image -> w >> dec_scale, image -> h >> dec_scale, 32, PIXEL_FORMAT);
	SDL_BlitScaled(image, NULL, unfiltered, NULL);
	SDL_SaveBMP(unfiltered, "unfiltered.bmp");
	SDL_FreeSurface(unfiltered);

	SDL_Surface* const filtered = bilinear_downscale_by_2(image, scale); // not fully working yet
	SDL_SaveBMP(filtered, "filtered.bmp");
	SDL_FreeSurface(filtered);

	exit(0);
}

SDL_Surface* bilinear_downscale_by_2(const SDL_Surface* const orig, const byte scale_factor) {
	const byte dec_scale_factor = scale_factor - 1;
	const int orig_size = orig -> w;
	const int downscaled_size = orig_size >> dec_scale_factor;

	SDL_Surface* const filtered = SDL_CreateRGBSurfaceWithFormat(0, downscaled_size, downscaled_size, 32, PIXEL_FORMAT);
	const SDL_PixelFormat* const format = filtered -> format;
	const int bpp = format -> BytesPerPixel;

	const byte inc_across = 1 << dec_scale_factor;

	for (int y = 0; y < orig_size; y += inc_across) {
		for (int x = 0; x < orig_size; x += inc_across) {
			const ivec four_neighbors[4] = {{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}; // as a cross
			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < orig_size && neighbor.y < orig_size) {
					const Uint32 neighbor_val = *read_surface_pixel(orig, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			*read_surface_pixel(filtered, x >> dec_scale_factor, y >> dec_scale_factor, bpp) = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
		}
	}
	return filtered;
}
*/

/////

// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_next_mipmap_level(const SDL_Surface* const mipmap, const SDL_Rect last_dest, const SDL_Rect dest) {
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;

	for (int last_y = last_dest.y; last_y < last_dest.y + last_dest.h; last_y++) {
		for (int last_x = last_dest.x; last_x < last_dest.x + last_dest.w; last_x++) {
			const ivec four_neighbors[4] = {
				{last_x - 1, last_y}, {last_x + 1, last_y},
				{last_x, last_y - 1}, {last_x, last_y + 1}
			}; // a cross

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < last_dest.w && neighbor.y < last_dest.w) {
					const Uint32 neighbor_val = *read_surface_pixel(mipmap, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}

				// *read_surface_pixel(filtered, x >> dec_scale_factor, y >> dec_scale_factor, bpp) =

				/*
				*read_surface_pixel(mipmap, )
					SDL_MapRGBA(format, sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
						sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
				*/

				/* write from the last dest to the current one
				maybe I should iterate over the curr dest instead
				*/
			}
		}
	}
}

/////

// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_next_mipmap_level(SDL_Surface* const mipmap, const SDL_Rect last_dest, SDL_Rect dest) {
	/*
	DEBUG_RECT(last_dest);
	DEBUG_RECT(dest);
	SDL_BlitScaled(mipmap, NULL, mipmap, &dest);
	*/

	/*
	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel;

	for (int y = dest.y, last_y = last_dest.y; y < dest.y + dest.h; y++, last_y += 2) {
		for (int x = dest.x, last_x = last_dest.x; x < dest.x + dest.w; x++, last_x += 2) {

			const ivec four_neighbors[4] = {
				{last_x - 1, last_y}, {last_x + 1, last_y},
				{last_x, last_y - 1}, {last_x, last_y + 1}
			}; // a plus sign shape

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < last_dest.w && neighbor.y < last_dest.w) {
					const Uint32 neighbor_val = *read_surface_pixel(mipmap, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			printf("x = %d, y = %d\n", x, y);
			*read_surface_pixel(mipmap, x, y, bpp) = SDL_MapRGBA(format, sum[0] / valid_neighbor_sum,
				sum[1] / valid_neighbor_sum, sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);
		}
	}
	*/
}

/////

/*
// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	if (depth == 0) {
		SDL_BlitScaled(image, NULL, mipmap, &dest);
		return;
	}

	const int src_sample_step = 1 << depth;
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	for (int src_y = 0, dest_y = dest.y; src_y < src_size; src_y += src_sample_step, dest_y++) {
		for (int src_x = 0, dest_x = dest.x; src_x < src_size; src_x += src_sample_step, dest_x++) {
			const ivec four_neighbors[4] = { // sample coordinates from the source
				{src_x - 1, src_y}, {src_x + 1, src_y},
				{src_x, src_y - 1}, {src_x, src_y + 1}
			};

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				// if the sample coordinate is within the bounds of the src image
				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < src_size && neighbor.y < src_size) {
					const Uint32 neighbor_val = *read_surface_pixel(image, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			const Uint32 filtered_pixel = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);

			*read_surface_pixel(mipmap, dest_x, dest_y, bpp) = filtered_pixel;
		}
	}
}
*/

void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	(void) depth;
	// SDL_BlitScaled(image, NULL, mipmap, &dest); // for nearest-neighbor, this works

	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	static byte first = 1;

	for (int dy = dest.y; dy < dest.y + dest.h; dy++) {
		const int rel_dy = dy - dest.y;
		for (int dx = dest.x; dx < dest.x + dest.w; dx++) {
			const int rel_dx = dx - dest.x;

			const ivec sample_src_coords = {rel_dx >> depth, rel_dy >> depth};
			if (first) DEBUG_IVEC(sample_src_coords);
			// *read_surface_pixel(mipmap, dx, dy, bpp) = SDL_MapRGBA(format, 255, 0, 0, 255); // fills the mipmap with red
		}
	}
	puts("-");

	if (first) first = 0;
}

/////

/*
// this bilinearly filters the previous mipmap level's pixels onto a new section of the mipmap
void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	if (depth == 0) {
		SDL_BlitScaled(image, NULL, mipmap, &dest);
		return;
	}

	const int src_sample_step = 1 << depth;
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	for (int src_y = 0, dest_y = dest.y; src_y < src_size; src_y += src_sample_step, dest_y++) {
		for (int src_x = 0, dest_x = dest.x; src_x < src_size; src_x += src_sample_step, dest_x++) {
			const ivec four_neighbors[4] = { // sample coordinates from the source
				{src_x - 1, src_y}, {src_x + 1, src_y},
				{src_x, src_y - 1}, {src_x, src_y + 1}
			};

			color4_t sum = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 4; i++) {
				const ivec neighbor = four_neighbors[i];

				// if the sample coordinate is within the bounds of the src image
				if (neighbor.x >= 0 && neighbor.y >= 0 && neighbor.x < src_size && neighbor.y < src_size) {
					const Uint32 neighbor_val = *read_surface_pixel(image, neighbor.x, neighbor.y, bpp);
					byte r, g, b, a;
					SDL_GetRGBA(neighbor_val, format, &r, &g, &b, &a);
					sum += (color4_t) {r, g, b, a};
					valid_neighbor_sum++;
				}
			}

			const Uint32 filtered_pixel = SDL_MapRGBA(format,
				sum[0] / valid_neighbor_sum, sum[1] / valid_neighbor_sum,
				sum[2] / valid_neighbor_sum, sum[3] / valid_neighbor_sum);

			*read_surface_pixel(mipmap, dest_x, dest_y, bpp) = filtered_pixel;
		}
	}
}
*/

void filter_mipmap_level(SDL_Surface* const image, SDL_Surface* const mipmap, SDL_Rect dest, const byte depth) {
	(void) depth;
	// SDL_BlitScaled(image, NULL, mipmap, &dest); // for nearest-neighbor, this works

	const SDL_PixelFormat* const format = mipmap -> format;
	const int bpp = format -> BytesPerPixel, src_size = image -> w;

	static byte first = 1;

	for (int dy = dest.y; dy < dest.y + dest.h; dy++) {
		const int rel_dy = dy - dest.y;
		for (int dx = dest.x; dx < dest.x + dest.w; dx++) {
			const int rel_dx = dx - dest.x;

			const ivec sample_src_coords = {rel_dx >> depth, rel_dy >> depth};
			if (first) DEBUG_IVEC(sample_src_coords);
			// *read_surface_pixel(mipmap, dx, dy, bpp) = SDL_MapRGBA(format, 255, 0, 0, 255); // fills the mipmap with red
		}
	}
	puts("-");

	if (first) first = 0;
}

/////