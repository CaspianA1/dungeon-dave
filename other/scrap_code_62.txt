/*
a 2D z-buffer with floats, worst case: 1440 * 900 * 4 = 5,184,000 bytes
a more optimal structure: a list of v_depths

enum {MAX_V_DEPTHS = 20};

typedef struct {
	short start_y, end_y;
	float depth;
} Column;

typedef struct {
	Column columns[MAX_V_DEPTHS];
} ScrColumn;
*/

/////

(void) texture;
(void) src_column;
(void) thing_crop;
(void) screen_pos;
(void) start_x;
(void) end_x;
(void) corrected_dist;
(void) size;

//////////

typedef struct {
	int start_x, end_x;
} VisSpan;

enum {max_vis_spans = 20};
static VisSpan vis_spans[max_vis_spans];
memset(&vis_spans, -1, max_vis_spans * sizeof(VisSpan));

int vis_span_ind = 0;
byte in_vis_span = 0;

// for (; (double) screen_pos.x < end_x; screen_pos.x += settings.ray_column_width) {
for (double x = start_x; x < end_x; x += settings.ray_column_width) {
	if (x < 0.0) continue;

	else if ((double) val_buffer[(int) x].depth > corrected_dist) { // yes, span is visible
		VisSpan* const vis_span = &vis_spans[vis_span_ind];
		if (!in_vis_span) {
			vis_span -> start_x = x;
			in_vis_span = 1;
		}
		else vis_span -> end_x = x;
	}
	else { // no, span is not visible
		if (in_vis_span) {
			vis_spans[vis_span_ind].end_x = x - 1;
			in_vis_span = 0;
		}
	}
}

for (byte i = 0; i < vis_span_ind + 1; i++) {
	VisSpan* const vis_span = &vis_spans[i];
	if (vis_span -> end_x == -1) vis_span -> end_x = end_x;

	printf("vis_span = {%d, %d}\n", vis_span -> start_x, vis_span -> end_x);
	// how are some vis spans able to get a negative start x?
}
puts("---");

/////


/*
const double screen_range = screen_pos.x - vis_span_start;
const double range_over_size = screen_range / size;

screen_pos.w = screen_range;

src_column.x = 
src_column.w = ((double) (d_x - vis_span.start_x) / size) * thing_crop.w;

SDL_RenderCopy(screen.renderer, texture, &src_column, &screen_pos);
*/

/*
const int src_offset = (((double) screen_pos.x - (int) vis_span_start) / size) * thing_crop.w;
src_column.x = src_offset + thing_crop.x;
src_column.w = 
*/

in_vis_span = 0;

/*
src_column.x = (((double) screen_pos.x - start_x) / size) * thing_crop.w;
src_column.w = ((double) (vis_span.end_x - vis_span.start_x) / size) * thing_crop.w;
DEBUG(src_column.w, d);
SDL_RenderCopyF(screen.renderer, texture, &src_column, &screen_pos);
in_vis_span = 0;
*/

/////


/*
screen_pos.w = end_x - start_x;
DEBUG(screen_pos.w, d);
src_column.x = (double) screen_pos.w / size * thing_crop.w;
src_column.w = thing_crop.w;
SDL_RenderCopy(screen.renderer, texture, &src_column, &screen_pos);
*/

/*
for (; (double) screen_pos.x < end_x; screen_pos.x += settings.ray_column_width) {
	if (screen_pos.x < 0.0f || (double) val_buffer[(int) screen_pos.x].depth < corrected_dist) continue;
	const int src_offset = (((double) screen_pos.x - (int) start_x) / size) * thing_crop.w;
	src_column.x = src_offset + thing_crop.x;

	SDL_RenderCopy(screen.renderer, texture, &src_column, &screen_pos);
}
*/

/////

// thing_crop.w += (double) -start_x / size;

if (start_x < 0) {
	// thing_crop.w += -start_x;
	/*
	printf("Time for the magic; add %f\n", (double) screen_pos.x / size * thing_crop.x);
	thing_crop.w += (double) screen_pos.x / size * thing_crop.x;
	*/
}

/////

/*
thing_crop.x = (((double) vis_span_start - (int) start_x) / size) * thing_crop.w;
thing_crop.w *= (double) screen_pos.w / size;
*/

/*
// const int src_offset = (((double) vis_span_start - (int) start_x) / size) * thing_crop.w;
printf("Thing crop w before = %d\n", thing_crop.w);
thing_crop.w *= (double) screen_pos.w / size;
DEBUG(thing_crop.w, d);
*/

/////

/*
const double thing_columns_per_screen_columns = screen_pos.w / size;
thing_crop.w *= thing_columns_per_screen_columns;

if (screen_pos.x < 0) {
	const int screen_columns_lost = -screen_pos.x;
	DEBUG(screen_columns_lost, d);
	DEBUG(thing_columns_per_screen_columns, lf);
	const double thing_columns_lost = screen_columns_lost * thing_columns_per_screen_columns;
	DEBUG(thing_columns_lost, lf);
	puts("---");
}
*/

/*
const double thing_columns_per_screen_columns = screen_pos.w / size;
thing_crop.w *= thing_columns_per_screen_columns;

const double numba = (((double) x - vis_span_start_x) / size) * thing_crop.w;
thing_crop.w = numba;
*/

/////

(void) size;

screen_pos.x = start_x;
screen_pos.w = x - vis_span_start_x; // == dest_x_range

DEBUG(screen_pos.x, d);
DEBUG(screen_pos.w, d);

/*
thing_crop.x += 20;
thing_crop.w -= 20; // find the change amt
*/

/*
DEBUG(thing_crop.x, d);
const double thing_columns_per_screen_columns = screen_pos.w / size;
thing_crop.w *= thing_columns_per_screen_columns;
*/

/*
const double thing_columns_per_screen_columns = screen_pos.w / size;
thing_crop.w *= thing_columns_per_screen_columns;

if (screen_pos.x < 0) {
	const int screen_columns_lost = -screen_pos.x;
	DEBUG(screen_columns_lost, d);
	DEBUG(thing_columns_per_screen_columns, lf);
	const double thing_columns_lost = screen_columns_lost * thing_columns_per_screen_columns;
	DEBUG(thing_columns_lost, lf);
	puts("---");
}
*/

/*
const double thing_columns_per_screen_columns = screen_pos.w / size;
thing_crop.w *= thing_columns_per_screen_columns;

const double numba = (((double) x - vis_span_start_x) / size) * thing_crop.w;
thing_crop.w = numba;
*/

/////

// DEBUG_RECT(thing_crop);

/*
static int a;
if (keys[SDL_SCANCODE_T]) a++;
if (keys[SDL_SCANCODE_Y]) a--;
if (keys[SDL_SCANCODE_U]) a = 0;

screen_pos.x += a;
screen_pos.w += a;
*/

/////

const double thing_cols_per_screen_cols = screen_pos.w / size;
thing_crop.w *= thing_cols_per_screen_cols;

if (screen_pos.x < 0) {
	/*
	// printf("This is where the bug arises\n");
	static int a, b;
	if (keys[SDL_SCANCODE_T]) a++;
	if (keys[SDL_SCANCODE_Y]) a--;
	if (keys[SDL_SCANCODE_U]) a = 0;

	if (keys[SDL_SCANCODE_H]) b++;
	if (keys[SDL_SCANCODE_J]) b--;
	if (keys[SDL_SCANCODE_K]) b = 0;

	thing_crop.x += a;
	thing_crop.w += b;

	DEBUG_RECT(thing_crop);
	*/
}

///// Another attempt at floor interpolation:

vec tex_offset_for_straight_dist(const vec pos, const double straight_dist, const int screen_x) {
	const BufferVal buffer_val = val_buffer[screen_x];
	const double actual_dist = straight_dist * (double) buffer_val.one_over_cos_beta;
	const vec hit = vec_line_pos(pos, buffer_val.dir, actual_dist);
	return vec_tex_offset(hit, ground.size);
}

typedef struct {
	const vec y0, dx, slope;
} FloorLerp;

FloorLerp init_floor_lerp(const vec pos, const double straight_dist) {
	const vec
		y0 = tex_offset_for_straight_dist(pos, straight_dist, 0),
		y1 = tex_offset_for_straight_dist(pos, straight_dist, settings.screen_width - 1);

	const vec dy = y1 - y0;
	DEBUG_VEC(dy);

	const vec dx = vec_fill(settings.screen_width - 1);
	const vec slope = (y1 - y0) / dx;

	return (FloorLerp) {y0, dx, slope};
}

vec floor_lerp_offset(const FloorLerp floor_lerp, const int x) {
	return floor_lerp.y0 + vec_fill(x) * floor_lerp.slope;
}

/////

const FloorLerp floor_lerp = init_floor_lerp(pos, straight_dist);

/////

//////////
vec offset = floor_lerp_offset(floor_lerp, screen_x);
ivec aligned_offset = {(int) offset[0] & 63, (int) offset[1] & 63};
const Uint32 lerp_pixel = ground.pixels[aligned_offset.y * ground.size + aligned_offset.x];
//////////

const Uint32 out = keys[SDL_SCANCODE_T] ? lerp_pixel : pixel;

///// A big chunk of experiments in raycasting that may be useful later:

/*
void draw_colored_rect(const byte, const byte, const byte, const double, const SDL_Rect* const);
const SDL_Rect top = {wall_dest.x, projected_wall_top, 10, 10}, bottom = {wall_dest.x, projected_wall_bottom, 10, 5};
draw_colored_rect(255, 0, 0, 1.0, &top); draw_colored_rect(0, 0, 255, 1.0, &bottom); // red = top, blue = bottom
*/

/* floor = last red to curr blue (initial red = bottom of screen), wall = blue to red
last red = last last wall top, curr blue = curr wall bottom */

/* SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
SDL_RenderDrawLine(screen.renderer, wall_dest.x, projected_wall_bottom, wall_dest.x, projected_wall_top); */
//////////

/* this will work once player heights are accurate to the world
const byte below_highest_point =
	(d -> full_jump_height / settings.screen_height) <= current_level.max_point_height - 1.0;

DEBUG(below_highest_point, d);
if (d -> point_height == current_level.max_point_height && below_highest_point) set exit status; */

///// A very good mark_floor function:

void mark_floor(const DataRaycast* const d, double last_projected_wall_top,
	const double projected_wall_top, const double projected_wall_bottom) {

	const int x = d -> screen_x;

	SDL_SetRenderDrawColor(screen.renderer, 0, 255 / (*d -> last_point_height + 1), 0, SDL_ALPHA_OPAQUE);
	SDL_RenderDrawLine(screen.renderer, x, last_projected_wall_top, x, projected_wall_bottom);
	// floor from last projected_wall_top (red) to current projected_wall_bottom (blue) (green rgb = 0, 255, 0)

	/*
	SDL_Rect bottom_or_top = {x, projected_wall_bottom, 5, 5};
	SDL_SetRenderDrawColor(screen.renderer, 0, 0, 255, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer, &bottom_or_top);

	bottom_or_top.y = projected_wall_top;
	SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer, &bottom_or_top);
	*/
}

///// Some old tests:

// box_blur_test();
// gauss_blur_test();
// menu_test();
start_screen_test();
// lightmap_test();

/////

/*
void lightmap_test(void) {
	SDL_Surface* const test = SDL_CreateRGBSurfaceWithFormat(
		0, current_level.map_size.x, current_level.map_size.y, 32, PIXEL_FORMAT);

	Uint32* read_surface_pixel(const SDL_Surface* const, const int, const int, const int);

	for (int y = 0; y < current_level.map_size.y; y++) {
		for (int x = 0; x < current_level.map_size.x; x++) {
			const byte light_val = calculate_shade(0.0, (vec) {x, y});
			*read_surface_pixel(test, x, y, test -> format -> BytesPerPixel) =
				SDL_MapRGBA(test -> format, light_val, light_val, light_val, 255);
		}
	}

	SDL_SaveBMP(test, "lightmap_sample.bmp");
	SDL_FreeSurface(test);
}
*/

///// An old menu test:

SDL_Rect textbox_1_pos(void) {
	return (SDL_Rect) {0, 0, settings.half_screen_width >> 1, settings.half_screen_height >> 1};
}

SDL_Rect textbox_2_pos(void) {
	return (SDL_Rect) {settings.half_screen_width, settings.half_screen_height, settings.screen_width / 10, settings.screen_height / 10};
}

InputStatus textbox_1_on_click(void) {
	puts("Clicked textbox 1");
	return Exit;
}

InputStatus textbox_2_on_click(void) {
	puts("Clicked textbox 2");
	return ProceedAsNormal;
}

void menu_test(void) {
	const Menu menu = init_menu((Color3) {205, 92, 92}, (Color3) {135, 206, 235}, (Color3) {0, 255, 0}, 2,
		textbox_1_pos, textbox_1_on_click, "Textbox 1",
		textbox_2_pos, textbox_2_on_click, "Textbox 2");

	menu_loop(&menu);
}

/////

void start_screen_test(void) {
	const Menu start_screen = init_menu((Color3) {255, 99, 71}, (Color3) {139, 0, 0}, (Color3) {228, 29, 29}, 1,
		start_button_pos, start_button_on_click, "Start!");

	menu_loop(&start_screen);
}

/////

menu_test();
start_screen_test();

/////

else if (mouse_pos.x <= 1) {
	SDL_WarpMouseInWindow(screen.window, settings.screen_width - 1, mouse_pos.y);
	printf("Warp from left, where the original pos is %d, ", mouse_pos.x);
	SDL_GetMouseState(&mouse_pos.x, &mouse_pos.y);
	printf("and the new left position is %d\n", mouse_pos.x);
}

///// These are the calculations needed for one pixel:

const BufferVal buffer_val = val_buffer[screen_x];
const double actual_dist = straight_dist * (double) buffer_val.one_over_cos_beta;
const vec hit = buffer_val.dir * vec_fill(actual_dist) + pos;
const vec offset = vec_fill(ground.size) * (hit - vec_trunc(hit));
//////////
static const double small = 0.000000001;
const vec lightmap_pos = (hit - vec_fill(small)) * vec_fill(lightmap_samples_per_tile);
const Lightmap lightmap = current_level.lightmap;
const byte shade = lightmap.data[(int) lightmap_pos[1] * lightmap.size.x + (int) lightmap_pos[0]];
//////////
pixbuf_row[screen_x] = shade_ARGB_pixel(ground.pixels[(long) ((long) offset[1] * ground.size + offset[0])], shade);

/////

void check_err(void) {
	const GLenum error = glGetError();
	if (error != GL_NO_ERROR) printf("There is an opengl error: %d\n", error);
}

/////

/*
row = (y_shift - pace) - half_screen_height - y_pitch + 1
row = ((half_screen_height + y_pitch + pace) - pace) - half_screen_height - y_pitch + 1
row = (half_screen_height + y_pitch) - half_screen_height - y_pitch + 1
row = 1

pace_y = y + pace
pace_y = (y_shift - pace) + pace
pace_y = y_shift
*/

/////

const double p_height, const int pace, int y_shift, const int y_pitch) {

(void) y_pitch;

const double screen_height_proj_ratio = settings.screen_height / settings.proj_dist;
const double world_height = p_height - floor_height / screen_height_proj_ratio;

// if the player is under the floor plane
if (world_height < settings.plane_bottom) return;

const double opp_h = 0.5 + world_height * screen_height_proj_ratio;

/*
start = y_shift - pace
end = screen_height - pace

diff = (screen_height - pace) - (y_shift - pace)
diff = (screen_height - pace) - y_shift + pace
diff = screen_height - pace - y_shift + pace
diff = screen_height - y_shift
*/

/*
puts("-");
DEBUG(settings.screen_height - y_shift, d);
*/
// for (int y = y_shift - pace, row = 1; y < settings.screen_height - pace; y++, row++) {
for (int row = 1; row <= settings.screen_height - y_shift; row++) {
	// DEBUG(row, d);

///// The old floorcast floor height code:

/* const double screen_height_proj_ratio = settings.screen_height / settings.proj_dist;
const double world_height = p_height - floor_height / screen_height_proj_ratio;

if (world_height < settings.plane_bottom) return; // if the player is under the floor plane
const double opp_h = 0.5 + world_height * screen_height_proj_ratio; */

/////

/*
(void) tilt;
(void) lstrafe;
(void) strafe;

static char last_input_direction = 0;
const char input_direction = (lstrafe << 1) - strafe; // 1 -> left, 0 -> no strafe, -1 -> right
char final_direction = input_direction;

if (last_input_direction == 1 && input_direction != 1 && tilt -> val > 0.0) final_direction = -1;
else if (last_input_direction == -1 && input_direction != -1 && tilt -> val < -0.0) final_direction = 1;

tilt -> val += tilt -> step * final_direction;
if (input_direction) last_input_direction = input_direction;
*/

/*

/////

/*
static double last_theta = -1.0;
const double delta_theta = theta - last_theta;

double tilt_change = tilt -> step;

if (last_theta != -1.0) {
	const double turn_tilt_change = (delta_theta / 360.0) * 5.0;
	DEBUG(turn_tilt_change, lf);
	tilt_change += turn_tilt_change;
}

last_theta = theta;

//////////

if (strafe || delta_theta != 0.0) {
	tilt -> val += lstrafe ? tilt_change : -tilt_change;

	if (tilt -> val > tilt -> max)
		tilt -> val = tilt -> max;
	else if (tilt -> val < -tilt -> max)
		tilt -> val = -tilt -> max;
}

else if (tilt -> val + tilt -> step < 0.0) tilt -> val += tilt -> step;
else if (tilt -> val - tilt -> step > 0.0) tilt -> val -= tilt -> step;
*/


/////

// tilt_change += (fabs(delta_theta) / 360.0) * percent_v * 5.0;

///// A version of the tilting code that allowed for tilting based on turning (it was too disorienting):

static double last_theta = -1.0;
const double delta_theta = theta - last_theta;

const byte tilting_from_turn = delta_theta != 0.0;
const byte should_tilt = strafe || tilting_from_turn;
const byte tilt_left = lstrafe || (delta_theta < 0.0);

double tilt_change = 0.0;

if (strafe) tilt_change += tilt -> step;

if (tilting_from_turn && last_theta != -1.0) {
	tilt_change += 0.1;
	if (tilt -> val == 0.1) tilt_change = 0.0;
}

last_theta = theta;

if (should_tilt) {
	tilt -> val += tilt_left ? tilt_change : -tilt_change;

	if (tilt -> val > tilt -> max)
		tilt -> val = tilt -> max;
	else if (tilt -> val < -tilt -> max)
		tilt -> val = -tilt -> max;
}

else if (tilt -> val + tilt -> step < 0.0) tilt -> val += tilt -> step;
else if (tilt -> val - tilt -> step > 0.0) tilt -> val -= tilt -> step;

/////

DEBUG(cast_start, d);
DEBUG(cast_end, d);
DEBUG((double) (cast_end - cast_start) / total_drawers, lf);
puts("---");

/////

/*
pthread_t thread;
pthread_create(&thread, NULL, floorcast_caller, &fcp);
pthread_join(thread, NULL);
*/

/////