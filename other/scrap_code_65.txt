///// My fast closest_pow_2 version that rounded up:

inlinable int my_closest_pow_2(const int x) {
	return 1 << (sizeof(x) * 8 - num_leading_zeroes(x));
}

///// Another version of that (did not round up on power of 2 inputs):

static int nearest_pow(int num) {
	int n = num > 0 ? num - 1 : 0;

	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;

	return n + 1;
}

///// And the num_leading_zeroes function:

#define num_leading_zeroes __builtin_clz

///// The attempt at screen scaling:

/*
DEBUG(mipmap -> size.y, d);
const double tex_to_scr = mipmap -> size.y / (double) wall_h;
double level = tex_to_scr * mipmap -> max_mipmap_depth;
// level = log2(level + 1);
DEBUG(level, lf);
*/

/////

void add_temp_thing(Thing (*const spawner)(void), byte (*thing_done_spawning)) {
	if (current_level.thing_count < current_level.max_alloc_thing_count) {
		current_level.thing_container = realloc(current_level.thing_container, ++current_level.max_alloc_thing_count);
	}
	current_level.thing_count++;
}

// - need an indication of when a thing is done in-game, and when so, don't spawn it anymore

/////

const int orig_size = mipmap -> size.y; // orig_size = full w and h of the original full-res texture

/*
int pow = one_plus_exp_for_pow_2(orig_size) - 1 - log2(wall_h);
if (pow > orig_size) pow = orig_size;
return get_mipmap_crop(orig_size, pow);
*/

int pow_2 = log2(wall_h); // nearest_pow_2(wall_h);
if (pow_2 > orig_size) pow_2 = orig_size;

char depth_offset = one_plus_exp_for_pow_2(orig_size) - one_plus_exp_for_pow_2(pow_2);
if (depth_offset < 0) depth_offset = 0;

return get_mipmap_crop(orig_size, one_plus_exp_for_pow_2(pow_2) - 1);

/////