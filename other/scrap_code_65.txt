///// My fast closest_pow_2 version that rounded up:

inlinable int my_closest_pow_2(const int x) {
	return 1 << (sizeof(x) * 8 - num_leading_zeroes(x));
}

///// Another version of that (did not round up on power of 2 inputs):

static int nearest_pow(int num) {
	int n = num > 0 ? num - 1 : 0;

	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;

	return n + 1;
}

///// And the num_leading_zeroes function:

#define num_leading_zeroes __builtin_clz

///// The attempt at screen scaling:

/*
DEBUG(mipmap -> size.y, d);
const double tex_to_scr = mipmap -> size.y / (double) wall_h;
double level = tex_to_scr * mipmap -> max_mipmap_depth;
// level = log2(level + 1);
DEBUG(level, lf);
*/

/////

void add_temp_thing(Thing (*const spawner)(void), byte (*thing_done_spawning)) {
	if (current_level.thing_count < current_level.max_alloc_thing_count) {
		current_level.thing_container = realloc(current_level.thing_container, ++current_level.max_alloc_thing_count);
	}
	current_level.thing_count++;
}

// - need an indication of when a thing is done in-game, and when so, don't spawn it anymore

/////

const int orig_size = mipmap -> size.y; // orig_size = full w and h of the original full-res texture

/*
int pow = one_plus_exp_for_pow_2(orig_size) - 1 - log2(wall_h);
if (pow > orig_size) pow = orig_size;
return get_mipmap_crop(orig_size, pow);
*/

int pow_2 = log2(wall_h); // nearest_pow_2(wall_h);
if (pow_2 > orig_size) pow_2 = orig_size;

char depth_offset = one_plus_exp_for_pow_2(orig_size) - one_plus_exp_for_pow_2(pow_2);
if (depth_offset < 0) depth_offset = 0;

return get_mipmap_crop(orig_size, one_plus_exp_for_pow_2(pow_2) - 1);

/////

float max_enemy_instance_height = DBL_MIN;
for (byte i = 0; i < current_level.enemy_instance_count; i++) {
	const float enemy_instance_height = current_level.enemy_instances[i].billboard_data.height;
	if (enemy_instance_height > max_enemy_instance_height) max_enemy_instance_height = enemy_instance_height;
}
max_enemy_instance_height++; // enemies have a height of 1, hitscans should only stop once fully over an enemy

/////

/*
void y_pitch_test(const int horizon_line, Player* const player) {
	const SDL_Rect horizon_rect = {0, horizon_line, settings.screen_width, 1};
	SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer, &horizon_rect);

	// DEBUG(player -> y_pitch, d);

	if (keys[SDL_SCANCODE_T]) {
		player -> pos[0] = round(player -> pos[0]);
		player -> pos[1] = round(player -> pos[1]);
	}

	const double max_down_pitch_angle = atan(2.0);
	const double y_pitch_percent = (double) player -> y_pitch / (INIT_H / 2);

	const double view_angle = max_down_pitch_angle * y_pitch_percent;
	const double view_angle_degrees = view_angle * 180.0 / M_PI;
	(void) view_angle_degrees;
	// DEBUG(view_angle_degrees, lf);

	const double all_tilt = player -> y_pitch + player -> pace.screen_offset;
	DEBUG(all_tilt, lf);

	const double test_tilt = atan(all_tilt / settings.proj_dist);
	DEBUG(test_tilt * 180.0 / M_PI, lf);
}
*/

///// Old max_height checking; only useful for if aiming upwards

////////// This stops unnecessary hitscan iterations
float max_enemy_instance_height = DBL_MIN;
for (byte i = 0; i < current_level.enemy_instance_count; i++) {
	const float enemy_instance_height = current_level.enemy_instances[i].billboard_data.height;
	if (enemy_instance_height > max_enemy_instance_height) max_enemy_instance_height = enemy_instance_height;
}
max_enemy_instance_height++; // enemies have a height of 1, hitscans should only stop once fully over an enemy
//////////

/////

#define print_bbx_3D(bbx)\
	printf(#bbx " = {.origin = {%lf, %lf, %lf}, .size = {%lf, %lf, %lf}}\n",\
		(double) bbx.origin[0], (double) bbx.origin[1], (double) bbx.origin[2],\
		(double) bbx.size[0], (double) bbx.size[1], (double) bbx.size[2]);\
	
///// The old hitscan code:

/*
typedef struct {
	vec pos;
	const vec dir;
	double dist;
} Hitscan;

inlinable byte iter_hitscan(Hitscan* const hitscan) {
	hitscan -> pos += hitscan -> dir * vec_fill(weapon_hitscan_step);
	hitscan -> dist += weapon_hitscan_step;
	return !vec_out_of_bounds(hitscan -> pos);
}
*/

/*
void shoot_weapon(const Weapon* const weapon, const Player* const player) {
	const vec p_pos = player -> pos, p_dir = player -> dir;
	const double p_height = player -> jump.height;

	(void) p_height;

	Hitscan hitscan = {p_pos, p_dir, 0.0};
	const byte short_range_weapon = bit_is_set(weapon -> status, mask_short_range_weapon);

	while (iter_hitscan(&hitscan)) {
		const BoundingBox projectile_box = init_bounding_box(hitscan.pos, projectile_size);
		byte collided = 0;

		for (byte i = 0; i < current_level.enemy_instance_count; i++) {
			EnemyInstance* const enemy_instance = current_level.enemy_instances + i;
			if (enemy_instance -> state == Dead || !bit_is_set(enemy_instance -> status, mask_weapon_y_pitch_in_range_of_enemy))
				continue;

			const BoundingBox enemy_box = init_bounding_box(enemy_instance -> billboard_data.pos, actor_box_side_len);
			if (aabb_collision(projectile_box, enemy_box)) {
				set_bit(enemy_instance -> status, mask_recently_attacked_enemy);
				enemy_instance -> hp -= weapon -> power;

				void set_enemy_instance_state(EnemyInstance* const, const EnemyState, const byte, const vec, const double);

				if (enemy_instance -> hp <= 0.0)
					set_enemy_instance_state(enemy_instance, Dead, 0, p_pos, p_height);
				else
					play_sound_from_billboard_data(
					enemy_instance -> enemy -> sounds + 4, // attacked
					&enemy_instance -> billboard_data, p_pos, p_height);

				collided = 1;
			}
		}
		if (collided || short_range_weapon) break;
	}
}
*/

/////

/* If the player's weapon has a y-pitch that is within the vertical bounds of the enemy, 
a flag is set in the enemy instance to allow them to be attacked by a weapon */
void update_enemy_weapon_y_state(EnemyInstance* const enemy_instance, const SDL_FRect* const thing_screen_pos) {
	const byte weapon_y_matches_enemy_y =
		settings.half_screen_height >= thing_screen_pos -> y &&
		thing_screen_pos -> y + thing_screen_pos -> h >= settings.half_screen_height;

	bit_to_x(enemy_instance -> status, mask_weapon_y_pitch_in_range_of_enemy, weapon_y_matches_enemy_y);
}

/////

/*
if (nav == &current_level.enemy_instances[7].nav) {
	for (int i = 0; i < nav -> route.length; i++) {
		const vec pos = nav -> route.data[i];
		if (*map_point(current_level.wallmap, pos[0], pos[1])) puts("Warning, in a wall");
		else DEBUG_VEC(pos);
	}
}
*/

/*
const byte trooper = nav == &current_level.enemy_instances[7].nav;
if (nav -> route.length == 1 && trooper) {
	puts("The route length is 1");
}
else if (trooper) printf("The route length is not 1: %d\n", nav -> route.length);
*/

/////

const vec last_pos = route -> data[end_ind];
printf("End pos: {%lf, %lf}\n", last_pos[0], last_pos[1]);
DEBUG(route -> length, d);
puts("---");

/*
else {
	const vec last_pos = route -> data[end_ind];
	*nav -> pos = (vec) {(int) last_pos[0], (int) last_pos[1]} + vec_fill(0.5);
}
*/

/////

/*
const EnemyInstance* const trooper = current_level.enemy_instances + 7;
const vec trooper_pos = trooper -> billboard_data.pos;
const byte in_wall = !!*map_point(current_level.wallmap, trooper_pos[0], trooper_pos[1]);
const int path_len = trooper -> nav.route.length;
DEBUG_VEC(trooper_pos);
DEBUG(in_wall, d);
DEBUG(path_len, d);
puts("---");
*/

/////

/*
const vec last_pos = route -> data[end_ind];
if (last_pos[0] == 0.0 && last_pos[1] == 0.0) {
	printf("Last is zero; route -> length = %d, end_ind = %d\n", route -> length, end_ind);
	for (int i = 0; i < route -> length; i++) {
		const vec node = route -> data[i];
		printf("{%lf, %lf} ", node[0], node[1]);
	}
	putchar('\n');
}
*/

/*
DEBUG(end_ind, d);
DEBUG(route -> length, d);
if (end_ind >= route -> length) puts("Problem");
puts("---");
*/

// in some cases, the end ind is often longer than the route length, which shouldn't be

/////

/*
projectiles: one billboard
they can't have a tracer and billboard
perhaps make a billboard, billboard -> tracer, update tracer, tracer -> billboard
a new tracer type, which is just a billboard (?)
need to store a dir though

projectile details in weapon.c; projectile type = of DataBillboard and step
projectile -> tracer -> projectile
*/

/////

memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');	


/*
for (int i = del_ind; i < len; i++) {
	test_array[i] = test_array[i + 1];
}

for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');
*/
//////////

/////

//////////
enum {len = 5};
byte test_array[len] = {4, 5, 6, 7, 8};

int del_ind = 2;

memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');	


/*
for (int i = del_ind; i < len; i++) {
	test_array[i] = test_array[i + 1];
}

for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');
*/
//////////

/////

inlinable void delete_from_array(void* array, const int del_ind, const int length) {
	// memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
	memmove(array + del_ind, array + del_ind + 1, length - del_ind - 1);
}

/////

/*
if (current_level.projectile_count > 0) puts("All projectiles:");
for (byte i = 0; i < current_level.projectile_count; i++)
	printf("%lf ", (double) current_level.projectiles[i].tracer.pos[0]);
if (current_level.projectile_count > 0) puts("\n---");
else puts("No projectiles");
*/

/////


	/*
	byte i = 0;
	while (i < current_level.projectile_count) {
		Projectile* const projectile_ref = current_level.projectiles + i;
		printf("i = %d, {%lf, %lf}\n", i, (double) projectile_ref -> tracer.pos[0], (double) projectile_ref -> tracer.pos[1]);	

		enum {s = 4};
		int foo[s] = {1, 2, 3, 4};

		for (int i = 1; i < s - 1; i++) {
		}

		for (int i = 0; i < s; i++) {
			printf("%d ", foo[i]);
		}
		putchar('\n');

		i++;
	}
	*/

/////

			/*
			for (int j = i; j < current_level.projectile_count - 1; j++) {
				// current_level.projectiles[j] = current_level.projectiles[j + 1];
				const Projectile ahead = current_level.projectiles[j + 1];
				memcpy(current_level.projectiles + j, &ahead, sizeof(Projectile));
			}
			memset(current_level.projectiles + current_level.projectile_count - 1, 0, sizeof(Projectile));
			*/

			/*
			enum {s = 5};
			int t[s] = {1, 2, 3, 4, 5};
			for (int j = 1; j < s - 1; j++) {
				t[j] = t[j + 1];
			}
			for (int j = 0; j < s; j++) {
				printf("%d ", t[j]);
			}
			putchar('\n');
			*/

/////

	#define PR_LIST(msg)\
		puts(msg ":");\
		for (byte i = 0; i < current_level.projectile_count; i++)\
			printf("i = %d, {%lf, %lf}\n", i, (double) current_level.projectiles[i].tracer.pos[0], (double) current_level.projectiles[i].tracer.pos[1]);\
		putchar('\n');

/////

/* On the topic of filling the thing buffer just once:
	- It would work for still things and teleporters without any extra hassle
	- Animated things and enemies would have to have their frame origins updated
	- For intra (between-frame) projectiles, they would have to be dynamically removed and added */

///// Hints:

	/*
	int a = SDL_SetHintWithPriority(SDL_HINT_FRAMEBUFFER_ACCELERATION, "2", SDL_HINT_OVERRIDE);
	int b = SDL_SetHintWithPriority(SDL_HINT_RENDER_BATCHING, "1", SDL_HINT_OVERRIDE);
	DEBUG(a, d);
	DEBUG(b, d);
	*/

	// SDL_SetHintWithPriority(SDL_HINT_RENDER_SCALE_QUALITY, "1", SDL_HINT_OVERRIDE);

///// The antialiased_downscale_by_2 function:

void antialiased_downscale_by_2(const SDL_Surface* const orig,
	SDL_Surface* const mipmap, const ivec dest_origin, const byte scale_factor) {

	const byte dec_scale_factor = scale_factor - 1;
	const int orig_size = orig -> w;

	const SDL_PixelFormat* const format = orig -> format;
	const int bpp = format -> BytesPerPixel, inc_across = 1 << dec_scale_factor;

	for (int y = 0; y < orig_size; y += inc_across) {
		for (int x = 0; x < orig_size; x += inc_across) {
			const int dec_x = x - 1, dec_y = y - 1, inc_x = x + 1, inc_y = y + 1;

			const ivec pixel_group[9] = {
				{dec_x, dec_y}, {x, dec_y}, {inc_x, dec_y},
				{dec_x, y}, 	{x, y}, 	{inc_x, y},
				{dec_x, inc_y}, {x, inc_y}, {inc_x, inc_y}
			};

			int sum[4] = {0, 0, 0, 0};
			byte valid_neighbor_sum = 0;

			for (byte i = 0; i < 9; i++) {
				const ivec pixel_pos = pixel_group[i];

				if (pixel_pos.x >= 0 && pixel_pos.y >= 0 && pixel_pos.x < orig_size && pixel_pos.y < orig_size) {
					const Uint32 neighbor = *read_surface_pixel(orig, pixel_pos.x, pixel_pos.y, bpp);

					sum[0] += (byte) (neighbor >> 24);
					sum[1] += (byte) (neighbor >> 16);
					sum[2] += (byte) (neighbor >> 8);
					sum[3] += (byte) neighbor;
					valid_neighbor_sum++;
				}
			}

			const Uint32 result = SDL_MapRGBA(format, sum[1] / valid_neighbor_sum, sum[2] / valid_neighbor_sum,
				sum[3] / valid_neighbor_sum, sum[0] / valid_neighbor_sum);

			*read_surface_pixel(mipmap, (x >> dec_scale_factor) + dest_origin.x, (y >> dec_scale_factor) + dest_origin.y, bpp) = result;
		}
	}
}

///// And the old load_mipmap with that:

// returns null if the image dimensions aren't powers of 2
SDL_Surface* load_mipmap(SDL_Surface* const image, byte* const depth_ref) {
	const int image_size = image -> w; // image must have uniform dimensions
	if (!is_pow_of_2(image_size) || !is_pow_of_2(image -> h)) return NULL;

	SDL_Surface* const mipmap = SDL_CreateRGBSurfaceWithFormat(0,
		image_size + (image_size >> 1), image_size, PIXEL_FORMAT_DEPTH, PIXEL_FORMAT);

	byte depth = 0;

	#ifdef ANTIALIASED_MIPMAPPING

	SDL_LockSurface(image);
	SDL_LockSurface(mipmap);

	int dest_size = image_size;
	ivec dest_origin = {0, 0};
	while (dest_size != 0) {
		if (depth >= 2) dest_origin.y += image_size >> (depth - 1);
		antialiased_downscale_by_2(image, mipmap, dest_origin, depth + 1);

		dest_origin.x = image_size;
		dest_size >>= 1;
		depth++;
	}

	SDL_UnlockSurface(image);
	SDL_UnlockSurface(mipmap);

	#else

	SDL_Rect dest = {0, 0, image_size, image_size};
	SDL_Rect last_dest = dest;
	SDL_BlitSurface(image, NULL, mipmap, &dest);

	while (dest.w != 0) {
		if (depth >= 2) dest.y += image_size >> (depth - 1);

		SDL_BlitScaled(mipmap, &last_dest, mipmap, &dest);
		last_dest = dest;

		dest.x = image_size;
		dest.w >>= 1;
		dest.h >>= 1;
		depth++;
	}

	#endif

	/*
	static byte first = 1, id = 0;
	if (first) {
		system("mkdir -p imgs");
		first = 0;
	}

	char buf[15];
	sprintf(buf, "imgs/out_%d.bmp", id);
	SDL_SaveBMP(mipmap, buf);
	id++;
	*/

	*depth_ref = depth;
	return mipmap;
}

/////


	/*
	SDL_Surface* const mipmap = load_mipmap(surface, &sprite.max_mipmap_depth);
	if (mipmap == NULL) {
		FAIL("The sprite with the path %s must have dimensions that are powers of two\n", path);
	}
	else {
		SDL_FreeSurface(surface); // free the previous surface
		surface = mipmap; // replace it with the mipmap
	}

	sprite.texture = SDL_CreateTextureFromSurface(screen.renderer, surface); // make a texture from the surface
	#endif

	SDL_FreeSurface(surface); // free the surface, it isn't used anymore

	sprite.size = (ivec) {surface -> w, surface -> h};
	*/

/////

printf("projectile_box.origin = {%f, %f, %f}\n",
	(double) projectile_box.origin[0], (double) projectile_box.origin[1], (double) projectile_box.origin[2]);

/////