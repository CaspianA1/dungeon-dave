///// My fast closest_pow_2 version that rounded up:

inlinable int my_closest_pow_2(const int x) {
	return 1 << (sizeof(x) * 8 - num_leading_zeroes(x));
}

///// Another version of that (did not round up on power of 2 inputs):

static int nearest_pow(int num) {
	int n = num > 0 ? num - 1 : 0;

	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;

	return n + 1;
}

///// And the num_leading_zeroes function:

#define num_leading_zeroes __builtin_clz

///// The attempt at screen scaling:

/*
DEBUG(mipmap -> size.y, d);
const double tex_to_scr = mipmap -> size.y / (double) wall_h;
double level = tex_to_scr * mipmap -> max_mipmap_depth;
// level = log2(level + 1);
DEBUG(level, lf);
*/

/////

void add_temp_thing(Thing (*const spawner)(void), byte (*thing_done_spawning)) {
	if (current_level.thing_count < current_level.max_alloc_thing_count) {
		current_level.thing_container = realloc(current_level.thing_container, ++current_level.max_alloc_thing_count);
	}
	current_level.thing_count++;
}

// - need an indication of when a thing is done in-game, and when so, don't spawn it anymore

/////

const int orig_size = mipmap -> size.y; // orig_size = full w and h of the original full-res texture

/*
int pow = one_plus_exp_for_pow_2(orig_size) - 1 - log2(wall_h);
if (pow > orig_size) pow = orig_size;
return get_mipmap_crop(orig_size, pow);
*/

int pow_2 = log2(wall_h); // nearest_pow_2(wall_h);
if (pow_2 > orig_size) pow_2 = orig_size;

char depth_offset = one_plus_exp_for_pow_2(orig_size) - one_plus_exp_for_pow_2(pow_2);
if (depth_offset < 0) depth_offset = 0;

return get_mipmap_crop(orig_size, one_plus_exp_for_pow_2(pow_2) - 1);

/////

float max_enemy_instance_height = DBL_MIN;
for (byte i = 0; i < current_level.enemy_instance_count; i++) {
	const float enemy_instance_height = current_level.enemy_instances[i].billboard_data.height;
	if (enemy_instance_height > max_enemy_instance_height) max_enemy_instance_height = enemy_instance_height;
}
max_enemy_instance_height++; // enemies have a height of 1, hitscans should only stop once fully over an enemy

/////

/*
void y_pitch_test(const int horizon_line, Player* const player) {
	const SDL_Rect horizon_rect = {0, horizon_line, settings.screen_width, 1};
	SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer, &horizon_rect);

	// DEBUG(player -> y_pitch, d);

	if (keys[SDL_SCANCODE_T]) {
		player -> pos[0] = round(player -> pos[0]);
		player -> pos[1] = round(player -> pos[1]);
	}

	const double max_down_pitch_angle = atan(2.0);
	const double y_pitch_percent = (double) player -> y_pitch / (INIT_H / 2);

	const double view_angle = max_down_pitch_angle * y_pitch_percent;
	const double view_angle_degrees = view_angle * 180.0 / M_PI;
	(void) view_angle_degrees;
	// DEBUG(view_angle_degrees, lf);

	const double all_tilt = player -> y_pitch + player -> pace.screen_offset;
	DEBUG(all_tilt, lf);

	const double test_tilt = atan(all_tilt / settings.proj_dist);
	DEBUG(test_tilt * 180.0 / M_PI, lf);
}
*/

///// Old max_height checking; only useful for if aiming upwards

////////// This stops unnecessary hitscan iterations
float max_enemy_instance_height = DBL_MIN;
for (byte i = 0; i < current_level.enemy_instance_count; i++) {
	const float enemy_instance_height = current_level.enemy_instances[i].billboard_data.height;
	if (enemy_instance_height > max_enemy_instance_height) max_enemy_instance_height = enemy_instance_height;
}
max_enemy_instance_height++; // enemies have a height of 1, hitscans should only stop once fully over an enemy
//////////

/////

#define print_bbx_3D(bbx)\
	printf(#bbx " = {.origin = {%lf, %lf, %lf}, .size = {%lf, %lf, %lf}}\n",\
		(double) bbx.origin[0], (double) bbx.origin[1], (double) bbx.origin[2],\
		(double) bbx.size[0], (double) bbx.size[1], (double) bbx.size[2]);\
	
///// The old hitscan code:

/*
typedef struct {
	vec pos;
	const vec dir;
	double dist;
} Hitscan;

inlinable byte iter_hitscan(Hitscan* const hitscan) {
	hitscan -> pos += hitscan -> dir * vec_fill(weapon_hitscan_step);
	hitscan -> dist += weapon_hitscan_step;
	return !vec_out_of_bounds(hitscan -> pos);
}
*/

/*
void shoot_weapon(const Weapon* const weapon, const Player* const player) {
	const vec p_pos = player -> pos, p_dir = player -> dir;
	const double p_height = player -> jump.height;

	(void) p_height;

	Hitscan hitscan = {p_pos, p_dir, 0.0};
	const byte short_range_weapon = bit_is_set(weapon -> status, mask_short_range_weapon);

	while (iter_hitscan(&hitscan)) {
		const BoundingBox projectile_box = init_bounding_box(hitscan.pos, projectile_size);
		byte collided = 0;

		for (byte i = 0; i < current_level.enemy_instance_count; i++) {
			EnemyInstance* const enemy_instance = current_level.enemy_instances + i;
			if (enemy_instance -> state == Dead || !bit_is_set(enemy_instance -> status, mask_weapon_y_pitch_in_range_of_enemy))
				continue;

			const BoundingBox enemy_box = init_bounding_box(enemy_instance -> billboard_data.pos, actor_box_side_len);
			if (aabb_collision(projectile_box, enemy_box)) {
				set_bit(enemy_instance -> status, mask_recently_attacked_enemy);
				enemy_instance -> hp -= weapon -> power;

				void set_enemy_instance_state(EnemyInstance* const, const EnemyState, const byte, const vec, const double);

				if (enemy_instance -> hp <= 0.0)
					set_enemy_instance_state(enemy_instance, Dead, 0, p_pos, p_height);
				else
					play_sound_from_billboard_data(
					enemy_instance -> enemy -> sounds + 4, // attacked
					&enemy_instance -> billboard_data, p_pos, p_height);

				collided = 1;
			}
		}
		if (collided || short_range_weapon) break;
	}
}
*/

/////

/* If the player's weapon has a y-pitch that is within the vertical bounds of the enemy, 
a flag is set in the enemy instance to allow them to be attacked by a weapon */
void update_enemy_weapon_y_state(EnemyInstance* const enemy_instance, const SDL_FRect* const thing_screen_pos) {
	const byte weapon_y_matches_enemy_y =
		settings.half_screen_height >= thing_screen_pos -> y &&
		thing_screen_pos -> y + thing_screen_pos -> h >= settings.half_screen_height;

	bit_to_x(enemy_instance -> status, mask_weapon_y_pitch_in_range_of_enemy, weapon_y_matches_enemy_y);
}

/////

/*
if (nav == &current_level.enemy_instances[7].nav) {
	for (int i = 0; i < nav -> route.length; i++) {
		const vec pos = nav -> route.data[i];
		if (*map_point(current_level.wallmap, pos[0], pos[1])) puts("Warning, in a wall");
		else DEBUG_VEC(pos);
	}
}
*/

/*
const byte trooper = nav == &current_level.enemy_instances[7].nav;
if (nav -> route.length == 1 && trooper) {
	puts("The route length is 1");
}
else if (trooper) printf("The route length is not 1: %d\n", nav -> route.length);
*/

/////

const vec last_pos = route -> data[end_ind];
printf("End pos: {%lf, %lf}\n", last_pos[0], last_pos[1]);
DEBUG(route -> length, d);
puts("---");

/*
else {
	const vec last_pos = route -> data[end_ind];
	*nav -> pos = (vec) {(int) last_pos[0], (int) last_pos[1]} + vec_fill(0.5);
}
*/

/////

/*
const EnemyInstance* const trooper = current_level.enemy_instances + 7;
const vec trooper_pos = trooper -> billboard_data.pos;
const byte in_wall = !!*map_point(current_level.wallmap, trooper_pos[0], trooper_pos[1]);
const int path_len = trooper -> nav.route.length;
DEBUG_VEC(trooper_pos);
DEBUG(in_wall, d);
DEBUG(path_len, d);
puts("---");
*/

/////

/*
const vec last_pos = route -> data[end_ind];
if (last_pos[0] == 0.0 && last_pos[1] == 0.0) {
	printf("Last is zero; route -> length = %d, end_ind = %d\n", route -> length, end_ind);
	for (int i = 0; i < route -> length; i++) {
		const vec node = route -> data[i];
		printf("{%lf, %lf} ", node[0], node[1]);
	}
	putchar('\n');
}
*/

/*
DEBUG(end_ind, d);
DEBUG(route -> length, d);
if (end_ind >= route -> length) puts("Problem");
puts("---");
*/

// in some cases, the end ind is often longer than the route length, which shouldn't be

/////

/*
projectiles: one billboard
they can't have a tracer and billboard
perhaps make a billboard, billboard -> tracer, update tracer, tracer -> billboard
a new tracer type, which is just a billboard (?)
need to store a dir though

projectile details in weapon.c; projectile type = of DataBillboard and step
projectile -> tracer -> projectile
*/

/////

memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');	


/*
for (int i = del_ind; i < len; i++) {
	test_array[i] = test_array[i + 1];
}

for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');
*/
//////////

/////

//////////
enum {len = 5};
byte test_array[len] = {4, 5, 6, 7, 8};

int del_ind = 2;

memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');	


/*
for (int i = del_ind; i < len; i++) {
	test_array[i] = test_array[i + 1];
}

for (int i = 0; i < 5; i++) {
	printf("%d ", test_array[i]);
}
putchar('\n');
*/
//////////

/////

inlinable void delete_from_array(void* array, const int del_ind, const int length) {
	// memmove(test_array + del_ind, test_array + del_ind + 1, len - del_ind - 1);
	memmove(array + del_ind, array + del_ind + 1, length - del_ind - 1);
}

/////

/*
if (current_level.projectile_count > 0) puts("All projectiles:");
for (byte i = 0; i < current_level.projectile_count; i++)
	printf("%lf ", (double) current_level.projectiles[i].tracer.pos[0]);
if (current_level.projectile_count > 0) puts("\n---");
else puts("No projectiles");
*/

/////