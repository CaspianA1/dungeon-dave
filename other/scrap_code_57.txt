///// An attempt at thing ranges:

typedef struct {
	int start, end;
} RangeX;

RangeX visible[5] = {0};
byte range_ind = 0, in_visible_block = 1;

#define obscured_x (double) val_buffer[screen_row].depth < corrected_dist
#define print_range(r) printf("{%d, %d}, ", r.start, r.end);

for (int screen_row = start_x; screen_row < end_x; screen_row += settings.ray_column_width) {
	if (screen_row < 0) continue;

	else if (obscured_x) {
		if (in_visible_block) range_ind++;
		in_visible_block = 0;
	}
	else {
		RangeX* const visible_range = &visible[range_ind];

		if (!in_visible_block) visible_range -> start = screen_row;
		else visible_range -> end = screen_row;

		in_visible_block = 1;
	}
}

for (byte i = 0; i < range_ind + 1; i++) {
	const RangeX visible_range = visible[i];

	print_range(visible_range)

	screen_pos.x = visible_range.start;
	src_crop.x = ((double) (visible_range.start - (int) start_x) / size) * sprite.size.x;
	src_crop.w = visible_range.end - visible_range.start;

	SDL_RenderCopyF(screen.renderer, thing.sprite.texture, &src_crop, &screen_pos);
}
putchar('\n');

/*
for (byte i = 0; i < range_ind + 1; i++) {
	printf("{%d, %d}, ", ranges[i].start, ranges[i].end);
}
putchar('\n');
*/

/////

/*
double h = p_height;

static double a;
const byte up = keys[SDL_SCANCODE_T], down = keys[SDL_SCANCODE_Y], clamp = keys[SDL_SCANCODE_U];
if (up) a += 0.01;
if (down) a -= 0.01;
if (clamp) a = round(a);
if (up || down || clamp) DEBUG(a, lf);
h += a;

const double test = 1.0 / current_level.max_point_height;
DEBUG(test, lf);

DEBUG(1.0 / (settings.screen_height / settings.proj_dist), lf);

const double height_ratio = h * settings.screen_height / settings.proj_dist;

DEBUG(height_ratio, lf);

const double opp_h = 0.5 + height_ratio;
*/

///// This snippet adjusts the height to the point height that the player is at:

const double screen_height_proj_ratio = settings.screen_height / settings.proj_dist;
const double world_height = p_height - p_height / screen_height_proj_ratio;
const double opp_h = 0.5 + world_height * screen_height_proj_ratio;

/////

const double screen_height_proj_ratio = settings.screen_height / settings.proj_dist;
const double world_height = p_height - floor_height / screen_height_proj_ratio;
const double opp_h = 0.5 + world_height * screen_height_proj_ratio;

/*
const double screen_height_proj_ratio = settings.screen_height / settings.proj_dist;
const double world_height = p_height - p_height / screen_height_proj_ratio;
const double opp_h = 0.5 + world_height * screen_height_proj_ratio;
*/

/////

/*
for floor height 1: -0.66
floor height 2: -1.32
*/

/////

/*
a / b / c = a / b * 1/c = a * 1/b * 1/c = a / (b * c)

1 / ratio / 2 = 1 / (sc)
*/

/////

const int max_offset = width - 1;

double (*fn)();
if (keys[SDL_SCANCODE_T]) fn = round;
else if (keys[SDL_SCANCODE_Y]) fn = ceil;
else fn = floor;

/*
if side && dir[1] > 0.0, fn = floor
if !side && dir[0] < 0.0, fn = ?
if side && dir[1] > 0.0, fn = ceil
*/

if (side) {
	if (h == 1) printf("Yes, and (dir[1] > 0.0) == %d\n", dir[1] > 0.0);
	const int x_offset = fn((hit[0] - (int) hit[0]) * max_offset);
	return (dir[1] > 0.0) ? max_offset - x_offset : x_offset;
}
else {
	if (h == 1) printf("No, and (dir[0] < 0.0) == %d\n", dir[0] < 0.0);
	const int y_offset = fn((hit[1] - (int) hit[1]) * max_offset);
	return (dir[0] < 0.0) ? max_offset - y_offset : y_offset;
}

/////

typedef struct {
	Billboard billboard;
	byte is_animated, is_enemy_instance;
	int animation_index;
} GenericBillboard;

/////