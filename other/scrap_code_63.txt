///// The old sprite chunking code:

static void vis_drawing_fn(const double start_x, const double x, SDL_Rect* const thing_crop,
	SDL_FRect* const screen_pos, const double size, SDL_Texture* const texture) {

	screen_pos -> x = start_x;
	screen_pos -> w = x - start_x; // == dest_x_range

	// const byte is_idol = texture == current_level.billboards[4].sprite.texture;
	// if (is_idol) DEBUG((double) screen_pos -> w, lf);

	const double new_thing_crop_w = round(thing_crop -> w * (double) screen_pos -> w / size);
	thing_crop -> w = new_thing_crop_w;

	SDL_RenderCopyF(screen.renderer, texture, thing_crop, screen_pos);
}

inlinable void draw_thing_as_cols(SDL_Texture* const texture,
	SDL_Rect* const thing_crop, SDL_FRect* const screen_pos, const double screen_start_x,
	const double screen_end_x, const double corrected_dist, const double screen_size) {

	//////////

	byte in_vis_span = 1;
	double x_draw_start = screen_start_x;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || screen_x == (int) screen_end_x - 1 || (double) val_buffer[screen_x].depth < corrected_dist) { // occluded column
			printf("Don't draw at screen_x %d\n", screen_x);

			if (in_vis_span) {
				vis_drawing_fn(x_draw_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
		else if (!in_vis_span) {
			in_vis_span = 1;	
			x_draw_start = screen_x;
		}
	}

	/*
	byte in_vis_span = 0;
	double vis_span_start = screen_start_x;

	const byte is_idol = texture == current_level.billboards[4].sprite.texture;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || (double) val_buffer[screen_x].depth > corrected_dist) { // yes, span is visible
			if (!in_vis_span) {
				if (is_idol) printf("Begin vis span at x = %d\n", screen_x);
				vis_span_start = screen_x;
				in_vis_span = 1;
			}
		}

		else { // no, span is not visible, so draw the last one
			if (in_vis_span) { // draws from vis_span_start to start_x
				vis_drawing_fn(vis_span_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
	}

	if (in_vis_span) vis_drawing_fn(vis_span_start, screen_end_x, thing_crop, screen_pos, screen_size, texture);
	*/
}

/////

if (screen_pos.x < -0.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999f || (double) val_buffer[round].depth < corrected_dist) {

/////

if (doubles_eq(last_projected_wall_top - projected_wall_bottom, 0.0)) return;

if (*d -> last_point_height == 1 && keys[SDL_SCANCODE_T]) return;

/////

// if (slice.x - mipmap_crop.x == 0 && d -> first_wall_hit) goto bob;

// if (doubles_eq(d -> hit[0], round(d -> hit[0])) && doubles_eq(d -> hit[1], round(d -> hit[1]))) {
if (0) {
	bob:

/////

void draw_colored_floor(const double horizon_line) {
	const SDL_FRect floor = {0.0, horizon_line - 1.0, settings.screen_width, settings.screen_height - horizon_line + 1.0};
	SDL_SetRenderDrawColor(screen.renderer, 148, 107, 69, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRectF(screen.renderer, &floor);
}

/////

void fast_affine_floor_2(const byte floor_height, const vec pos, const double p_height, const int horizon_line, const int y_end) {
	const double eye_height = (p_height - floor_height) + 0.5;
	if (eye_height < 0.0) return;

	// horizon_line is y_start
	for (int row = 1; row <= y_end - horizon_line; row++) {
		const int pixbuf_y = horizon_line + row - 1;
		if (pixbuf_y < 0) continue;

		Uint32* const pixbuf_row = read_texture_row(screen.pixels, screen.pixel_pitch, pixbuf_y);

		const vec straight_dist = vec_fill(eye_height / row * settings.proj_dist);

		for (int screen_x = 0; screen_x < settings.screen_width; screen_x += 2) {
			const BufferVal buffer_vals[2] = {val_buffer[screen_x], val_buffer[screen_x + 1]};

			const vec actual_dists = straight_dist * (vec) {
				(double) buffer_vals[0].one_over_cos_beta,
				(double) buffer_vals[1].one_over_cos_beta
			};

			const __m256d hits = (__m256d) {buffer_vals[0].dir[0], buffer_vals[0].dir[1], buffer_vals[1].dir[0], buffer_vals[1].dir[1]}
				*  + (__m256d) {pos[0], pos[1], pos[0], pos[1]};

			// const vec hit = buffer_val.dir * vec_fill(actual_dist) + pos;

			/*
			const BufferVal buffer_val = val_buffer[screen_x];
			const double actual_dist = straight_dist * (double) buffer_val.one_over_cos_beta;
			const vec hit = vec_line_pos(pos, buffer_val.dir, actual_dist);

			if (hit[0] < 1.0 || hit[1] < 1.0 || hit[0] > current_level.map_size.x - 1.0
				|| hit[1] > current_level.map_size.y - 1.0) continue;

			#ifndef PLANAR_MODE
			const byte wall_point = *map_point(current_level.wall_data, hit[0], hit[1]);
			if (current_level.get_point_height(wall_point, hit) != floor_height) continue;
			#endif

			const vec offset = vec_tex_offset(hit, ground.size);
			Uint32 pixel = ground.pixels[(long) ((long) offset[1] * ground.size + offset[0])];

			#ifdef SHADING_ENABLED
			pixel = shade_ARGB_pixel(pixel, calculate_shade(settings.proj_dist / actual_dist, hit));
			#endif

			for (int x = 0; x < settings.ray_column_width; x++) pixbuf_row[x + screen_x] = pixel;
			*/
		}
	}

///// The old perlin noise code:

double rand_double(void) {
	const double val = rand() / (double) RAND_MAX;
	return (rand() % 2) ? val : -val;
}

double dot_product(const vec a, const vec b) {
	return a[0] * a[0] + b[1] * b[1];
}

SDL_Surface* generate_perlin_noise(const ivec image_size) {
	const int grid_size = 20;

	vec gradient_vecs[grid_size][grid_size];

	for (int y = 0; y < grid_size; y++) {
		for (int x = 0; x < grid_size; x++)
			gradient_vecs[y][x] = (vec) {rand_double(), rand_double()};
	}

	double dot_products[grid_size][grid_size][4];

	for (int y = 0; y < grid_size; y++) {
		for (int x = 0; x < grid_size; x++) {
			const vec gradient_vec = gradient_vecs[y][x];

			static const vec offset_vecs[4] = {{-1, 1}, {-1, 1}, {1, -1}, {1, 1}};
			for (byte i = 0; i < 4; i++) dot_products[y][x][i] = dot_product(gradient_vec, offset_vecs[i]);
		}
	}

	SDL_Surface* const image = SDL_CreateRGBSurfaceWithFormat(0, image_size.x, image_size.y, 32, PIXEL_FORMAT);

	const double gradients_per_pixel[2] = {(double) image_size.x / grid_size, (double) image_size.y / grid_size};
	double gradient_pos[2] = {0.0, 0.0};

	for (int y = 0; y < image_size.y; y++, gradient_pos[1] += gradients_per_pixel[1]) {
		for (int x = 0; x < image_size.x; x++, gradient_pos[0] += gradients_per_pixel[0]) {

		}
	}

	return image;	
}

///// Version 2:

double dot(const vec a, const vec b) {
	return a[0] * a[0] + b[1] * b[1];
}

function Shuffle(tab){
	for(let e = tab.length-1; e > 0; e--){
		let index = Math.round(Math.random()*(e-1)),
			temp  = tab[e];
		
		tab[e] = tab[index];
		tab[index] = temp;
	}
}

function MakePermutation(){

	/*
	let P = [];
	for(let i = 0; i < 256; i++){
		P.push(i);
	}
	Shuffle(P);
	for(let i = 0; i < 256; i++){
		P.push(P[i]);
	}
	
	return P;
	*/
}
let P = MakePermutation();

vec GetConstantVector(int v){
	int h = v & 3;

	switch (h) {
		case 0: return (vec) {1.0, 1.0};
		case 1: return (vec) {-1.0, 1.0};
		case 2: return (vec) {-1.0, -1.0};
		default: return (vec) {1.0, -1.0};
	}
}

double Fade(double t){
	return ((6*t - 15)*t + 10)*t*t*t;
}

double Lerp(double t, double a1, double a2){
	return a1 + t*(a2-a1);
}

double Noise2D(int x, int y){
	int X = Math.floor(x) & 255;
	int Y = Math.floor(y) & 255;

	double xf = x-Math.floor(x);
	double yf = y-Math.floor(y);

	vec topRight = (vec) {xf-1.0, yf-1.0};
	vec topLeft = (vec) {xf, yf-1.0};
	vec bottomRight = (vec) {xf-1.0, yf};
	vec bottomLeft = (vec) {xf, yf};
	
	//Select a value in the array for each of the 4 corners
	double valueTopRight = P[P[X+1]+Y+1];
	double valueTopLeft = P[P[X]+Y+1];
	double valueBottomRight = P[P[X+1]+Y];
	double valueBottomLeft = P[P[X]+Y];
	
	double dotTopRight = dot(GetConstantVector(valueTopRight));
	double dotTopLeft = dot(GetConstantVector(valueTopLeft));
	double dotBottomRight = dot(GetConstantVector(valueBottomRight));
	double dotBottomLeft = dot(GetConstantVector(valueBottomLeft));
	
	double u = Fade(xf);
	double v = Fade(yf);
	
	return Lerp(u,
		Lerp(v, dotBottomLeft, dotTopLeft),
		Lerp(v, dotBottomRight, dotTopRight)
	);

}

///// Some old, working perlin code:

void perlin(SDL_Surface* const image) {
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;

	Uint32* read_surface_pixel(const SDL_Surface* const, const int, const int, const int);

	for (int y = 0; y < image -> h; y++) {
		for (int x = 0; x < image -> w; x++) {
			const byte color = perlin2d(x, y, 0.01, 10) * 255; // 0.1, 4 (0.05, 10 is also good for 128x128)
			*read_surface_pixel(image, x, y, bpp) = SDL_MapRGBA(format, color, color, color, 255);
		}
	}
}

void perlin_test(void) {
	const int size = 64;

	SDL_Surface* const image = SDL_CreateRGBSurfaceWithFormat(0, size, size, 32, PIXEL_FORMAT);
	SDL_LockSurface(image);

	perlin(image);
	SDL_SaveBMP(image, "out.bmp");

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);

	// exit(0);
}

/////