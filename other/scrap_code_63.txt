///// The old sprite chunking code:

static void vis_drawing_fn(const double start_x, const double x, SDL_Rect* const thing_crop,
	SDL_FRect* const screen_pos, const double size, SDL_Texture* const texture) {

	screen_pos -> x = start_x;
	screen_pos -> w = x - start_x; // == dest_x_range

	// const byte is_idol = texture == current_level.billboards[4].sprite.texture;
	// if (is_idol) DEBUG((double) screen_pos -> w, lf);

	const double new_thing_crop_w = round(thing_crop -> w * (double) screen_pos -> w / size);
	thing_crop -> w = new_thing_crop_w;

	SDL_RenderCopyF(screen.renderer, texture, thing_crop, screen_pos);
}

inlinable void draw_thing_as_cols(SDL_Texture* const texture,
	SDL_Rect* const thing_crop, SDL_FRect* const screen_pos, const double screen_start_x,
	const double screen_end_x, const double corrected_dist, const double screen_size) {

	//////////

	byte in_vis_span = 1;
	double x_draw_start = screen_start_x;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || screen_x == (int) screen_end_x - 1 || (double) val_buffer[screen_x].depth < corrected_dist) { // occluded column
			printf("Don't draw at screen_x %d\n", screen_x);

			if (in_vis_span) {
				vis_drawing_fn(x_draw_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
		else if (!in_vis_span) {
			in_vis_span = 1;	
			x_draw_start = screen_x;
		}
	}

	/*
	byte in_vis_span = 0;
	double vis_span_start = screen_start_x;

	const byte is_idol = texture == current_level.billboards[4].sprite.texture;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || (double) val_buffer[screen_x].depth > corrected_dist) { // yes, span is visible
			if (!in_vis_span) {
				if (is_idol) printf("Begin vis span at x = %d\n", screen_x);
				vis_span_start = screen_x;
				in_vis_span = 1;
			}
		}

		else { // no, span is not visible, so draw the last one
			if (in_vis_span) { // draws from vis_span_start to start_x
				vis_drawing_fn(vis_span_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
	}

	if (in_vis_span) vis_drawing_fn(vis_span_start, screen_end_x, thing_crop, screen_pos, screen_size, texture);
	*/
}

/////

if (screen_pos.x < -0.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999f || (double) val_buffer[round].depth < corrected_dist) {

/////

if (doubles_eq(last_projected_wall_top - projected_wall_bottom, 0.0)) return;

if (*d -> last_point_height == 1 && keys[SDL_SCANCODE_T]) return;

/////

// if (slice.x - mipmap_crop.x == 0 && d -> first_wall_hit) goto bob;

// if (doubles_eq(d -> hit[0], round(d -> hit[0])) && doubles_eq(d -> hit[1], round(d -> hit[1]))) {
if (0) {
	bob:

/////

void draw_colored_floor(const double horizon_line) {
	const SDL_FRect floor = {0.0, horizon_line - 1.0, settings.screen_width, settings.screen_height - horizon_line + 1.0};
	SDL_SetRenderDrawColor(screen.renderer, 148, 107, 69, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRectF(screen.renderer, &floor);
}

/////

void fast_affine_floor_2(const byte floor_height, const vec pos, const double p_height, const int horizon_line, const int y_end) {
	const double eye_height = (p_height - floor_height) + 0.5;
	if (eye_height < 0.0) return;

	// horizon_line is y_start
	for (int row = 1; row <= y_end - horizon_line; row++) {
		const int pixbuf_y = horizon_line + row - 1;
		if (pixbuf_y < 0) continue;

		Uint32* const pixbuf_row = read_texture_row(screen.pixels, screen.pixel_pitch, pixbuf_y);

		const vec straight_dist = vec_fill(eye_height / row * settings.proj_dist);

		for (int screen_x = 0; screen_x < settings.screen_width; screen_x += 2) {
			const BufferVal buffer_vals[2] = {val_buffer[screen_x], val_buffer[screen_x + 1]};

			const vec actual_dists = straight_dist * (vec) {
				(double) buffer_vals[0].one_over_cos_beta,
				(double) buffer_vals[1].one_over_cos_beta
			};

			const __m256d hits = (__m256d) {buffer_vals[0].dir[0], buffer_vals[0].dir[1], buffer_vals[1].dir[0], buffer_vals[1].dir[1]}
				*  + (__m256d) {pos[0], pos[1], pos[0], pos[1]};

			// const vec hit = buffer_val.dir * vec_fill(actual_dist) + pos;

			/*
			const BufferVal buffer_val = val_buffer[screen_x];
			const double actual_dist = straight_dist * (double) buffer_val.one_over_cos_beta;
			const vec hit = vec_line_pos(pos, buffer_val.dir, actual_dist);

			if (hit[0] < 1.0 || hit[1] < 1.0 || hit[0] > current_level.map_size.x - 1.0
				|| hit[1] > current_level.map_size.y - 1.0) continue;

			#ifndef PLANAR_MODE
			const byte wall_point = *map_point(current_level.wall_data, hit[0], hit[1]);
			if (current_level.get_point_height(wall_point, hit) != floor_height) continue;
			#endif

			const vec offset = vec_tex_offset(hit, ground.size);
			Uint32 pixel = ground.pixels[(long) ((long) offset[1] * ground.size + offset[0])];

			#ifdef SHADING_ENABLED
			pixel = shade_ARGB_pixel(pixel, calculate_shade(settings.proj_dist / actual_dist, hit));
			#endif

			for (int x = 0; x < settings.ray_column_width; x++) pixbuf_row[x + screen_x] = pixel;
			*/
		}
	}

///// The old perlin noise code:

double rand_double(void) {
	const double val = rand() / (double) RAND_MAX;
	return (rand() % 2) ? val : -val;
}

double dot_product(const vec a, const vec b) {
	return a[0] * a[0] + b[1] * b[1];
}

SDL_Surface* generate_perlin_noise(const ivec image_size) {
	const int grid_size = 20;

	vec gradient_vecs[grid_size][grid_size];

	for (int y = 0; y < grid_size; y++) {
		for (int x = 0; x < grid_size; x++)
			gradient_vecs[y][x] = (vec) {rand_double(), rand_double()};
	}

	double dot_products[grid_size][grid_size][4];

	for (int y = 0; y < grid_size; y++) {
		for (int x = 0; x < grid_size; x++) {
			const vec gradient_vec = gradient_vecs[y][x];

			static const vec offset_vecs[4] = {{-1, 1}, {-1, 1}, {1, -1}, {1, 1}};
			for (byte i = 0; i < 4; i++) dot_products[y][x][i] = dot_product(gradient_vec, offset_vecs[i]);
		}
	}

	SDL_Surface* const image = SDL_CreateRGBSurfaceWithFormat(0, image_size.x, image_size.y, 32, PIXEL_FORMAT);

	const double gradients_per_pixel[2] = {(double) image_size.x / grid_size, (double) image_size.y / grid_size};
	double gradient_pos[2] = {0.0, 0.0};

	for (int y = 0; y < image_size.y; y++, gradient_pos[1] += gradients_per_pixel[1]) {
		for (int x = 0; x < image_size.x; x++, gradient_pos[0] += gradients_per_pixel[0]) {

		}
	}

	return image;	
}

///// Version 2:

double dot(const vec a, const vec b) {
	return a[0] * a[0] + b[1] * b[1];
}

function Shuffle(tab){
	for(let e = tab.length-1; e > 0; e--){
		let index = Math.round(Math.random()*(e-1)),
			temp  = tab[e];
		
		tab[e] = tab[index];
		tab[index] = temp;
	}
}

function MakePermutation(){

	/*
	let P = [];
	for(let i = 0; i < 256; i++){
		P.push(i);
	}
	Shuffle(P);
	for(let i = 0; i < 256; i++){
		P.push(P[i]);
	}
	
	return P;
	*/
}
let P = MakePermutation();

vec GetConstantVector(int v){
	int h = v & 3;

	switch (h) {
		case 0: return (vec) {1.0, 1.0};
		case 1: return (vec) {-1.0, 1.0};
		case 2: return (vec) {-1.0, -1.0};
		default: return (vec) {1.0, -1.0};
	}
}

double Fade(double t){
	return ((6*t - 15)*t + 10)*t*t*t;
}

double Lerp(double t, double a1, double a2){
	return a1 + t*(a2-a1);
}

double Noise2D(int x, int y){
	int X = Math.floor(x) & 255;
	int Y = Math.floor(y) & 255;

	double xf = x-Math.floor(x);
	double yf = y-Math.floor(y);

	vec topRight = (vec) {xf-1.0, yf-1.0};
	vec topLeft = (vec) {xf, yf-1.0};
	vec bottomRight = (vec) {xf-1.0, yf};
	vec bottomLeft = (vec) {xf, yf};
	
	//Select a value in the array for each of the 4 corners
	double valueTopRight = P[P[X+1]+Y+1];
	double valueTopLeft = P[P[X]+Y+1];
	double valueBottomRight = P[P[X+1]+Y];
	double valueBottomLeft = P[P[X]+Y];
	
	double dotTopRight = dot(GetConstantVector(valueTopRight));
	double dotTopLeft = dot(GetConstantVector(valueTopLeft));
	double dotBottomRight = dot(GetConstantVector(valueBottomRight));
	double dotBottomLeft = dot(GetConstantVector(valueBottomLeft));
	
	double u = Fade(xf);
	double v = Fade(yf);
	
	return Lerp(u,
		Lerp(v, dotBottomLeft, dotTopLeft),
		Lerp(v, dotBottomRight, dotTopRight)
	);

}

///// Some old, working perlin code:

void perlin(SDL_Surface* const image) {
	const SDL_PixelFormat* const format = image -> format;
	const int bpp = format -> BytesPerPixel;

	Uint32* read_surface_pixel(const SDL_Surface* const, const int, const int, const int);

	for (int y = 0; y < image -> h; y++) {
		for (int x = 0; x < image -> w; x++) {
			const byte color = perlin2d(x, y, 0.01, 10) * 255; // 0.1, 4 (0.05, 10 is also good for 128x128)
			*read_surface_pixel(image, x, y, bpp) = SDL_MapRGBA(format, color, color, color, 255);
		}
	}
}

void perlin_test(void) {
	const int size = 64;

	SDL_Surface* const image = SDL_CreateRGBSurfaceWithFormat(0, size, size, 32, PIXEL_FORMAT);
	SDL_LockSurface(image);

	perlin(image);
	SDL_SaveBMP(image, "out.bmp");

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);

	// exit(0);
}

/////

#include <math.h>

/* Function to linearly interpolate between a0 and a1
 * Weight w should be in the range [0.0, 1.0]
 */
float interpolate(float a0, float a1, float w) {
    /* // You may want clamping by inserting:
     * if (0.0 > w) return a0;
     * if (1.0 < w) return a1;
     */
    return (a1 - a0) * w + a0;
    /* // Use this cubic interpolation [[Smoothstep]] instead, for a smooth appearance:
     * return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;
     *
     * // Use [[Smootherstep]] for an even smoother result with a second derivative equal to zero on boundaries:
     * return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;
     */
}

typedef struct {
    float x, y;
} vector2;

/* Create pseudorandom direction vector
 */
vector2 randomGradient(int ix, int iy) {
    // No precomputed gradients mean this works for any number of grid coordinates
    const unsigned w = 8 * sizeof(unsigned);
    const unsigned s = w / 2; // rotation width
    unsigned a = ix, b = iy;
    a *= 3284157443; b ^= (a << s) | a >> (w-s);
    b *= 1911520717; a ^= (b << s) | b >> (w-s);
    a *= 2048419325;
    float random = a * (3.14159265 / ~(~0u >> 1)); // in [0, 2*Pi]
    vector2 v;
    v.x = sin(random); v.y = cos(random);
    return v;
}

// Computes the dot product of the distance and gradient vectors.
float dotGridGradient(int ix, int iy, float x, float y) {
    // Get gradient from integer coordinates
    vector2 gradient = randomGradient(ix, iy);

    // Compute the distance vector
    float dx = x - (float)ix;
    float dy = y - (float)iy;

    // Compute the dot-product
    return (dx*gradient.x + dy*gradient.y);
}

// Compute Perlin noise at coordinates x, y
float perlin(float x, float y) {
    // Determine grid cell coordinates
    int x0 = (int)x;
    int x1 = x0 + 1;
    int y0 = (int)y;
    int y1 = y0 + 1;

    // Determine interpolation weights
    // Could also use higher order polynomial/s-curve here
    float sx = x - (float)x0;
    float sy = y - (float)y0;

    // Interpolate between grid point gradients
    float n0, n1, ix0, ix1, value;

    n0 = dotGridGradient(x0, y0, x, y);
    n1 = dotGridGradient(x1, y0, x, y);
    ix0 = interpolate(n0, n1, sx);

    n0 = dotGridGradient(x0, y1, x, y);
    n1 = dotGridGradient(x1, y1, x, y);
    ix1 = interpolate(n0, n1, sx);

    value = interpolate(ix0, ix1, sy);
    DEBUG(value, lf);
    return value;
}

/////

double smooth_lerp(const double x0, const double x1, const double width) { // also known as smoothstep
	// return (x2 - x1) * (3.0 - width * 2.0) * width * width + x1;

	// double a0 = x1, a1 = x2, w = width;
	// return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;
	return (x1 - x0) * ((width * (width * 6.0 - 15.0) + 10.0) * width * width * width) + x0;
}

/////

inlinable double render_wall_column(const DRect* const wall_dest, const SDL_Rect* const slice,
	const byte last_point_height, const byte point_height, const double last_wall_top, const int max_sprite_h) {

}

///// Doesn't work:

// once the colors are correct per vertical line, this will be done
void mark_floor(const DataRaycast* const d, const double last_projected_wall_top, const double projected_wall_bottom) {
	(void) last_projected_wall_top;
	(void) projected_wall_bottom;

	const vec hit = d -> hit;
	if (doubles_eq(hit[0], round(hit[0])) && doubles_eq(hit[1], round(hit[1]))) {
		puts("Lala\n");
		SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
		const SDL_Rect r = {d -> screen_x, last_projected_wall_top, 20, 20};
		SDL_RenderFillRect(screen.renderer, &r);
	}

	/*
	if (doubles_eq(last_projected_wall_top - projected_wall_bottom, 0.0)) return;
	const int x = d -> screen_x;
	SDL_SetRenderDrawColor(screen.renderer, 0, 255 / (*d -> last_point_height + 1), 0, SDL_ALPHA_OPAQUE);
	SDL_RenderDrawLine(screen.renderer, x, last_projected_wall_top, x, projected_wall_bottom); // last wall top -> curr wall bottom
	*/
}

/////

/*
if (slice.x - mipmap_crop.x == 0 && d -> first_wall_hit) {
	const SDL_Rect corner = {d -> screen_x, proj_wall_top, 20, 20};
	SDL_SetRenderDrawColor(screen.renderer, 255, 0, 0, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRect(screen.renderer, &corner);
}
*/

/////

static int x;
if (keys[SDL_SCANCODE_T]) x++;
if (keys[SDL_SCANCODE_Y]) x--;
if (keys[SDL_SCANCODE_U]) x = 0;

SDL_Rect r = {x, x, settings.screen_width - (x << 1), settings.screen_height - (x << 1)};

SDL_RenderCopy(screen.renderer, screen.pixel_buffer, &r, NULL); // copy everything?
SDL_RenderCopy(screen.renderer, screen.shape_buffer, &r, NULL);

/////

static double a = 0.0;
const double step = 0.0001;
if (keys[SDL_SCANCODE_T]) a += step;
if (keys[SDL_SCANCODE_Y]) a -= step;
if (keys[SDL_SCANCODE_U]) a = 0.0;

ray.dist += a;

/////

if (ray.curr_tile[0] == 2.0 && ray.curr_tile[1] == 6.0) {
	ray.dist++;
}

/////

/*
if (height_delta > 0.0) {
	printf("Landed on thing, with a height delta of %lf\n", height_delta);
	landed_on_thing = 1;
	ground_height = thing_height + 1.0;
	// jump -> jumping = 0;
	break;
}
else if (height_delta > -0.05) {
	hit_head = 1;
	break;
}
*/

/////


/*
// This could really use templates

#define BIGGEST_IND_OF_2(a) a[0] >= a[1]

#define UNPACK_2(v) {v[0], v[1]}
#define APPLY_2(v, f) {f(v[0]), f(v[1])}
#define OUT_OF_BOUNDS_2(v) ivec_out_of_bounds((ivec) v)

//////////

inlinable byte biggest_ind_of_3(const double a[3]) {
	if (a[0] >= a[1] && a[0] >= a[2]) return 1;
	else if (a[1] >= a[0] && a[1] >= a[2]) return 2;
	else return 3;
}

#define UNPACK_3(v) {v[0], v[1], v[2]}
#define APPLY_3(v, f) {f(v[0]), f(v[1]), f(v[2])}

inlinable byte double3_out_of_bounds(const double a[3]) {
	// x across, y up, and z backward
	return ivec_out_of_bounds((ivec) {a[0], a[2]}) || (a[1] < 0.0) || (a[1] > current_level.max_point_height);
}

#define OUT_OF_BOUNDS_3(a) double3_out_of_bounds((double[3]) a)

//////////

#define DDA_DEF(dimensions, typename, init_fn, peek_fn, iter_fn, applier, unpacker, component_cmp, out_of_bounds_checker)\
\
typedef struct {\
	byte step_count, side;\
	double dist;\
	const double origin[dimensions], dir[dimensions], unit_step_size[dimensions], ray_step[dimensions];\
	double ray_length[dimensions], curr_tile[dimensions];\
} typename;\
\
typename init_fn(const double origin[dimensions], const double dir[dimensions], const double step) {\
	const double curr_tile[dimensions] = applier(origin, floor);\
	double unit_step_size[dimensions], ray_length[dimensions], ray_step[dimensions];\
\
	for (byte i = 0; i < dimensions; i++) {\
		unit_step_size[i] = fabs(step / dir[i]);\
\
		if (dir[i] < 0.0) {\
			ray_step[i] = -step;\
			ray_length[i] = (origin[i] - curr_tile[i]) * unit_step_size[i];\
		}\
		else {\
			ray_step[i] = step;\
			ray_length[i] = (curr_tile[i] + 1.0 - origin[i]) * unit_step_size[i];\
		}\
	}\
	return (typename) {\
		0, 0, 0.0, unpacker(origin), unpacker(dir), unpacker(unit_step_size),\
		unpacker(ray_step), unpacker(ray_length), unpacker(curr_tile)\
	};\
}\
\
inlinable typename peek_fn(typename d) {\
	d.side = component_cmp(d.ray_length);\
\
	d.dist = d.ray_length[d.side];\
	d.curr_tile[d.side] += d.ray_step[d.side];\
	d.ray_length[d.side] += d.unit_step_size[d.side];\
\
	return d;\
}\
\
inlinable byte iter_fn(typename* const d_ref) {\
	typename d = peek_fn(*d_ref);\
	if (out_of_bounds_checker(unpacker(d.curr_tile))) return 0;\
\
	d.step_count++;\
	memcpy(d_ref, &d, sizeof(DataDDA));\
	return 1;\
}

DDA_DEF(2, DataDDA,   init_dda,    peek_dda,    iter_dda,    APPLY_2, UNPACK_2, BIGGEST_IND_OF_2, OUT_OF_BOUNDS_2)
// DDA_DEF(3, DataDDA3D, init_dda_3D, peek_dda_3D, iter_dda_3D, APPLY_3, UNPACK_3, biggest_ind_of_3, OUT_OF_BOUNDS_3)
*/

/////

/*
if (settings.half_screen_height >= screen_pos.y && screen_pos.y + screen_pos.h >= settings.half_screen_height
	&& thing.possible_enemy_instance != NULL) {
	thing.possible_enemy_instance -> flags |= mask_weapon_y_pitch_in_range_of_enemy;
	SDL_SetTextureColorMod(texture, 220, 20, 60);
}
else SDL_SetTextureColorMod(texture, 255, 255, 255);
*/
//////////

// SDL_SetTextureColorMod(current_level.skybox.sprite.texture, 255, 0, 0);

/////

SDL_Texture* const texture = enemy_instance -> enemy -> animation_data.sprite.texture;
if (weapon_y_matches_enemy_y) SDL_SetTextureColorMod(texture, 255, 0, 0);
else SDL_SetTextureColorMod(texture, 255, 255, 255);

///// An attempt at making the crosshair red when the enemy is on it (didn't work b/c also have to see if shot will actually hit)

byte red_crosshair_for_enemy = 0;
for (byte i = 0; i < current_level.enemy_instance_count; i++) {
	if (bit_is_set(current_level.enemy_instances[i].status, mask_recently_attacked_enemy)) {
		red_crosshair_for_enemy = 1;
		break;
	}
}

const Color3 color = red_crosshair_for_enemy ? (Color3) {255, 0, 0} : hud_colors[HUD];

/////

/*
double step, max_hit_dist;
const byte short_range_weapon = bit_is_set(weapon -> status, mask_short_range_weapon);

if (short_range_weapon) {
	step = short_range_weapon_dda_step;
	max_hit_dist = short_range_weapon_max_hit_dist;
}
else {
	step = long_range_weapon_dda_step;
	max_hit_dist = long_range_weapon_max_hit_dist;
}
*/

/////

/*
{
	const vec delta = enemy_pos - bullet_pos;
	const double dist_squared = delta[0] * delta[0] + delta[1] * delta[1];
	DEBUG(sqrt(dist_squared), lf);
}
*/

///// diffs:

static byte first = 1;
vec last_hit = {0.0, 0.0}, last_diff = {0.0, 0.0};

for (int screen_x = 0; screen_x < settings.screen_width; screen_x += settings.ray_column_width) {
	/* The remaining bottlenecks:
	Checking for statemap bits will not be needed with a visplane system -> speedup
	Also, that means that the statemap won't be needed anymore -> speedup
	Checking for out-of-bound hits won't be needed either -> speedup
	Checking for wall points that do not equal the floor height won't be needed either -> speedup
	Also, with a visplane system, less y and x coordinates will be iterated over -> speedup */

	#ifndef PLANAR_MODE
	if (get_statemap_bit(occluded_by_walls, screen_x, pixbuf_y)) continue;
	#endif

	const FloorcastBufferVal floorcast_buffer_val = floorcast_val_buffer[screen_x];
	const double actual_dist = straight_dist * (double) floorcast_buffer_val.one_over_cos_beta;
	const vec hit = vec_line_pos(pos, floorcast_buffer_val.dir, actual_dist);

	if (first) {
		const vec diff = hit - last_hit;
		const vec diff_diff = diff - last_diff;

		DEBUG(screen_x, d);
		DEBUG_VEC(hit);
		DEBUG_VEC(diff);
		DEBUG_VEC(diff_diff);
		puts("---");

		last_hit = hit;
		last_diff = diff;
	}

	if (hit[0] < 1.0 || hit[1] < 1.0 || hit[0] > current_level.map_size.x - 1.0
		|| hit[1] > current_level.map_size.y - 1.0) continue;

	#ifndef PLANAR_MODE
	const byte wall_point = *map_point(current_level.wall_data, hit[0], hit[1]);
	if (current_level.get_point_height(wall_point, hit) != floor_height) continue;
	#endif

	const vec offset = vec_tex_offset(hit, ground.size);
	Uint32 pixel = ground.pixels[(long) ((long) offset[1] * ground.size + offset[0])];

	#ifdef SHADING_ENABLED
	pixel = shade_ARGB_pixel(pixel, calculate_shade(settings.proj_dist / actual_dist, hit));
	#endif

	for (int x = 0; x < settings.ray_column_width; x++) pixbuf_row[x + screen_x] = pixel;
}
if (first) first = 0;

/////

int v = val * wall_h / settings.screen_height;
if (v > 255) v = 255;
return v;

/////

/*
printf("params.start_y = %d, params.end_y = %d\n", params.start_y, params.end_y);
printf("For drawer #%d, draw from %d to %d\n", i + 1, params.y_start, params.y_end);
*/

/////