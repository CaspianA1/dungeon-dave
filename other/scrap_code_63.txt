///// The old sprite chunking code:

static void vis_drawing_fn(const double start_x, const double x, SDL_Rect* const thing_crop,
	SDL_FRect* const screen_pos, const double size, SDL_Texture* const texture) {

	screen_pos -> x = start_x;
	screen_pos -> w = x - start_x; // == dest_x_range

	// const byte is_idol = texture == current_level.billboards[4].sprite.texture;
	// if (is_idol) DEBUG((double) screen_pos -> w, lf);

	const double new_thing_crop_w = round(thing_crop -> w * (double) screen_pos -> w / size);
	thing_crop -> w = new_thing_crop_w;

	SDL_RenderCopyF(screen.renderer, texture, thing_crop, screen_pos);
}

inlinable void draw_thing_as_cols(SDL_Texture* const texture,
	SDL_Rect* const thing_crop, SDL_FRect* const screen_pos, const double screen_start_x,
	const double screen_end_x, const double corrected_dist, const double screen_size) {

	//////////

	byte in_vis_span = 1;
	double x_draw_start = screen_start_x;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || screen_x == (int) screen_end_x - 1 || (double) val_buffer[screen_x].depth < corrected_dist) { // occluded column
			printf("Don't draw at screen_x %d\n", screen_x);

			if (in_vis_span) {
				vis_drawing_fn(x_draw_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
		else if (!in_vis_span) {
			in_vis_span = 1;	
			x_draw_start = screen_x;
		}
	}

	/*
	byte in_vis_span = 0;
	double vis_span_start = screen_start_x;

	const byte is_idol = texture == current_level.billboards[4].sprite.texture;

	for (int screen_x = screen_start_x; screen_x < screen_end_x; screen_x++) {
		if (screen_x < 0 || (double) val_buffer[screen_x].depth > corrected_dist) { // yes, span is visible
			if (!in_vis_span) {
				if (is_idol) printf("Begin vis span at x = %d\n", screen_x);
				vis_span_start = screen_x;
				in_vis_span = 1;
			}
		}

		else { // no, span is not visible, so draw the last one
			if (in_vis_span) { // draws from vis_span_start to start_x
				vis_drawing_fn(vis_span_start, screen_x, thing_crop, screen_pos, screen_size, texture);
				in_vis_span = 0;
			}
		}
	}

	if (in_vis_span) vis_drawing_fn(vis_span_start, screen_end_x, thing_crop, screen_pos, screen_size, texture);
	*/
}

/////

if (screen_pos.x < -0.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999f || (double) val_buffer[round].depth < corrected_dist) {

/////

if (doubles_eq(last_projected_wall_top - projected_wall_bottom, 0.0)) return;

if (*d -> last_point_height == 1 && keys[SDL_SCANCODE_T]) return;

/////

// if (slice.x - mipmap_crop.x == 0 && d -> first_wall_hit) goto bob;

// if (doubles_eq(d -> hit[0], round(d -> hit[0])) && doubles_eq(d -> hit[1], round(d -> hit[1]))) {
if (0) {
	bob:

/////

void draw_colored_floor(const double horizon_line) {
	const SDL_FRect floor = {0.0, horizon_line - 1.0, settings.screen_width, settings.screen_height - horizon_line + 1.0};
	SDL_SetRenderDrawColor(screen.renderer, 148, 107, 69, SDL_ALPHA_OPAQUE);
	SDL_RenderFillRectF(screen.renderer, &floor);
}

/////

void fast_affine_floor_2(const byte floor_height, const vec pos, const double p_height, const int horizon_line, const int y_end) {
	const double eye_height = (p_height - floor_height) + 0.5;
	if (eye_height < 0.0) return;

	// horizon_line is y_start
	for (int row = 1; row <= y_end - horizon_line; row++) {
		const int pixbuf_y = horizon_line + row - 1;
		if (pixbuf_y < 0) continue;

		Uint32* const pixbuf_row = read_texture_row(screen.pixels, screen.pixel_pitch, pixbuf_y);

		const vec straight_dist = vec_fill(eye_height / row * settings.proj_dist);

		for (int screen_x = 0; screen_x < settings.screen_width; screen_x += 2) {
			const BufferVal buffer_vals[2] = {val_buffer[screen_x], val_buffer[screen_x + 1]};

			const vec actual_dists = straight_dist * (vec) {
				(double) buffer_vals[0].one_over_cos_beta,
				(double) buffer_vals[1].one_over_cos_beta
			};

			const __m256d hits = (__m256d) {buffer_vals[0].dir[0], buffer_vals[0].dir[1], buffer_vals[1].dir[0], buffer_vals[1].dir[1]}
				*  + (__m256d) {pos[0], pos[1], pos[0], pos[1]};

			// const vec hit = buffer_val.dir * vec_fill(actual_dist) + pos;

			/*
			const BufferVal buffer_val = val_buffer[screen_x];
			const double actual_dist = straight_dist * (double) buffer_val.one_over_cos_beta;
			const vec hit = vec_line_pos(pos, buffer_val.dir, actual_dist);

			if (hit[0] < 1.0 || hit[1] < 1.0 || hit[0] > current_level.map_size.x - 1.0
				|| hit[1] > current_level.map_size.y - 1.0) continue;

			#ifndef PLANAR_MODE
			const byte wall_point = *map_point(current_level.wall_data, hit[0], hit[1]);
			if (current_level.get_point_height(wall_point, hit) != floor_height) continue;
			#endif

			const vec offset = vec_tex_offset(hit, ground.size);
			Uint32 pixel = ground.pixels[(long) ((long) offset[1] * ground.size + offset[0])];

			#ifdef SHADING_ENABLED
			pixel = shade_ARGB_pixel(pixel, calculate_shade(settings.proj_dist / actual_dist, hit));
			#endif

			for (int x = 0; x < settings.ray_column_width; x++) pixbuf_row[x + screen_x] = pixel;
			*/
		}
	}

/////