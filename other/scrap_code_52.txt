/*
idea:
1. turn the 32-bit int into 4 8-bit ints,
2. simd multiply the first three by the shade
3. make that vector one number

xmm registers store 4 32-bit floating-point numbers
need a way to take each byte out of a 32-bit number and put each part in a section of an xmm register
*/

void print_bits(Uint32 val) {
	for (int i = 31; 0 <= i; i--)
		printf("%c", (val & (1 << i)) ? '1' : '0');
	putchar('\n');
}

// https://stackoverflow.com/questions/58895781/extracting-bytes-from-a-32-bits-number
Uint32 shader_2(const Uint32 pixel, const double dist, const vec hit) {
	(void) dist;
	(void) hit;
	return pixel;

	/*
	print_bits(pixel);
	const double shade = 0.8;
	DEBUG(shade, lf);
	const byte r = (byte) (pixel >> 16) * shade, g = (byte) (pixel >> 8) * shade, b = (byte) pixel * shade;
	const Uint32 result = 0xFF000000 | (r << 16) | (g << 8) | b;
	print_bits(result);
	printf("---\n");
	return result;
	*/

	/*
	11111111 11011001 10100000 01100110
	shade = 0.800000
	11111111 10101101 10000000 01010001

	the shaded part = 101011011000000001010001

	01100110 * 0.8 = 1010001 (didn't equal 01010001?)
	*/


	/*
	printf("Pixel: ");
	print_bits(pixel);

	const Uint32 rgb = (pixel >> 8);
	printf("RGB: ");	
	print_bits(rgb);

	const Uint32 shaded = rgb * 0.8;	

	printf("Result: ");
	const Uint32 result = 0xFF000000 | shaded;
	print_bits(result);
	printf("---\n");

	return result;
	*/
}

/////

if (keys[SDL_SCANCODE_F]) rgb = ~rgb;

/////

// 0xFF000000 = 0b11111111000000000000000000000000

/////

// SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
// SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
// SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, "1" );

/////

const Uint32 flags = SDL_RENDERER_ACCELERATED | SDL_WINDOW_RESIZABLE; // | SDL_WINDOW_OPENGL | SDL_VIDEO_RENDER_OGL;
SDL_CreateWindowAndRenderer(settings.screen_width, settings.screen_height,
	flags, &screen.window, &screen.renderer);
SDL_SetWindowTitle(screen.window, "Dungeon Dave");

SDL_GLContext context = SDL_GL_CreateContext(screen.window);
DEBUG(SDL_GetError(), s);

SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 32);
SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 2);
SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);

// glEnable(GL_MULTISAMPLE);

/////