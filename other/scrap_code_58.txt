inlinable void new_handle_thing_collisions(vec* const ref_pos,
	const vec prev_pos, const vec movement, const double p_height) {

	(void) ref_pos;
	(void) prev_pos;
	(void) p_height;

	static byte first_call = 1;
	if (first_call) {
		first_call = 0;
		return;
	}

	vec new_pos = *ref_pos;

	vec new_x_pos = prev_pos, new_y_pos = prev_pos;
	new_x_pos[0] += movement[0];
	new_y_pos[1] += movement[1];

	for (byte i = 0; i < current_level.thing_count; i++) {
		const DataBillboard* const billboard_data = current_level.thing_container[i].billboard_data;
		const Circle thing_circle = {billboard_data -> pos, 0.5};

		byte x_hit = 0, y_hit = 0;
		if (intersects_with_circle(new_x_pos, thing_circle)) new_pos[0] = prev_pos[0], x_hit = 1;
		if (intersects_with_circle(new_y_pos, thing_circle) && !x_hit) new_pos[1] = prev_pos[1], y_hit = 1;

		printf("x_hit = %d, y_hit = %d\n", x_hit, y_hit);

		if (x_hit || y_hit) break;
	}

	*ref_pos = new_pos;
}

/////

inlinable byte intersects_with_circle(const vec pos, const Circle circle) {
	const vec center_diff = pos - circle.center;
	const double
		radius_squared = circle.radius * circle.radius,
		d_squared = center_diff[0] * center_diff[0] + center_diff[1] * center_diff[1];
	return d_squared <= radius_squared;
}

/////

new_handle_thing_collisions(&pos, prev_pos, movement, p_height);

/////

// #define dest (*ref_pos)[axis]

// dest = pos_to + 0.2;

/*
// (*ref_pos)[axis] = prev_pos[axis];
const double diff = (*ref_pos)[axis] - prev_pos[axis];
const char sign = ((pos[axis] - prev_pos[axis]) > 0.0) ? 1.0 : -1.0;
DEBUG(sign, d);

(*ref_pos)[axis] = (int) prev_pos[axis] + 0.2 * -sign;
*/

/////

const double pos_to = round(pos[axis]);
(*ref_pos)[axis] = pos_to;

/////

	// *ref_pos += movement;

	// hit_detection(pos, prev_pos, movement, p_height);

	// *pos += movement;
	/*
	if (!map_point(current_level.wall_data, (*pos)[0] + movement[0], (*pos)[1]))
		(*pos)[0] += movement[0];

	if (!map_point(current_level.wall_data, (*pos)[0], (*pos)[1] + movement[1]))
		(*pos)[1] += movement[1];
	*/

/////

#ifndef NOCLIP_MODE

const double thing_hit_dist = 0.5, thing_jump_above_dist = 0.5;

inlinable void handle_thing_collisions(vec* const ref_pos, const vec prev_pos, const double p_height) {
	static byte first_call = 1;
	if (first_call) { // first call skipped b/c thing data has not been initialized yet
		first_call = 0;
		return;
	}

	vec pos = *ref_pos, positions_to_check[4] = {pos, pos, pos, pos};
	for (byte i = 0; i < 4; i++) {
		const byte axis = i > 1;

		if (i & 1) positions_to_check[i][axis] += settings.stop_dist;
		else positions_to_check[i][axis] -= settings.stop_dist;
	}

	for (byte i = 0; i < current_level.thing_count; i++) {
		const DataBillboard* const billboard_data = current_level.thing_container[i].billboard_data;

		// if the player is over the thing, or the thing is over the player
		if (fabs(p_height - billboard_data -> height) >= thing_jump_above_dist) continue;

		for (byte j = 0; j < 4; j++) {
			if (!vec_delta_exceeds(billboard_data -> pos, positions_to_check[j], thing_hit_dist)) {
				const byte axis = j > 1;
				pos[axis] = prev_pos[axis];
			}
		}
	}

	*ref_pos = pos;
}

/*
typedef struct {const vec corners[4];} Rect;
static byte rects_are_colliding(const Rect r1, const Rect r2) {
	(void) r1;
	(void) r2;
	return 1;
}
*/

static void handle_axis_collision(const byte axis, vec* const ref_pos, const vec prev_pos, const vec movement, const double p_height) {
	const vec pos = *ref_pos;

	vec forward_pos = pos, backward_pos = pos;
	forward_pos[axis] += settings.stop_dist;
	backward_pos[axis] -= settings.stop_dist;

	if (!(point_exists_at(forward_pos[0], forward_pos[1], p_height) ||
		point_exists_at(backward_pos[0], backward_pos[1], p_height)))
		(*ref_pos)[axis] += movement[axis];

	/*
	if (point_exists_at(forward_pos[0], forward_pos[1], p_height) ||
		point_exists_at(backward_pos[0], backward_pos[1], p_height)) {
		// printf("Eject from %lf to %lf\n", (*ref_pos)[axis], prev_pos[axis]);
		(*ref_pos)[axis] = prev_pos[axis];
	}
	*/
}

#endif

static void hit_detection(vec* const ref_pos, const vec prev_pos, const vec movement, const double p_height) {
	// vec pos = *ref_pos + movement;
	vec pos = *ref_pos;

	#ifdef NOCLIP_MODE

	(void) prev_pos;
	(void) p_height;

	/* Out-of-bounds hit detection is only needed for noclip mode,
	as it will be impossible to go out of bounds otherwise in normal mode. */
	if (pos[1] < 1 || pos[1] > current_level.map_size.y - 1) pos[1] = prev_pos[1];
	if (pos[0] < 1 || pos[0] > current_level.map_size.x - 1) pos[0] = prev_pos[0];

	#else

	handle_axis_collision(0, &pos, prev_pos, movement, p_height);
	handle_axis_collision(1, &pos, prev_pos, movement, p_height);
	handle_thing_collisions(&pos, prev_pos, p_height);

	#endif

	*ref_pos = pos;
}


/////

/*
static void check_axis(vec* const ref_pos, const vec movement, const double p_height) {
	const vec pos = *ref_pos;

	if (!point_exists_at(pos[0] + movement[0], pos[1]), p_height)
		(*ref_pos)[]
}
*/

/////

// *ref_pos += movement;

hit_detection(ref_pos, prev_pos, movement, p_height);

// *pos += movement;
/*
if (!map_point(current_level.wall_data, (*pos)[0] + movement[0], (*pos)[1]))
	(*pos)[0] += movement[0];

if (!map_point(current_level.wall_data, (*pos)[0], (*pos)[1] + movement[1]))
	(*pos)[1] += movement[1];
*/

/////

/*
vec pos = *ref_pos;
if (!map_point(current_level.wall_data, pos[0] + movement[0], pos[1]))
	pos[0] += movement[0];

if (!map_point(current_level.wall_data, pos[0], pos[1] + movement[1]))
	pos[1] += movement[1];
*/

///// NOTE: this code was helpful:

https://github.com/Mekire/pygame-raycasting-experiment

/////