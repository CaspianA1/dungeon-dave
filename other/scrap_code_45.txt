void retreat_enemy(Enemy* const restrict enemy, const Player player) {
	Navigator* const restrict nav = &enemy -> nav;

	if (enemy -> state == Retreating) {
		update_path_if_needed(nav, player.pos, player.jump);
	}

	else {
		while (1) {
			const VectorF new_spot = {rand() % current_level.map_width, rand() % current_level.map_height};
			if (wall_point(new_spot[0], new_spot[1])) continue;
			enemy -> animations.billboard.pos = new_spot;
			// if the new dest isn't navigatable to, find a new spot
			if (update_path_if_needed(nav, player.pos, player.jump) == CouldNotNavigate)
				continue;

			set_enemy_state(enemy, Retreating);
			break;
		}
	}
}

case Retreating:
	/* if vantage point reached, wait for some amount of time,
	and then find a new vantage point */
	break;

// the pos is stored in the Animation, and the Navigator stores a pointer to that

/////

case Chasing: case Attacking: {
	const NavigatorState navigator_state = update_path_if_needed(nav, player.pos, player.jump);
	if (enemy -> state == Chasing) {
		if (navigator_state == ReachedDest) set_enemy_state(enemy, Attacking, 0);
	}

	else {
		printf("Attacking\n");
		// printf("Attacking, dist = %lf\n", dist);
		// if (dist >= thresholds.begin_chasing) set_enemy_state(enemy, Chasing, 0);
		// else, attack
	}
	break;
}

/////

/*
printf("In attack\n");
if (dist >= thresholds.begin_chasing) {
	printf("Switch to chase b/c dist is %lf\n", dist);
	set_enemy_state(enemy, Chasing, 0);
}
*/

/////

// store pixels in a local buffer, and write them afterwards? vram is far away
// https://stackoverflow.com/questions/2963898/faster-alternative-to-memcpy

/////

static double foo = 0;
if (keys[SDL_SCANCODE_T]) foo += 0.01;
if (keys[SDL_SCANCODE_Y]) foo -= 0.01;
DEBUG(foo, lf);

(void) z_pitch;
// double y_shift = z_pitch;
double y_shift = foo * settings.screen_height;
DEBUG(y_shift, lf);

/*
if the height increases, less should be shown at the bottom, and more should be shown at the top
*/

double y_portion_available = settings.half_screen_height;
// y_portion_available -= p_height * settings.screen_height;
double y_src_available = skybox.max_height;

// const double y_portion_available = settings.screen_height;
// const double available_ratio = y_portion_available / settings.screen_height;
// const double y_src_available = available_ratio * skybox.max_height;

/////

const double third_dest_height = settings.screen_height / 3.0;

/*
double y_shift = 20;
double y_portion_available = settings.half_screen_height;
double y_src_available = skybox.max_height;
*/

/////

(void) z_pitch;
// show a select third at z-pitch and height 0

/////

//
double dest_height = settings.half_screen_height;
const double z_pitch_ratio = (double) z_pitch / dest_height;
//
double src_y = 0, dest_y = 0, src_height = skybox.max_height;
//
double third_src = skybox.max_height / 3.0;
double src_z_pitch = z_pitch_ratio * third_src;
//
src_y = third_src - src_z_pitch;
src_height = third_src;
//
if (z_pitch > 0) { // show more if looking up
	printf("Adjust\n");
	/*
	double src_z_pitch = z_pitch_ratio * src_height;
	src_height -= src_z_pitch;
	*/
}
//

/////

//////////
static double center = 0.5;
if (keys[SDL_SCANCODE_T] && center < 1.0) center += 0.01;
if (keys[SDL_SCANCODE_Y] && center > 0.0) center -= 0.01;
if (keys[SDL_SCANCODE_U]) center = 0.5;
DEBUG(center, lf);
center = 0.5;
//////////

/*
When lowering the center, the content is being stretched, instead of more being shown.
An example is when the center is 0.5 and 't' is pressed.
*/

const double dest_height = settings.screen_height * center;
const double third_src_height = skybox.max_height / 3.0;
double src_height = third_src_height;

// src_height += (skybox.max_height * (center - 0.75));

DEBUG(src_height, lf);
printf("---\n");

const double z_pitch_ratio = (double) z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch;
//////////

/////

/*
When lowering the center, the content is being stretched, instead of more being shown.
An example is when the center is 0.5 and 't' is pressed.
*/

///// This part works without the floor plane:

//////////
const double dest_height = settings.half_screen_height;
const double src_height = skybox.max_height / 3.0;

const double z_pitch_ratio = (double) z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch;
//////////

///// This does things a little bit differently:

//////////
const double dest_y = z_pitch;
const double dest_height = settings.half_screen_height;
const double src_height = skybox.max_height / 3.0;

const double z_pitch_ratio = (double) z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch;

DEBUG(skybox.max_height, d);
DEBUG(src_y + src_height, lf);
//////////

///// Works for when looking down:

//////////
double dest_y;

if (z_pitch < 0)
	dest_y = z_pitch;
else
	dest_y = 0;

const double dest_height = settings.half_screen_height;
const double src_height = skybox.max_height / 3.0;

const double z_pitch_ratio = (double) z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch;

DEBUG(skybox.max_height, d);
DEBUG(src_y + src_height, lf);
//////////

/////

DEBUG(z_pitch, d);
double dest_y, dest_height;

if (z_pitch < 0) {
	dest_y = z_pitch;
	dest_height = settings.half_screen_height;
}
else { // when looking up
	dest_y = z_pitch;
	dest_height = settings.half_screen_height ; // + z_pitch;
}

/////

const double f = ((double) z_pitch + settings.half_screen_height) / settings.screen_height;
double z_pitch_ratio = f; // (double) (z_pitch - 1.0) / dest_height;
if (keys[SDL_SCANCODE_C]) z_pitch_ratio = (double) (z_pitch - 1.0) / dest_height;

///// This almost works:

//////////

const double dest_y = z_pitch, dest_height = settings.half_screen_height;
// I need to adjust src_height and dest_height
// find out what percentage of the skybox I need to show when looking completely up
// also, the texture box shouldn't move down when looking up and down
const double src_height = skybox.max_height / 3.0;

const double z_pitch_ratio = (double) z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch;

//////////

/////

const double z_pitch_ratio = (double) z_pitch / settings.screen_height + 0.5;

/////

//////////

const double dest_y = z_pitch, dest_height = settings.half_screen_height;
// I need to adjust src_height and dest_height
// find out what percentage of the skybox I need to show when looking completely up
// also, the texture box shouldn't move down when looking up and down

const double magic_num = 1.0 / 3.0;
const double src_height = skybox.max_height * magic_num;

const double z_pitch_ratio = z_pitch / dest_height;
const double src_z_pitch = z_pitch_ratio * src_height;
// DEBUG(src_z_pitch, lf);
const double src_y = src_height - src_z_pitch;

//////////

/////

/*
if (y_shift < 0) y_shift = 0;
else if (y_shift >= settings.screen_height) y_shift = settings.screen_height - 1;
*/

/////

/*
const double z_pitch_ratio = (y_shift - settings.half_screen_height) / dest_height;
const double src_height = skybox.max_height / 3.0;

const double src_z_pitch = z_pitch_ratio * src_height;
const double src_y = src_height - src_z_pitch * 2.0;
*/

/////

// all down = 0/3, middle = 1/3, all up = 2/3

/////

/*
static const byte wall_data[map_height * map_width] = {
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
	5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
	5, 0, 0, 0, 4, 4, 3, 3, 0, 1, 1, 5,
	5, 0, 0, 0, 4, 4, 3, 3, 2, 2, 0, 5,
	5, 0, 0, 0, 4, 0, 3, 3, 0, 0, 0, 5,
	5, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5,
	5, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 5,
	5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
};
*/

/////

/*
for (int y = 0; y < map_height; y++) {
	memcpy(debug_level.wall_data[y], &wall_data[y], map_width);
	memset(debug_level.ceiling_data[y], 2, map_width);
	memset(debug_level.floor_data[y], 2, map_width);
}
*/

/*
const int bytes = map_width * map_height;
// DEBUG(bytes, d);
// memcpy(debug_level.wall_data, wall_data, bytes);
m_memcpy(debug_level.wall_data, wall_data, bytes);
*/

/*
const int bytes = map_width * map_height;
m_memcpy(debug_level.wall_data, wall_data, bytes);
*/

/////

/*
const int bytes = map_width * map_height;
memset(debug_level.wall_data, 1, bytes);

memset(debug_level.wall_data, 2, map_width);
*/

/////

const int bytes = map_width * map_height;

for (int y = 0; y < map_height; y++) {
	for (int x = 0; x < map_width; x++) {
		debug_level.wall_data[y * map_width + x] = y;
	}
}

memset(debug_level.ceiling_data, 2, bytes);
memset(debug_level.floor_data, 2, bytes);

/*
for (int x = 0; x < map_width; x++) {
	printf("{");
	for (int y = 0; y < map_height; y++) {
		printf("%d, ", wall_data[y][x]);
	}
	printf("},\n");
}
*/

for (int y = 0; y < map_height; y++) {
	printf("{");
	for (int x = 0; x < map_width; x++) {
		printf("%d, ", wall_data[y][x]);
	}
	printf("},\n");
}

printf("Incorrect:\n");
for (int y = 0; y < map_height; y++) {
	printf("{");
	for (int x = 0; x < map_width; x++) {
		// printf("%d, ", debug_level.wall_data[x * map_width + y]);
		printf("%d, ", debug_level.wall_data[y * map_height + x]);
	}
	printf("},\n");
}

/////

void m_memcpy(void* dest, const void* src, size_t n) {
	char* csrc = (char*) src;
	char* cdest = (char*) dest;
	
	/*
	for (size_t i = 0; i < n; i++) {
		printf("i = %zu, csrc[i] = %d\n", i, csrc[i]);
		printf("---\n");

		cdest[i] = csrc[i];
	}

	for (size_t i = 0; i < n; i++) {
		if (cdest[i] != csrc[i]) printf("Bad\n");
	}
	*/

	int w = 12, h = 10;

	for (int x = 0; x < w; x++) {
		for (int y = 0; y < h; y++)
			cdest[y * w + x] = csrc[y * w + x];
	}
}

/////

/*
byte** restrict all_visited = wmalloc(current_level.map_height * sizeof(byte*));
for (int y = 0; y < current_level.map_height; y++)
	all_visited[y] = wcalloc(current_level.map_width, sizeof(byte));
all_visited[int_begin.y][int_begin.x] = 1;
*/

/////

/*
for (int y = 0; y < map_height; y++) {
	for (int x = 0; x < map_width; x++) {
		debug_level.wall_data[y * map_width + x] = wall_data[y][x];
	}
}
*/

/////

for (int y = 0; y < map_height; y++) {
	printf("{");
	for (int x = 0; x < map_width; x++) {
		printf("%d, ", wall_data[y][x]);
	}
	printf("},\n");
}

printf("Incorrect:\n");
for (int y = 0; y < map_height; y++) {
	printf("{");
	for (int x = 0; x < map_width; x++) {
		printf("%d, ", debug_level.wall_data[y * map_width + x]);
	}
	printf("},\n");
}

/////

//////////

/*
I need to adjust src_height and dest_height
find out what percentage of the skybox I need to show when looking completely up
also, the texture box shouldn't move down when looking up and down

All of the dest math is correct

some warping when looking up
make the scroll rate even when looking up and down
https://www.dcode.fr/function-equation-finder
make sure that there is an equal amount of skybox to show when looking up and down

old:
	at the top: y = 0/3, height = 2/3
	in the middle: y = 1/3, height = 1/3
	at the bottom: y = 3/3, height = 0/3
*/

/*
const double two_thirds = 2.0 / 3.0;
const double dest_y = 0, dest_height = y_shift; // maybe dest_y shouldn't always be 0
const double y_shift_percentage = y_shift / settings.screen_height;

const double dest_height_show_percentage = y_shift_percentage * two_thirds;
const int src_height = dest_height_show_percentage * skybox.max_height;

const double src_y_show_percentage =
	two_thirds * y_shift_percentage * y_shift_percentage - 5.0 / 3.0 * y_shift_percentage + 1.0;
const int src_y = src_y_show_percentage * skybox.max_height;
*/

/*
const double dest_y = 0, dest_height = y_shift;
const double src_y = 0, src_height = skybox.max_height;
*/

/*
const double dest_y = 0, dest_height = y_shift;
const double third_src_height = skybox.max_height / 3.0;
const double src_y = third_src_height, src_height = third_src_height;
*/

//////////

///// squished, but even:

/*
const double dest_y = 0, dest_height = y_shift;
const double third_src_height = skybox.max_height / 3.0;
const double look_up_percent = y_shift / settings.screen_height;
const double src_y = skybox.max_height * (1.0 - look_up_percent);
const double src_height = skybox.max_height * look_up_percent;
*/

///// The final sky code:

//////////

/*
I need to adjust src_height and dest_height
find out what percentage of the skybox I need to show when looking completely up
also, the texture box shouldn't move down when looking up and down

All of the dest math is correct

some warping when looking up
make the scroll rate even when looking up and down
https://www.dcode.fr/function-equation-finder
make sure that there is an equal amount of skybox to show when looking up and down
*/

const double
	dest_y = 0.0, dest_height = y_shift,
	look_up_percent = y_shift / settings.screen_height;

// src_height can be divided to determine what fraction is shown at once
const double
	src_y = skybox.max_height * (1.0 - look_up_percent),
	src_height = skybox.max_height * look_up_percent;

//////////

/////

typedef struct {
	double val;
	const double step;
	double max;
} Domain;

/////

const double new_num = y_shift - 51.0;

double look_up_percent = y_shift / settings.screen_height;
// if (look_up_percent <= 0.0) return;

if (look_up_percent > 0.0) {
	look_up_percent = new_num / settings.screen_height;
}

/////

/*
proj_dist = half_scr_w / tan(fov / 2)
proj_dist * tan(fov / 2) = half_scr_w
screen_w = 2 * proj_dist * tan(fov / 2)
*/

/////

void draw_precalculated_wall(const Sprite wall_sprite, const SDL_FRect* dest,
	const int offset, const double src_height) {

	const SDL_Rect slice = {offset, 0, 1, src_height};
	SDL_RenderCopyF(screen.renderer, sprite.texture, &slice, dest);
}

/////

// draw_wall(cast_data, dir, raised_wall, sprite_height, max_raised_wall_h);

/////