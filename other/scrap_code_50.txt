#define PIXEL_FORMAT_BYTES_PER_PIXEL 4

/////

inlinable void draw_from_hit(const vec hit, const double actual_dist, const int screen_x, Uint32* pixbuf_row) {
	const byte floor_point = map_point(current_level.floor_data, hit[0], hit[1]);
	const SDL_Surface* const surface = current_level.walls[floor_point - 1].surface;
	const int max_offset = sprite.size.x - 1;

	const ivec floored_hit = vec_to_ivec(hit);
	const ivec surface_offset = {
		(hit[0] - floored_hit.x) * max_offset,
		(hit[1] - floored_hit.y) * max_offset
	};

	#ifdef SHADING_ENABLED
	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);
	const byte r = (byte) (src >> 16) * shade, g = (byte) (src >> 8) * shade, b = (byte) src * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;
	#else
	(void) dist;
	#endif

	for (int x = screen_x; x < screen_x + settings.ray_column_width; x++)
		*(pixbuf_row + x) = src;
}

/////

typedef struct {
	void* pixels;
	ivec size;
} PixelwiseSprite;

PixelwiseSprite init_pixelwise_sprite(const char* const path) {
	const Sprite base_sprite = init_sprite(path);
	PixelwiseSprite pixelwise_sprite = {.size = base_sprite.size};
	SDL_Texture* const prev_render_target = SDL_GetRenderTarget(screen.renderer);
	SDL_SetRenderTarget(screen.renderer, base_sprite.texture);
	const int pixel_pitch = PIXEL_FORMAT_BYTES_PER_PIXEL * base_sprite.size.x;
	SDL_RenderReadPixels(screen.renderer, NULL, PIXEL_FORMAT, &pixelwise_sprite.pixels, pixel_pitch);
	SDL_SetRenderTarget(screen.renderer, prev_render_target);
	return pixelwise_sprite;
}

/////

// PixelwiseSprite pws = init_pixelwise_sprite("../assets/walls/mesa.bmp");

/////

/*
for (int y = 0; y < size.y; y++) {
	Uint32* row = read_texture_row(p.pixels, p.pitch, y);
	for (int x = 0; x < size.x; x++)
		row[x] = 4291998860 / (x + 1);
}
*/

/////

inlinable void basic_draw_from_hit(const vec hit, const double actual_dist, const int screen_x, Uint32* pixbuf_row) {
	(void) hit;
	(void) actual_dist;

	Uint32 src = 4291998860; // tan

	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);
	const byte r = (byte) (src >> 16) * shade, g = (byte) (src >> 8) * shade, b = (byte) src * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;

	for (int x = screen_x; x < screen_x + settings.ray_column_width; x++)
		*(pixbuf_row + x) = src;
}

/////

/*
SDL_UpdateTexture(p.texture, NULL, converted_surface -> pixels, converted_surface -> pitch);
SDL_FreeSurface(converted_surface);
printf("Here\n");
DEBUG(SDL_GetError(), s);
*/

/////

/*
else if ((i == TopLeft) ||
	(i == TopRight) ||
	(i == BottomRight) ||
	(i == BottomLeft)) {}
*/

/*
if ((VectorII_eq(neighbor, top_left) && map_point(current_level.wall_data, left.x, left.y)) ||
	(VectorII_eq(neighbor, top_right) && map_point(current_level.wall_data, right.x, right.y)) ||
	(VectorII_eq(neighbor, bottom_right) && map_point(current_level.wall_data, bottom.x, bottom.y)) ||
	(VectorII_eq(neighbor, bottom_left) && map_point(current_level.wall_data, bottom.x, bottom.y)))
	continue;
*/

/////

/*
const VectorI
	top = {vertex.x, vertex.y - 1},
	bottom = {vertex.x, vertex.y + 1},
	left = {vertex.x - 1, vertex.y},
	right = {vertex.x + 1, vertex.y},

	top_left = {vertex.x - 1, vertex.y - 1},
	bottom_left = {vertex.x - 1, vertex.y + 1},
	top_right = {vertex.x + 1, vertex.y - 1},
	bottom_right = {vertex.x + 1, vertex.y + 1};

// use an enum
const VectorI neighbors[8] = {
	top, bottom, left, right, top_left, bottom_left, top_right, bottom_right
};
*/

/////

// for no wall collisions, rule out movement with a corner wall and diagonal movement

/////

const ivec neighbor = neighbors[i];
if (ivec_out_of_bounds(neighbor) || map_point(current_level.wall_data, neighbor.x, neighbor.y))
	skip_this_neighbor = 1;

else if (i == BottomLeft) {
	if (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Bottom))
		skip_this_neighbor = 1;
}

else if (i == BottomLeft && neighbor_map_point(neighbors, Left))
	skip_this_neighbor = 1;
else if (i == BottomLeft && neighbor_map_point(neighbors, Bottom))
	skip_this_neighbor = 1;

else if (i == BottomRight && neighbor_map_point(neighbors, Bottom))
	skip_this_neighbor = 1;
else if (i == BottomRight && neighbor_map_point(neighbors, Right))
	skip_this_neighbor = 1;

else if (i == TopRight && neighbor_map_point(neighbors, Right))
	skip_this_neighbor = 1;
else if (i == TopRight && neighbor_map_point(neighbors, Top))
	skip_this_neighbor = 1;

else if (i == TopLeft && neighbor_map_point(neighbors, Top))
	skip_this_neighbor = 1;
else if (i == TopLeft && neighbor_map_point(neighbors, Left))
	skip_this_neighbor = 1;

/////

inlinable byte navigator_in_wall(const vec pos) { // 8 directions
	return map_point(current_level.wall_data, pos[0] + 0.5, pos[1])
		|| map_point(current_level.wall_data, pos[0] - 0.5, pos[1])
		|| map_point(current_level.wall_data, pos[0], pos[1] + 0.5)
		|| map_point(current_level.wall_data, pos[0], pos[1] - 0.5)
		|| map_point(current_level.wall_data, pos[0] + 0.5, pos[1] + 0.5)
		|| map_point(current_level.wall_data, pos[0] + 0.5, pos[1] - 0.5)
		|| map_point(current_level.wall_data, pos[0] - 0.5, pos[1] + 0.5)
		|| map_point(current_level.wall_data, pos[0] - 0.5, pos[1] - 0.5);
}

/////

/* construct a new path that has been guaranteed to not have any walls to clip into on its way;
for a given node on the path, if the enemy is in a wall during navigating, find a suitable replacement
node nearby - just keep trying to make that possible. but before that, don't allow the enemy BFS corner
movement, because that will remove many possible bugs later.
*/

/////

EnemyState prev_state = current_level.enemies[0].state;
while (1) {
	const Uint32 before = SDL_GetTicks();
	if (keys[SDL_SCANCODE_C]) DEBUG_VEC(player.pos);

	Enemy* const enemy = &current_level.enemies[0];
	if (keys[SDL_SCANCODE_F] && enemy -> state != Dead) {
		prev_state = enemy -> state;
		set_enemy_state(enemy, Dead, 1);
	}
	else if (keys[SDL_SCANCODE_G] && enemy -> state != Dead) {
		set_enemy_state(enemy, prev_state, 1);
	}

///// note: an enemy can never be caught in a wall while dead because the enemy never goes in a wall

int in_dead = 0;
while (1) {
	const Uint32 before = SDL_GetTicks();
	if (keys[SDL_SCANCODE_C]) DEBUG_VEC(player.pos);

	Enemy* const enemy = &current_level.enemies[0];
	if (keys[SDL_SCANCODE_F]) {
		if (in_dead) set_enemy_state(enemy, Chasing, 1);
		else set_enemy_state(enemy, Dead, 1);

		in_dead = !in_dead;
	}

	DEBUG(enemy -> state, d);

/////

// typedef enum {Top, Bottom, Left, Right, TopLeft, BottomLeft, TopRight, BottomRight} NeighborID;

/*
a b c
d e f
g h i
*/

///// The old neighbor ID scheme:

// typedef enum {Top, Bottom, Left, Right, TopLeft, BottomLeft, TopRight, BottomRight} NeighborID;

/*
const ivec neighbors[8] = {
	{vertex.x, vertex.y - 1}, {vertex.x, vertex.y + 1},
	{vertex.x - 1, vertex.y}, {vertex.x + 1, vertex.y},
	{vertex.x - 1, vertex.y - 1}, {vertex.x - 1, vertex.y + 1},
	{vertex.x + 1, vertex.y - 1}, {vertex.x + 1, vertex.y + 1}
};
*/

/////

/*
a b c
d e f
g h i

left to right is positive, right to left is negative
down is postive, up is negative
*/

/////

for (NeighborID i = 0; i < 8; i++) {
	byte skip_this_neighbor = 0;

	const ivec neighbor = ordinal_neighbors[i];
	if (ivec_out_of_bounds(neighbor) || map_point(current_level.wall_data, neighbor.x, neighbor.y))
		skip_this_neighbor = 1;

	/*
	skip conds:
	for TopLeft,     under or right
	for TopRight,    under or left
	for BottomLeft,  over or right
	for BottomRight, over or left

	TopLeft, TopRight, BottomLeft, BottomRight = 0, 2, 5, 7
	Top, Left, Right, Bottom = 1, 3, 4, 6


	*/

	else if (i == BottomLeft) { // BottomLeft = 5, Left = 3, Bottom = 6
		if (neighbor_map_point(ordinal_neighbors, Left) || neighbor_map_point(ordinal_neighbors, Bottom))
			skip_this_neighbor = 1;
	}

	else if (i == BottomRight) { // BottomRight = 7, Bottom = 6, Right = 4
		if (neighbor_map_point(ordinal_neighbors, Bottom) || neighbor_map_point(ordinal_neighbors, Right))
			skip_this_neighbor = 1;
	}

	else if (i == TopLeft) { // TopLeft = 0, Left = 3, Top = 1
		if (neighbor_map_point(ordinal_neighbors, Left) || neighbor_map_point(ordinal_neighbors, Top))
			skip_this_neighbor = 1;
	}

	else if (i == TopRight) { // TopRight = 2, Top = 1, Right = 4
		if (neighbor_map_point(ordinal_neighbors, Top) || neighbor_map_point(ordinal_neighbors, Right))
			skip_this_neighbor = 1;
	}

	if (skip_this_neighbor) continue;

///// A big clump of code:

const ivec neighbor = ordinal_neighbors[i];
if (ivec_out_of_bounds(neighbor) || map_point(current_level.wall_data, neighbor.x, neighbor.y))
	skip_this_neighbor = 1;

else if
	((ivec_out_of_bounds(neighbor) || map_point(current_level.wall_data, neighbor.x, neighbor.y)) ||
	(i == BottomLeft && (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Bottom))) ||
	(i == BottomRight && (neighbor_map_point(neighbors, Bottom) || neighbor_map_point(neighbors, Right))) ||
	(i == TopLeft && (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Top))) ||
	(i == TopRight && (neighbor_map_point(neighbors, Top) || neighbor_map_point(neighbors, Right))))
continue;

/*
skip conds:
for TopLeft,     under or right
for TopRight,    under or left
for BottomLeft,  over or right
for BottomRight, over or left

TopLeft, TopRight, BottomLeft, BottomRight = 0, 2, 5, 7
Top, Left, Right, Bottom = 1, 3, 4, 6
*/

else if (i == BottomLeft) { // BottomLeft = 5, Left = 3, Bottom = 6
	if (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Bottom))
		skip_this_neighbor = 1;
}

else if (i == BottomRight) { // BottomRight = 7, Bottom = 6, Right = 4
	if (neighbor_map_point(neighbors, Bottom) || neighbor_map_point(neighbors, Right))
		skip_this_neighbor = 1;
}

else if (i == TopLeft) { // TopLeft = 0, Left = 3, Top = 1
	if (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Top))
		skip_this_neighbor = 1;
}

else if (i == TopRight) { // TopRight = 2, Top = 1, Right = 4
	if (neighbor_map_point(neighbors, Top) || neighbor_map_point(neighbors, Right))
		skip_this_neighbor = 1;
}

if (skip_this_neighbor) continue;

/////

void 

void enqueue(const ivec elem) {

	/*
	for ()

		for (int i = path_queue -> length - 1; i > 0; i--)
			path_queue -> data[i] = path_queue -> data[i - 1];

	Route r = {1};
	*/
}

ivec dequeue(void) {

}

/////

/*
for the queue {a b c d e},
an enqueue of f becomes {f a b c d e},
and a dequeue becomes {f a b c d}
*/

/////