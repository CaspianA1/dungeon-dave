#define PIXEL_FORMAT_BYTES_PER_PIXEL 4

/////

inlinable void draw_from_hit(const vec hit, const double actual_dist, const int screen_x, Uint32* pixbuf_row) {
	const byte floor_point = map_point(current_level.floor_data, hit[0], hit[1]);
	const SDL_Surface* const surface = current_level.walls[floor_point - 1].surface;
	const int max_offset = sprite.size.x - 1;

	const ivec floored_hit = vec_to_ivec(hit);
	const ivec surface_offset = {
		(hit[0] - floored_hit.x) * max_offset,
		(hit[1] - floored_hit.y) * max_offset
	};

	#ifdef SHADING_ENABLED
	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);
	const byte r = (byte) (src >> 16) * shade, g = (byte) (src >> 8) * shade, b = (byte) src * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;
	#else
	(void) dist;
	#endif

	for (int x = screen_x; x < screen_x + settings.ray_column_width; x++)
		*(pixbuf_row + x) = src;
}

/////

typedef struct {
	void* pixels;
	ivec size;
} PixelwiseSprite;

PixelwiseSprite init_pixelwise_sprite(const char* const path) {
	const Sprite base_sprite = init_sprite(path);
	PixelwiseSprite pixelwise_sprite = {.size = base_sprite.size};
	SDL_Texture* const prev_render_target = SDL_GetRenderTarget(screen.renderer);
	SDL_SetRenderTarget(screen.renderer, base_sprite.texture);
	const int pixel_pitch = PIXEL_FORMAT_BYTES_PER_PIXEL * base_sprite.size.x;
	SDL_RenderReadPixels(screen.renderer, NULL, PIXEL_FORMAT, &pixelwise_sprite.pixels, pixel_pitch);
	SDL_SetRenderTarget(screen.renderer, prev_render_target);
	return pixelwise_sprite;
}

/////

// PixelwiseSprite pws = init_pixelwise_sprite("../assets/walls/mesa.bmp");

/////

/*
for (int y = 0; y < size.y; y++) {
	Uint32* row = read_texture_row(p.pixels, p.pitch, y);
	for (int x = 0; x < size.x; x++)
		row[x] = 4291998860 / (x + 1);
}
*/

/////

inlinable void basic_draw_from_hit(const vec hit, const double actual_dist, const int screen_x, Uint32* pixbuf_row) {
	(void) hit;
	(void) actual_dist;

	Uint32 src = 4291998860; // tan

	const double shade = calculate_shade(settings.proj_dist / actual_dist, hit);
	const byte r = (byte) (src >> 16) * shade, g = (byte) (src >> 8) * shade, b = (byte) src * shade;
	src = 0xFF000000 | (r << 16) | (g << 8) | b;

	for (int x = screen_x; x < screen_x + settings.ray_column_width; x++)
		*(pixbuf_row + x) = src;
}

/////

/*
SDL_UpdateTexture(p.texture, NULL, converted_surface -> pixels, converted_surface -> pitch);
SDL_FreeSurface(converted_surface);
printf("Here\n");
DEBUG(SDL_GetError(), s);
*/

/////

/*
else if ((i == TopLeft) ||
	(i == TopRight) ||
	(i == BottomRight) ||
	(i == BottomLeft)) {}
*/

/*
if ((VectorII_eq(neighbor, top_left) && map_point(current_level.wall_data, left.x, left.y)) ||
	(VectorII_eq(neighbor, top_right) && map_point(current_level.wall_data, right.x, right.y)) ||
	(VectorII_eq(neighbor, bottom_right) && map_point(current_level.wall_data, bottom.x, bottom.y)) ||
	(VectorII_eq(neighbor, bottom_left) && map_point(current_level.wall_data, bottom.x, bottom.y)))
	continue;
*/

/////

/*
const VectorI
	top = {vertex.x, vertex.y - 1},
	bottom = {vertex.x, vertex.y + 1},
	left = {vertex.x - 1, vertex.y},
	right = {vertex.x + 1, vertex.y},

	top_left = {vertex.x - 1, vertex.y - 1},
	bottom_left = {vertex.x - 1, vertex.y + 1},
	top_right = {vertex.x + 1, vertex.y - 1},
	bottom_right = {vertex.x + 1, vertex.y + 1};

// use an enum
const VectorI neighbors[8] = {
	top, bottom, left, right, top_left, bottom_left, top_right, bottom_right
};
*/

/////

// for no wall collisions, rule out movement with a corner wall and diagonal movement

/////

const ivec neighbor = neighbors[i];
if (ivec_out_of_bounds(neighbor) || map_point(current_level.wall_data, neighbor.x, neighbor.y))
	skip_this_neighbor = 1;

else if (i == BottomLeft) {
	if (neighbor_map_point(neighbors, Left) || neighbor_map_point(neighbors, Bottom))
		skip_this_neighbor = 1;
}

else if (i == BottomLeft && neighbor_map_point(neighbors, Left))
	skip_this_neighbor = 1;
else if (i == BottomLeft && neighbor_map_point(neighbors, Bottom))
	skip_this_neighbor = 1;

else if (i == BottomRight && neighbor_map_point(neighbors, Bottom))
	skip_this_neighbor = 1;
else if (i == BottomRight && neighbor_map_point(neighbors, Right))
	skip_this_neighbor = 1;

else if (i == TopRight && neighbor_map_point(neighbors, Right))
	skip_this_neighbor = 1;
else if (i == TopRight && neighbor_map_point(neighbors, Top))
	skip_this_neighbor = 1;

else if (i == TopLeft && neighbor_map_point(neighbors, Top))
	skip_this_neighbor = 1;
else if (i == TopLeft && neighbor_map_point(neighbors, Left))
	skip_this_neighbor = 1;

/////