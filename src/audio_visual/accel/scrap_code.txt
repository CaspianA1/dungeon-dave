///// Old demo 3 stuff:

#include "demo_2.c"
#define deinit_texture(t) glDeleteTextures(1, &t)

DemoVars demo_3_init(void) {
	DemoVars dv;

	const char* const vertex_shader =
		"#version 330 core\n"
		"layout(location = 0) in vec3 vertexPosition_modelspace\n"
		"layout(location = 1) in vec2 vertexUV\n"
		"out vec2 UV;\n"
		"uniform mat4 MVP;\n"
		"void main() {\n"
			"gl_Position =  MVP * vec4(vertexPosition_modelspace, 1);\n"
			"UV = vertexUV;\n"
		"}\n",

	*const fragment_shader =
		"#version 330 core\n"
		"in vec2 UV;\n"
		"out vec3 color;\n"
		"uniform sampler2D myTextureSampler;\n"
		"void main() {\n"
    		"color = texture(myTextureSampler, UV).rgb;\n"
		"}\n";
	
	dv.shader_program = init_shader_program(vertex_shader, fragment_shader);

	const GLfloat uv_buffer_data[] = {
    	0.000059f, 1.0f-0.000004f,
    	0.000103f, 1.0f-0.336048f,
    	0.335973f, 1.0f-0.335903f,
    	1.000023f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.336024f, 1.0f-0.671877f,
    	0.667969f, 1.0f-0.671889f,
    	1.000023f, 1.0f-0.000013f,
    	0.668104f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.000059f, 1.0f-0.000004f,
    	0.335973f, 1.0f-0.335903f,
    	0.336098f, 1.0f-0.000071f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.336024f, 1.0f-0.671877f,
    	1.000004f, 1.0f-0.671847f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.668104f, 1.0f-0.000013f,
    	0.335973f, 1.0f-0.335903f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.668104f, 1.0f-0.000013f,
    	0.336098f, 1.0f-0.000071f,
    	0.000103f, 1.0f-0.336048f,
    	0.000004f, 1.0f-0.671870f,
    	0.336024f, 1.0f-0.671877f,
    	0.000103f, 1.0f-0.336048f,
    	0.336024f, 1.0f-0.671877f,
    	0.335973f, 1.0f-0.335903f,
    	0.667969f, 1.0f-0.671889f,
    	1.000004f, 1.0f-0.671847f,
    	0.667979f, 1.0f-0.335851f
	};

	(void) uv_buffer_data;

	return dv;
}

GLuint init_texture(const char* const path) {
	SDL_Surface* const image = SDL_LoadBMP(path);
	if (image == NULL) fail("open image file", OpenImageFile);
	SDL_LockSurface(image);

	GLuint texture;

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image -> w, image -> h, 0, GL_BGR, GL_UNSIGNED_BYTE, image -> pixels);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glGenerateMipmap(GL_TEXTURE_2D);

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);
	return texture;
}

void demo_3_drawer(const DemoVars dv) {
	/*
	GLuint foo = init_texture("assets/walls/mesa.bmp");
	deinit_texture(foo);
	*/

	demo_2_drawer(dv);
}

int main(void) {
	// load_texture("assets/walls/mesa.bmp");
	make_application(demo_3_drawer, demo_2_init, demo_1_deinit);
}

///// Lots of vertex testing:


	GLfloat texcoords[][2] = { {0.0,0.0},    {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0}
                             };

	GLubyte indices[24] = {0,1,2,3, 4,5,6,7, 3,2,5,4, 7,6,1,0,
                                  8,9,10,11, 12,13,14,15};

	/*
	for (int i = 0; i < 24; i++) {
		GLfloat* uv = texcoords[indices[i]];
		printf("%lff, %lff,\n", uv[0], uv[1]);
	}

	GLfloat uv_data[num_uv_floats] = {
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,

		0.0, 1.0,
	};
	*/

GLfloat uv_data[] = {
	0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
};



	/*
	#define TOP_LEFT 0.0f, 0.0f
	#define BOTTOM_LEFT 1.0f, 0.0f
	#define TOP_RIGHT 0.0f, 1.0f

	#define TRI_SET TOP_RIGHT, BOTTOM_LEFT, TOP_LEFT
	#define REV_TRI_SET TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT

	static const GLfloat uv_data[num_uv_floats] = {
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET
	};
	*/

	/*
	static const GLfloat uv_data[num_uv_floats] = {
		0.000059f, 1.0f-0.000004f,
		0.000103f, 1.0f-0.336048f,
		0.335973f, 1.0f-0.335903f,
		1.000023f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.336024f, 1.0f-0.671877f,
		0.667969f, 1.0f-0.671889f,
		1.000023f, 1.0f-0.000013f,
		0.668104f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.000059f, 1.0f-0.000004f,
		0.335973f, 1.0f-0.335903f,
		0.336098f, 1.0f-0.000071f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.336024f, 1.0f-0.671877f,
		1.000004f, 1.0f-0.671847f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.668104f, 1.0f-0.000013f,
		0.335973f, 1.0f-0.335903f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.668104f, 1.0f-0.000013f,
		0.336098f, 1.0f-0.000071f,
		0.000103f, 1.0f-0.336048f,
		0.000004f, 1.0f-0.671870f,
		0.336024f, 1.0f-0.671877f,
		0.000103f, 1.0f-0.336048f,
		0.336024f, 1.0f-0.671877f,
		0.335973f, 1.0f-0.335903f,
		0.667969f, 1.0f-0.671889f,
		1.000004f, 1.0f-0.671847f,
		0.667979f, 1.0f-0.335851f
	};
	*/

///// Even more tries:


	static const GLfloat uv_data[num_uv_floats] = {
		/* Sorta worked:
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f
		*/

		/* Flipped 90 degrees:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		*/


		/* Almost:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f
		*/

		/*
		0.0f, 0.0f,
		0.5f, 0.5f,
		1.0f, 1.0f
		*/

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
	};

///// A note on UV reversals:

	// rev
	#define FIRST_UV 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
	#define SECOND_UV 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f,

	// rev
	#define THIRD_UV 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
	#define FOURTH_UV 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,

	// fifth and sixth are reversed
	#define FIFTH_UV 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	#define SIXTH_UV 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,

	// 1 2 2 3 4 3 3 2 5 1 4 6

///// An indexing test

// Possibilities
#define P1 1.0f, 1.0f, 1.0f,
#define P2 -1.0f, -1.0f, -1.0f,

#define P3 -1.0f, 1.0f, 1.0f,
#define P4 1.0f, -1.0f, 1.0f,
#define P5 1.0f, 1.0f, -1.0f,

#define P6 -1.0f, -1.0f, 1.0f,
#define P7 1.0f, -1.0f, -1.0f,

#define P8 -1.0f, 1.0f, -1.0f

/*
	P2 P6 P3

	P5 P2 P8
*/

///// Stuff with automatic index generation:


	int index_buf_len = 0;
	int index_buffer[cube_num_points];

	for (int i = 0; i < cube_num_points; i += 3) {
		const float x = demo_3_vertex_data[i], y = demo_3_vertex_data[i + 1], z = demo_3_vertex_data[i + 2];

		byte found_match = 0;
		for (int j = 0; j < i; j += 3) {
			const float cx = demo_3_vertex_data[j], cy = demo_3_vertex_data[j + 1], cz = demo_3_vertex_data[j + 2];
			if (x == cx && y == cy && z == cz) {
				index_buffer[index_buf_len++] = j / 3;
				found_match = 1;
				break;
			}
		}

		if (!found_match) {
			printf("%lf, %lf, %lf\n", (double) x, (double) y, (double) z);
			index_buffer[index_buf_len] = index_buf_len;
			index_buf_len++;
		}
	}

	for (int i = 0; i < index_buf_len + 1; i++) {
		printf("%d%s", index_buffer[i], (i == index_buf_len - 1) ? "" : ", ");
	}
	putchar('\n');

///// And more of that:

#define A -1.000000, -1.000000, -1.000000
#define B -1.000000, -1.000000, 1.000000
#define C -1.000000, 1.000000, 1.000000
#define D 1.000000, 1.000000, -1.000000
#define E -1.000000, 1.000000, -1.000000
#define F 1.000000, -1.000000, 1.000000
#define G 1.000000, -1.000000, -1.000000
#define H 1.000000, 1.000000, 1.000000
/* 0, 1, 2, 3, 0,
5, 6, 0, 8, 3, 8,
0, 0, 2, 5, 6, 1, 0, 2, 1, 6, 21, 8, 3, 8, 21, 6, 21, 3, 5, 21, 5, 2, 21, 2, 6
*/

const GLfloat demo_3_vertex_data[cube_num_points] = {
	// A B C D A

///// Old vertex data:

	/*
	-1.0f, -1.0f, -1.0f, // triangle 1: begin
	-1.0f, -1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f, // triangle 1: end

	1.0f, 1.0f, -1.0f, // triangle 2: begin
	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f, // triangle 2: end

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,

	1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f
	*/

/////


		/*
		top_left_x, 0.0f, z,
		top_left_x + width, 0.0f, z,
		top_left_x, -height, z,

		top_left_x, -height, z,
		top_left_x + width, -height, z,
		top_left_x + width, 0.0f, z
		*/

		/*
		0.0f, 0.0f, z,
		width, 0.0f, z,
		0.0f, -height, z,

		0.0f, -height, z,
		width, -height, z,
		width, 0.0f, z
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,

		-s, -s, 0.0f,
		s, -s, 0.0f,
		s, s, 0.0f
		*/

/////

		/*
		top_left_x, top_left_y, z,
		top_left_x + width, top_left_y, z,
		top_left_x, top_left_y - height, z,

		top_left_x, top_left_y - height, z,
		top_left_x + width, top_left_y - height, z,
		top_left_x + width, top_left_y, z
		*/
	
/////

	(void) top_left_corner;
	// const float half_width = width / 2.0f, half_height = height / 2.0f;

	/*
	1____0
	|  . |
	2____|


	0___1
	|   /
	|  /
	| /
	2/
	*/

	/*
	Top left corner at {0, 0}
	*/

/////

		/*
		0.0f, 0.0f, far,
		1.0f, 0.0f, far,
		0.0f, 0.0f, near
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,
		*/

		/*
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		0.0f, 1.0f, 0.0f
		*/

		/*
		0.0f, height, far,
		0.0f, height, near,
		1.0f, height, far
		*/

/////

	/*
	GLfloat
		*const plane_vertices = create_vert_plane(top_left_corner, size_hori, size_vert),
		*const uv_data = create_uv_for_plane(size_hori, size_vert);

	sgl.num_vertex_buffers = 2;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers,
		plane_vertices, plane_vertex_bytes,
		uv_data, plane_uv_bytes);

	free(plane_vertices);
	free(uv_data);
	*/

/////

Functions to make:
- void create_cuboid(const vec3 origin, const vec3 size);
actually, instead of create_cuboid, make a make_planes fn (since sector meshes will not exactly be rectangles)
- GLfloat* join_plane_vertices(const GLfloat* const plane_1, const GLfloat* const plane_2);

/////

void draw_triangles(const int num_triangles) {
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // num_triangles * 3
	// glDrawArraysInstanced(GL_TRIANGLES, 0, num_triangles * 3, 1);
	// glDrawElements(GL_TRIANGLES, num_triangles * 3, GL_UNSIGNED_INT, NULL);
	// GL_ERR_CHECK;
}

/////

	/////
	glGenBuffers(sgl.num_vertex_buffers, &sgl.vertex_buffers);
	glBindBuffer(GL_ARRAY_BUFFER, sgl.vertex_buffers);
	glBufferData(GL_ARRAY_BUFFER, interleaved_plane_bytes, plane_data, GL_STATIC_DRAW);
	/////

/////