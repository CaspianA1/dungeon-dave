///// Old demo 3 stuff:

#include "demo_2.c"
#define deinit_texture(t) glDeleteTextures(1, &t)

DemoVars demo_3_init(void) {
	DemoVars dv;

	const char* const vertex_shader =
		"#version 330 core\n"
		"layout(location = 0) in vec3 vertexPosition_modelspace\n"
		"layout(location = 1) in vec2 vertexUV\n"
		"out vec2 UV;\n"
		"uniform mat4 MVP;\n"
		"void main() {\n"
			"gl_Position =  MVP * vec4(vertexPosition_modelspace, 1);\n"
			"UV = vertexUV;\n"
		"}\n",

	*const fragment_shader =
		"#version 330 core\n"
		"in vec2 UV;\n"
		"out vec3 color;\n"
		"uniform sampler2D myTextureSampler;\n"
		"void main() {\n"
    		"color = texture(myTextureSampler, UV).rgb;\n"
		"}\n";
	
	dv.shader_program = init_shader_program(vertex_shader, fragment_shader);

	const GLfloat uv_buffer_data[] = {
    	0.000059f, 1.0f-0.000004f,
    	0.000103f, 1.0f-0.336048f,
    	0.335973f, 1.0f-0.335903f,
    	1.000023f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.336024f, 1.0f-0.671877f,
    	0.667969f, 1.0f-0.671889f,
    	1.000023f, 1.0f-0.000013f,
    	0.668104f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.000059f, 1.0f-0.000004f,
    	0.335973f, 1.0f-0.335903f,
    	0.336098f, 1.0f-0.000071f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.336024f, 1.0f-0.671877f,
    	1.000004f, 1.0f-0.671847f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.668104f, 1.0f-0.000013f,
    	0.335973f, 1.0f-0.335903f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.668104f, 1.0f-0.000013f,
    	0.336098f, 1.0f-0.000071f,
    	0.000103f, 1.0f-0.336048f,
    	0.000004f, 1.0f-0.671870f,
    	0.336024f, 1.0f-0.671877f,
    	0.000103f, 1.0f-0.336048f,
    	0.336024f, 1.0f-0.671877f,
    	0.335973f, 1.0f-0.335903f,
    	0.667969f, 1.0f-0.671889f,
    	1.000004f, 1.0f-0.671847f,
    	0.667979f, 1.0f-0.335851f
	};

	(void) uv_buffer_data;

	return dv;
}

GLuint init_texture(const char* const path) {
	SDL_Surface* const image = SDL_LoadBMP(path);
	if (image == NULL) fail("open image file", OpenImageFile);
	SDL_LockSurface(image);

	GLuint texture;

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image -> w, image -> h, 0, GL_BGR, GL_UNSIGNED_BYTE, image -> pixels);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glGenerateMipmap(GL_TEXTURE_2D);

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);
	return texture;
}

void demo_3_drawer(const DemoVars dv) {
	/*
	GLuint foo = init_texture("assets/walls/mesa.bmp");
	deinit_texture(foo);
	*/

	demo_2_drawer(dv);
}

int main(void) {
	// load_texture("assets/walls/mesa.bmp");
	make_application(demo_3_drawer, demo_2_init, demo_1_deinit);
}

///// Lots of vertex testing:


	GLfloat texcoords[][2] = { {0.0,0.0},    {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0}
                             };

	GLubyte indices[24] = {0,1,2,3, 4,5,6,7, 3,2,5,4, 7,6,1,0,
                                  8,9,10,11, 12,13,14,15};

	/*
	for (int i = 0; i < 24; i++) {
		GLfloat* uv = texcoords[indices[i]];
		printf("%lff, %lff,\n", uv[0], uv[1]);
	}

	GLfloat uv_data[num_uv_floats] = {
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,

		0.0, 1.0,
	};
	*/

GLfloat uv_data[] = {
	0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
};



	/*
	#define TOP_LEFT 0.0f, 0.0f
	#define BOTTOM_LEFT 1.0f, 0.0f
	#define TOP_RIGHT 0.0f, 1.0f

	#define TRI_SET TOP_RIGHT, BOTTOM_LEFT, TOP_LEFT
	#define REV_TRI_SET TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT

	static const GLfloat uv_data[num_uv_floats] = {
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET
	};
	*/

	/*
	static const GLfloat uv_data[num_uv_floats] = {
		0.000059f, 1.0f-0.000004f,
		0.000103f, 1.0f-0.336048f,
		0.335973f, 1.0f-0.335903f,
		1.000023f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.336024f, 1.0f-0.671877f,
		0.667969f, 1.0f-0.671889f,
		1.000023f, 1.0f-0.000013f,
		0.668104f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.000059f, 1.0f-0.000004f,
		0.335973f, 1.0f-0.335903f,
		0.336098f, 1.0f-0.000071f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.336024f, 1.0f-0.671877f,
		1.000004f, 1.0f-0.671847f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.668104f, 1.0f-0.000013f,
		0.335973f, 1.0f-0.335903f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.668104f, 1.0f-0.000013f,
		0.336098f, 1.0f-0.000071f,
		0.000103f, 1.0f-0.336048f,
		0.000004f, 1.0f-0.671870f,
		0.336024f, 1.0f-0.671877f,
		0.000103f, 1.0f-0.336048f,
		0.336024f, 1.0f-0.671877f,
		0.335973f, 1.0f-0.335903f,
		0.667969f, 1.0f-0.671889f,
		1.000004f, 1.0f-0.671847f,
		0.667979f, 1.0f-0.335851f
	};
	*/

///// Even more tries:


	static const GLfloat uv_data[num_uv_floats] = {
		/* Sorta worked:
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f
		*/

		/* Flipped 90 degrees:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		*/


		/* Almost:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f
		*/

		/*
		0.0f, 0.0f,
		0.5f, 0.5f,
		1.0f, 1.0f
		*/

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
	};

///// A note on UV reversals:

	// rev
	#define FIRST_UV 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
	#define SECOND_UV 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f,

	// rev
	#define THIRD_UV 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
	#define FOURTH_UV 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,

	// fifth and sixth are reversed
	#define FIFTH_UV 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	#define SIXTH_UV 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,

	// 1 2 2 3 4 3 3 2 5 1 4 6

///// An indexing test

// Possibilities
#define P1 1.0f, 1.0f, 1.0f,
#define P2 -1.0f, -1.0f, -1.0f,

#define P3 -1.0f, 1.0f, 1.0f,
#define P4 1.0f, -1.0f, 1.0f,
#define P5 1.0f, 1.0f, -1.0f,

#define P6 -1.0f, -1.0f, 1.0f,
#define P7 1.0f, -1.0f, -1.0f,

#define P8 -1.0f, 1.0f, -1.0f

/*
	P2 P6 P3

	P5 P2 P8
*/

///// Stuff with automatic index generation:


	int index_buf_len = 0;
	int index_buffer[cube_num_points];

	for (int i = 0; i < cube_num_points; i += 3) {
		const float x = demo_3_vertex_data[i], y = demo_3_vertex_data[i + 1], z = demo_3_vertex_data[i + 2];

		byte found_match = 0;
		for (int j = 0; j < i; j += 3) {
			const float cx = demo_3_vertex_data[j], cy = demo_3_vertex_data[j + 1], cz = demo_3_vertex_data[j + 2];
			if (x == cx && y == cy && z == cz) {
				index_buffer[index_buf_len++] = j / 3;
				found_match = 1;
				break;
			}
		}

		if (!found_match) {
			printf("%lf, %lf, %lf\n", (double) x, (double) y, (double) z);
			index_buffer[index_buf_len] = index_buf_len;
			index_buf_len++;
		}
	}

	for (int i = 0; i < index_buf_len + 1; i++) {
		printf("%d%s", index_buffer[i], (i == index_buf_len - 1) ? "" : ", ");
	}
	putchar('\n');

///// And more of that:

#define A -1.000000, -1.000000, -1.000000
#define B -1.000000, -1.000000, 1.000000
#define C -1.000000, 1.000000, 1.000000
#define D 1.000000, 1.000000, -1.000000
#define E -1.000000, 1.000000, -1.000000
#define F 1.000000, -1.000000, 1.000000
#define G 1.000000, -1.000000, -1.000000
#define H 1.000000, 1.000000, 1.000000
/* 0, 1, 2, 3, 0,
5, 6, 0, 8, 3, 8,
0, 0, 2, 5, 6, 1, 0, 2, 1, 6, 21, 8, 3, 8, 21, 6, 21, 3, 5, 21, 5, 2, 21, 2, 6
*/

const GLfloat demo_3_vertex_data[cube_num_points] = {
	// A B C D A

///// Old vertex data:

	/*
	-1.0f, -1.0f, -1.0f, // triangle 1: begin
	-1.0f, -1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f, // triangle 1: end

	1.0f, 1.0f, -1.0f, // triangle 2: begin
	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f, // triangle 2: end

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,

	1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f
	*/

/////


		/*
		top_left_x, 0.0f, z,
		top_left_x + width, 0.0f, z,
		top_left_x, -height, z,

		top_left_x, -height, z,
		top_left_x + width, -height, z,
		top_left_x + width, 0.0f, z
		*/

		/*
		0.0f, 0.0f, z,
		width, 0.0f, z,
		0.0f, -height, z,

		0.0f, -height, z,
		width, -height, z,
		width, 0.0f, z
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,

		-s, -s, 0.0f,
		s, -s, 0.0f,
		s, s, 0.0f
		*/

/////

		/*
		top_left_x, top_left_y, z,
		top_left_x + width, top_left_y, z,
		top_left_x, top_left_y - height, z,

		top_left_x, top_left_y - height, z,
		top_left_x + width, top_left_y - height, z,
		top_left_x + width, top_left_y, z
		*/
	
/////

	(void) top_left_corner;
	// const float half_width = width / 2.0f, half_height = height / 2.0f;

	/*
	1____0
	|  . |
	2____|


	0___1
	|   /
	|  /
	| /
	2/
	*/

	/*
	Top left corner at {0, 0}
	*/

/////

		/*
		0.0f, 0.0f, far,
		1.0f, 0.0f, far,
		0.0f, 0.0f, near
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,
		*/

		/*
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		0.0f, 1.0f, 0.0f
		*/

		/*
		0.0f, height, far,
		0.0f, height, near,
		1.0f, height, far
		*/

/////

	/*
	GLfloat
		*const plane_vertices = create_vert_plane(top_left_corner, size_hori, size_vert),
		*const uv_data = create_uv_for_plane(size_hori, size_vert);

	sgl.num_vertex_buffers = 2;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers,
		plane_vertices, plane_vertex_bytes,
		uv_data, plane_uv_bytes);

	free(plane_vertices);
	free(uv_data);
	*/

/////

Functions to make:
- void create_cuboid(const vec3 origin, const vec3 size);
actually, instead of create_cuboid, make a make_planes fn (since sector meshes will not exactly be rectangles)
- GLfloat* join_plane_vertices(const GLfloat* const plane_1, const GLfloat* const plane_2);

/////

void draw_triangles(const int num_triangles) {
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // num_triangles * 3
	// glDrawArraysInstanced(GL_TRIANGLES, 0, num_triangles * 3, 1);
	// glDrawElements(GL_TRIANGLES, num_triangles * 3, GL_UNSIGNED_INT, NULL);
	// GL_ERR_CHECK;
}

/////

	/////
	glGenBuffers(sgl.num_vertex_buffers, &sgl.vertex_buffers);
	glBindBuffer(GL_ARRAY_BUFFER, sgl.vertex_buffers);
	glBufferData(GL_ARRAY_BUFFER, interleaved_plane_bytes, plane_data, GL_STATIC_DRAW);
	/////

/////

	/*
	.A B C
	C B D
	C D D - deg
	D D E - deg
	D E E - deg
	E E F - deg
	E F G
	G F H

	in as {A, B, C, D,
		D, E,
		E, F, G, H} to gpu

	plane_1 = {A, B, C, D}, plane_2 = {E, F, G, H};

	B--D    F--H
	|\ |    |\ |
	| \|    | \|
	A--C    E--G

	Whoops, theirs were like that
	Retrying
	*/

	/*
	New order:
	0 1 2
	1 2 3

	2 3 4
	3 4 5

	3 4 5
	4 5 6
	*/

/////

/*
Only join if next to each other:


0__1
|  /
| /
2/

    2
   /|
  / |
1/__3

2__4
|  /
| /
3/
*/

///// A programmatic plane creator (didn't work, but only discarding b/c hard to maintain):

	void (*const plane_creators[3])(PLANE_CREATOR_SIGNATURE) = {
		PLANE_CREATOR_NAME(vert_2), PLANE_CREATOR_NAME(hori), PLANE_CREATOR_NAME(vert_1)
	};

	int i = 0;
	for (byte varied_axis = 0; varied_axis < 3; varied_axis++) {
		const byte size_axis_x = (varied_axis == 0) * 2, size_axis_y = (varied_axis == 1) + 1;
		void (*const plane_creator)(PLANE_CREATOR_SIGNATURE) = plane_creators[varied_axis];

		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		i++;
		origin[varied_axis] += size[varied_axis];
		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		origin[varied_axis] -= size[varied_axis];
		i++;
	}

///// Old hori plane creation:

	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 2);
	origin[1] -= size[1];
	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 3);
	origin[1] += size[1];

/////

		/*
		0____1
		\   |
		 \  |
           2

		tri is

		0_1
		| /
		2/

		from other side

		b4: {0.0f, 0.0f}, {size_z, 0.0f}, {0.0f, size_y}
		after: {size_z, 0.0f}, {0.0f, 0.0f}, {0.0f, size_y}
		no
		*/

		/* orig flipped:
		far_x, top_y, near_z, 0.0f, 0.0f,
		far_x, top_y, far_z, size_z, 0.0f,
		far_x, bottom_y, near_z, 0.0f, size_y,
		*/

///// Vertices ordered by triangle pairs:

	const plane_type_t vertices[vars_per_mesh] = {
		// Top triangles aligned along Z axis (each pair in opposite winding order from each other)
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		// gotten

		far_x, top_y, near_z, size_z, 0,
		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, near_z, size_z, size_y,

		// Bottom triangles aligned along Z axis
		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0,
		// gotten

		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, near_z, size_z, size_y,

		// Top triangles aligned along X axis
		near_x, top_y, near_z, size_x, 0,
		far_x, top_y, near_z, 0, 0,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, top_y, far_z, size_x, 0,
		near_x, top_y, far_z, 0, 0,

		// Bottom triangles aligned along X axis
		far_x, top_y, near_z, 0, 0,
		far_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, far_z, size_x, size_y,
		far_x, top_y, far_z, size_x, 0,

		// Top triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, near_z, 0, 0,
		near_x, top_y, near_z, 0, size_x,

		// Bottom triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, far_z, size_z, 0,
		far_x, top_y, near_z, 0, 0

		// No matching degenerate bottom triangle under block here since not needed for sake of culling
	};

/////

void attempt_sector_fill_at(byte* const heightmap, const byte map_width,
	const byte map_height, const byte x, const byte y) {

	(void) heightmap;
	(void) map_width;
	(void) map_height;
	(void) x;
	(void) y;

	const byte height = *map_point(heightmap, x, y, map_width);
	// If the point is a potential corner
	const int top_left_corner_vals[3][2] = {
		{x - 1, y}, {x - 1, y - 1}, {x, y - 1}
	};

	byte corner_heights_not_eq_sum = 0;
	for (byte i = 0; i < 3; i++) {
		const int* const top_left_corner = top_left_corner_vals[i];
		const int x = top_left_corner[0], y = top_left_corner[1];

		if (x < 0 || x >= map_width || y < 0 || y >= map_height || *map_point(heightmap, x, y, map_width) != height)
		corner_heights_not_eq_sum++;
	}

	/*
	byte* const height_ref = map_point(heightmap, x, y, map_width);
	const byte height = *height_ref;
	if (height > 0) {
		SectorArea area = {.height = height};
	}
	*/
}

/////

	if (x < 0 || y < 0 || x >= map_width || y >= map_height) return;

/////

	// Not correct at the moment

	// Attempting expansions

	/*
	while (bottom_right[1] < map_height) {
		while (bottom_right[0] < map_width) {
			if (area_is_valid(&area, map, map_width)) bottom_right[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) bottom_right[1]++;
	}

	for (byte y = area.origin[1]; y < bottom_right[1]; y++) {
		for (byte x = area.origin[0]; x < bottom_right[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	area.size[0] = bottom_right[0] - area.origin[0];
	area.size[1] = bottom_right[1] - area.origin[1];
	return area;
	*/

/////

// byte bottom_right[2] = {area.origin[0] + area.size[0], area.origin[1] + area.size[1]}; // Stored as {x, y}

///// Old sector code:

byte area_is_valid(const SectorArea* const area, byte* const map, const byte map_width) {
	const byte start_x = area -> origin[0], start_y = area -> origin[1];
	const byte end_x = start_x + area -> size[0], end_y = area -> size[1];

	for (byte y = start_y; y < end_y; y++) {
		for (byte x = start_x; x < end_x; x++) {
			if (*map_point(map, x, y, map_width) != area -> height) return 0;
		}
	}
	return 1;
}

// Corner is top left
SectorArea attempt_area_fill(SectorArea area, byte* const map, const byte map_width, const byte map_height) {
	// Not working correctly yet
	for (byte y = area.origin[1]; y < map_height; y++) {
		for (byte x = area.origin[0]; x < map_width; x++) {
			if (area_is_valid(&area, map, map_width)) area.size[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) area.size[1]++;
		else break;
	}

	for (byte y = area.origin[1]; y < area.origin[1] + area.size[1]; y++) {
		for (byte x = area.origin[0]; x < area.origin[0] + area.size[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	return area;
}

///// Some 6-vertex vertices for a flat vert tomato:

	const plane_type_t triangle_vertices[30] = {
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
	};

///// Stuff:

	const plane_type_t origin[3] = {0, 2, 0}, size[3] = {2, 1, 4};
	const plane_type_t near_x = origin[0], top_y = origin[1], near_z = origin[2], size_x = size[0], size_y = size[1], size_z = size[2];
	const plane_type_t far_x = near_x + size_x, bottom_y = top_y - size_y, far_z = near_z + size_z;

	// const plane_type_t width = 3, height = 2;
	// const plane_type_t width = size_y, height = size[0];
	// const plane_type_t width = size_z, height = size_y;

	const plane_type_t triangle_vertices[] = {
		

		/*
		near_x, top_y, near_z, 0, 0,
		far_x, top_y, near_z, 0, size_x,
		near_x, bottom_y, near_z, size_y, 0
		*/

		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		near_x, bottom_y, far_z, size_z, size_y
		*/

		/*
		near_x, top_y, far_z, 0.0f, 0.0f,
		near_x, top_y, near_z, width, 0.0f,

		near_x, bottom_y, far_z, 0.0f, height,
		near_x, bottom_y, near_z, width, height
		*/


		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
		*/
	};

////// The old vertices for the billboard:

	const billboard_type_t top_left_corner[3] = {2, 3, 1}, size[3] = {1, 2, 1};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[20] = {
		near_x, top_y, near_z, 0, 0,
		near_x, top_y, far_z, size_z, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y
	};

/////

	/*
	const billboard_type_t top_left_corner[3] = {0.5, 0.5, 0.0}, size[3] = {0.5, 0.5, 0.5};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[] = {
		near_x, top_y, near_z,
		near_x, top_y, far_z,

		near_x, bottom_y, near_z,
		near_x, bottom_y, far_z
	};

	for (int i = 0; i < 12; i++) {
		printf("%f ", (double) vertices[i]);
		if (i == 2 || i == 5 || i == 8 || i == 11) printf("\n");
	}
	*/

/////

	#define PRINT_MAT(m)\
		for (int y = 0; y < 4; y++) {\
			for (int x = 0; x < 4; x++)\
				printf("%lf ", (double) m[y][x]);\
			putchar('\n');\
		} putchar('\n');

/////

/*
- Billboards
- Next step: set uniform vars
- http://www.opengl-tutorial.org/intermediate-tutorials/billboards-particles/billboards/#solution-3--the-fixed-size-3d-way
- https://github.com/opengl-tutorials/ogl/tree/master/tutorial18_billboards_and_particles
*/

/*
- Have 4 corners of sprite
- Can get right vec and up vec in shader

E = player vector
P = billboard vector
F = player-billboard-delta vector = P - E
R = right vector = global up vector crossed with F
U = up vector = F crossed with R

Top right corner = U + R
Top left corner = U - R
Bottom left corner = -U - R
Bottom right corner = R - U
*/

/////

		center[0] - half_size[0], center[1] - half_size[1],
		center[0] + half_size[0], center[1] - half_size[1],

		center[0] - half_size[0], center[1] + half_size[1],
		center[0] + half_size[0], center[1] + half_size[1]
		/*

///// Some manual frustum stuff:

	/*
	glm_vec3s_add((vec3) {1, 0, 0}, b, c);
	glm_vec3s_add(c, glms_vec3_cross(a, b, c), c);
	*/

	/*
	near.normal = pos + dir * near_clip
	far.normal = pos + dir * far_clip
	(left, right, top, bottom).normal = pos
	near.dist = 
	*/

	/*
	const GLfloat
		*const pos = camera -> pos, *const dir = camera -> dir,
		near_clip = camera -> clip_dists.near, far_clip = camera -> clip_dists.far;

	const GLfloat
		dir_times_far_clip[3] = {dir[0] * far_clip, dir[1] * far_clip, dir[2] * far_clip},
		half_far_clip_rect_height = far_clip * tanf(camera -> vert_fov * 0.5f);

	const GLfloat half_far_clip_rect_width = half_far_clip_rect_height * camera -> aspect_ratio;


	Frustum frustum = {
		.near = {{pos[0] + dir[0] * near_clip, pos[1] + dir[1] * near_clip, pos[2] + dir[2] * near_clip}, -1.0f},
		.far = {{pos[0] + dir_times_far_clip[0], pos[1] + dir_times_far_clip[1], pos[2] + dir_times_far_clip[2]}, -1.0f},

		.left = {{pos[0], pos[1], pos[2]}, -1.0f},
	};

/////

typedef struct {
	const GLfloat normal[3], dist; // Dist from origin to nearest point on plane
} Plane;

typedef struct {
	// const Plane near, far, left, right, top, bottom;

} Frustum;

///// An attempt at something branchless for movement:

	// const GLfloat* move_dir, speed;
	// const GLfloat* move_dirs[2] = {dir, camera -> right}, speeds[2] = {actual_speed, -actual_speed};


	const GLfloat* const move_dir =
		(keys[constants.movement_keys.forward] || keys[constants.movement_keys.backward]) ? dir : camera -> right,

	speed = (keys[constants.movement_keys.])


	// const GLfloat* const move_dir = ((GLfloat*[2]) {dir, camera -> right})[0];


	/*
	if (keys[constants.movement_keys.forward]) {
		move_dir =
	}

/////

	/* The vertex shader needs a dummy input here - the vertex ID
	could be gotten through gl_VertexID, but this only ranges from 0 to 3,
	which fits within the domain needed to access vertices_model_space */
	"layout(location = 0) in int vertex_id;"

/////

		/* Swizzle arrangements:
		flat: xz for demo 14, but actually something else not found
		vert 1:
		vert 2:

		tried: yz, xy, zy, yz */

/////

const char* const demo_15_vertex_shader =
    "#version 330 core\n"

    "layout(location = 0) in vec3 vertex_pos_model_space;\n"
    "out vec3 UV_3D;\n"
    "uniform mat4 M, MVP;\n" // model, model-view-projection

    "void main() {\n"
        "vec4 pos = MVP * vec4(vertex_pos_model_space, 1.0);\n"
        "gl_Position = pos.xyww;\n"

        // Perhaps just vertex_pos_model_space
        "UV_3D = vec3(model * vec4(vertex_pos_model_space, 1.0));\n"
    "}\n",

*const demo_15_fragment_shader =
    "#version 330 core\n"

    "in vec3 UV_3D;\n"
    "out vec4 color;\n"
    "uniform samplerCube skybox;\n"

    "void main() {\n"
        "color = texture(skybox, UV_3D);\n"
    "}\n";

/////

	/*
	for (int y = 0; y < 4; y++) {
		for (int x = 0; x < 4; x++) {
			printf("%lf ", (double) camera.view_projection[y][x]);
		}
		puts("|");
	}
	puts("---");

/////

// Skybox is a cubemap
GLuint init_skybox_texture(const char* const path) {
	// Start with same 6 faces

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};
	*/

	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	SDL_Surface* const surface = init_surface(path);
	const void* const pixels = surface -> pixels;
	const GLint surface_size[2] = {64, 64}; // surface -> w, surface -> h};
	GL_ERR_CHECK;

	// right, left, top, bottom, back, front

	const GLsizei cube_size = surface_size[0] >> 2;

	/*
	const GLint origin_1[2] = {0, cube_size};

	glTexImage2D(GL_TEXTURE_CUBE_MAP,
		0, OPENGL_INTERNAL_PIXEL_FORMAT, surface_size[0],
		surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
		OPENGL_COLOR_CHANNEL_TYPE, pixels);
	*/
	
	for (byte i = 0; i < 6; i++) { // "../../../assets/walls/hieroglyph.bmp"
		/*
		glTexSubImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, origin_1[0], origin_1[1], cube_size, cube_size,

			OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, pixels
		);
		*/

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface_size[0], surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);
		
		GL_ERR_CHECK;
	}
	deinit_surface(surface);

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
}

/////

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};

	(void) path;
	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	for (byte i = 0; i < 6; i++) {
		SDL_Surface* const surface = init_surface(paths[i]);

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface -> w, surface -> h, 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);

		deinit_surface(surface);
	}

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
	*/

/////

			/*
			memset(face_pixels + y * pitch, 0xF0F8FF / (y + 1), row_bytes); // works
			memset(face_pixels + y * pitch, 0xF0F8FF, row_bytes); // works
			*/

			/*
			const void* dest = face_pixels + y * row_bytes;

			int src_start = y + cube_size;
			const void* src = skybox_pixels + src_start * row_bytes;

			memcpy(dest, src, row_bytes);
			*/

/////

		for (int y = 0; y < cube_size; y++) {
			// pitch = width * 4
			const int pitch = cube_size * 4;

			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(skybox_pixels, pitch, y);		

			memcpy(dest + 1, src, row_bytes);

			/*
			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(face_pixels, pitch, y + cube_size);
			*/

			/*
			void* const ndest = face_pixels + y * pitch, *nsrc = skybox_pixels + (y) * pitch;
			memcpy(ndest, nsrc, row_bytes);
			*/
		}

/////

/* right = GL_TEXTURE_CUBE_MAP_POSITIVE_X
left = GL_TEXTURE_CUBE_MAP_NEGATIVE_X

top = GL_TEXTURE_CUBE_MAP_POSITIVE_Y
bottom = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y

back = GL_TEXTURE_CUBE_MAP_POSITIVE_Z
front = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z */

/////

// This demo asserts that batching + culling work

#include "demo_11.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

StateGL demo_17_init(void) {
	StateGL sgl = {.vertex_array = init_vao()};



	/*
	const plane_type_t origin[3] = {1, 2, 2}, size[3] = {1, 2, 3};
	plane_type_t* const cuboid_mesh = create_sector_mesh(origin, size);

	sgl.num_vertex_buffers = 1;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers, cuboid_mesh, bytes_per_mesh);
	bind_interleaved_planes_to_vao();

	free(cuboid_mesh);

	sgl.shader_program = init_shader_program(demo_4_vertex_shader, demo_4_fragment_shader);
	sgl.num_textures = 1;
	sgl.textures = init_textures(sgl.num_textures, "../../../assets/walls/pyramid_bricks_3.bmp", tex_repeating);
	select_texture_for_use(sgl.textures[0], sgl.shader_program);

	enable_all_culling();
	*/

	return sgl;
}

void demo_17_drawer(const StateGL* const sgl) {
	(void) sgl;
	static Camera camera;
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	/*
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		model_view_projection_id = glGetUniformLocation(sgl -> shader_program, "model_view_projection");
		first_call = 0;
	}
	update_camera(&camera);
	glUniformMatrix4fv(model_view_projection_id, 1, GL_FALSE, &camera.model_view_projection[0][0]);

	glClearColor(0.2f, 0.4f, 0.6f, 0.0f);
	draw_triangles(triangles_per_mesh);
	*/
}

#ifdef DEMO_17
int main(void) {
	make_application(demo_17_drawer, demo_17_init, deinit_demo_vars);
}
#endif

/////

#include "../utils.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

/*
typedef struct {
	GLsizei num_textures;
	GLuint vao, *const textures, shader;
	Batch batch;
} StateDemo17;

void demo_17_drawer(const StateDemo17* const s) {
	static byte first_call = 1;
	static Camera camera;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		first_call = 0;
	}

	glClearColor(0.8f, 0.8f, 0.5f, 0.0f);

	(void) s;
}

StateDemo17 init_state_demo_17(void) {
	StateDemo17 s;

	glGenVertexArrays(1, &s.vao);
	glBindVertexArray(s.vao);

	return s;
}

void deinit_state_demo_17(const StateDemo17* const s) {
	glDeleteTextures(s -> num_textures, rs -> textures);
	deinit_batch(&s -> batch);
	glDeleteVertexArrays(1, &s -> vao);
}

// #ifdef DEMO_17
int main(void) {
	Screen screen = init_screen("Culling Demo");

	const int max_delay = 1000 / constants.fps;
	(void) max_delay;

	SDL_Event event;
	keys = SDL_GetKeyboardState(NULL);
	byte running = 1;

	StateDemo17 s = init_state_demo_17();

	while (running) {
		const Uint32 before = SDL_GetTicks();

		while (SDL_PollEvent(&event)) {
			if (event.type == SDL_QUIT) running = 0;
		}

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		demo_17_drawer(&s);
		SDL_GL_SwapWindow(screen.window);
		const int wait = max_delay - (SDL_GetTicks() - before);
		if (wait > 0) SDL_Delay(wait);
	}

	deinit_state_demo_17(&s);
	deinit_screen(&screen);
}
// #endif
*/

/////

	/*
	sgl.num_vertex_buffers = sectors.length;
	sgl.vertex_buffers = malloc(sgl.num_vertex_buffers * sizeof(GLuint));
	glGenBuffers(sgl.num_vertex_buffers, sgl.vertex_buffers);
	*/

	/*
	sgl.num_vertex_buffers = 0;

	for (int i = 0; i < sector_list.length; i++) {
		Sector* const sector = sector_list.sectors + i;

		// glGenBuffers(1, &sector -> vbo);
		// sector -> vbo = sgl.vertex_buffers[i];
		const plane_type_t origin[3] = {area.origin[0], area.height, area.origin[1]};

		plane_type_t* mesh;
		byte mesh_bytes;

		if (area.height == 0) { // Flat sector
			mesh = create_height_zero_mesh(origin, area.size);
			mesh_bytes = bytes_per_height_zero_mesh;
		}
		else {
			const plane_type_t size[3] = {area.size[0], area.height, area.size[1]};
			mesh = create_sector_mesh(origin, size);
			mesh_bytes = bytes_per_mesh;
		}

		glBindBuffer(GL_ARRAY_BUFFER, sector -> vbo);
		glBufferData(GL_ARRAY_BUFFER, mesh_bytes, mesh, GL_STATIC_DRAW);

		// free(mesh);
	}
	*/

/////

// printf("%d, %d, %d\n", (intO 0.89f / 1 * 255, 0.854f / 1 * 255, 0.788f / 1 * 255);

/////
		/*
		"float depth = gl_FragCoord.z / gl_FragCoord.w;\n"
		"float l = 1.0f / gl_ClipDistance;\n"
		"light_intensity;\n"
		*/

/////

		/*
		if (height_diff != 0) {
			Face face;

			if (height_diff > 0) {
				printf("Sector is over other sector by %d\n", height_diff);
			}
			else if (height_diff < 0) {
				printf("Sector is under other sector by %d; no face column\n", -height_diff);
			}
		}
		last_height_diff = height_diff;
		*/

/////

/*
void generic_init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width,
	const byte map_height, const byte is_bottom_side) {

	const byte start_x = sector.origin[0];
	byte start_y = sector.origin[1];

	if (is_bottom_side) {
		start_y += sector.size[1] - 1;

		DEBUG(sector.origin[1], d);
		DEBUG(sector.size[1], d);
		DEBUG(start_y, d);
		if (start_y == map_height - 1) return;
	}
	else if (start_y == 0) return;

	//////////

	const byte adjacent_y = start_y + (is_bottom_side ? 1 : -1);
	byte face_skippable = 0;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {start_x, start_y}, {1, 0}};

	for (byte x = start_x; x < start_x + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, adjacent_y, map_width);
		const int16_t height_diff = sector.height - height;

		const byte not_skippable_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (not_skippable_before && face_skippable) {
			puts("Continuity error");
		}

		if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) {
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1;
				}
				curr_face.size[1] = height_diff;
			}
		}
		last_height_diff = height_diff;
	}
	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

// Assumes that the faces are vertical
/*
void init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width) {
	// == edge
	if (sector.origin[1] == 0) return;

	// Side decr
	const byte y_above = sector.origin[1] - 1;

	byte face_skippable = 1;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {sector.origin[0], sector.origin[1]}, {1, 0}};

	for (byte x = sector.origin[0]; x < sector.origin[0] + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, y_above, map_width);
		const int16_t height_diff = sector.height - height;

		const byte had_face_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (face_skippable && had_face_before) {
			puts("Catch it");
			print_face(curr_face, "Face: ");
			curr_face.origin[0] = x;
			curr_face.size[0] = 1; // top-down x
		}

		else if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) { // Add face to list here
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1; // top-down x
				}
				curr_face.size[1] = height_diff; // top-down y
			}
		}
		last_height_diff = height_diff;
	}

	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

/////

	/*
	if (!is_top) next_face.origin[1] += sector.size[1];

	byte adjacent_y = next_face.origin[1];

	DEBUG(is_top, d);

	if (is_top && adjacent_y-- == 0) return;
	else if (adjacent_y == map_height) {
		// DEBUG(is_top, d);
		return;
	}
	*/

/////

/*
void create_flat_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ns_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ew_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}
*/

/////

				/*
				1, 2, 3, 4, 5,
				6, 7, 8, 9, 10,
				11, 12, 13, 14, 15,

				16, 17, 18, 19, 20,
				21, 22, 23, 24, 25,
				26, 27, 28, 29, 30
				*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_______
			|     |
			|     |
			|_____|

			origin size[0] top down, and size[1] depth
			*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_____
			|   |
			|___|
			*/


			/*
			Note: x across top-down is also x across in 3D
			origin
			|

			For vert ns,
				origin[0] = x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y,
				origin[1] = near_z (which is top z),
				origin[1] - size[0] = far_z
			*/

			/*
			origin -

			For vert ew,
				origin[0] = near_x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y
				origin[1] = near_x (which is left x),
				origin[1] - size[0] = far_x (which is right_x)
			*/

///// Some UV stuff:

			/*
				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, near_z, 0, 1,
				near_x, sector_height, near_z, 1, 1,

				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, far_z, 0, 0,
				far_x, sector_height, near_z, 0, 1
				*/

				/*
				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, near_z, 0, 0,
				near_x, sector_height, near_z, 0, size_x,

				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, far_z, size_z, 0,
				far_x, sector_height, near_z, 0, 0
				*/

/////

	/*
	Visible face sides:

	Bottom = invisible
	Top = visible
	Right = invisible
	Left = visible

	Find alternate face orientations, and switch between, or programatically swizzle vars in it

	With normal vert NS: bottom = invisible, and top UV is correct.
	With alternative vert NS: bottom = visible + correct UVs, and top is invisible.
	*/

///// Heightmap modification based on perlin noise from the main project:

	for (int y = 0; y < terrain_height - 1; y++) {
		printf("\t{");
		for (int x = 0; x < terrain_width - 1; x++) {

			byte* val = map_point((byte*) terrain_map, x, y, terrain_width);
			int smaller = *val - 40;
			if (smaller < 0) smaller = 0;

			int v = fabs(tan(*val / 16.0) / 3.0) * *val;
			if (v > 255) v = 255;
			*val = v;

			printf("%d%s", *val, (x == terrain_width - 2) ? "" : ", ");
		}
		puts("},");
	}

/////

	/*
	const GLsizeiptr total_index_bytes = num_faces * indices_per_face * sizeof(index_type_t);
	GLuint* const cpu_index_buffer = malloc(total_index_bytes);
	for (size_t i = 0; i < num_faces; i++) {
		const int s = i * 4;

		const GLuint index_set_1[6] =
			// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
			{s, s + 1, s + 2, s, s + 3, s + 1};

		for (int j = 0; j < 6; j++) printf("%d ", index_set_1[j]);
		putchar('\n');
	
		memcpy(cpu_index_buffer + i * 6, index_set_1, sizeof(index_set_1));
	}

	glGenBuffers(1, &sector_list -> ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sector_list -> ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, total_index_bytes, cpu_index_buffer, GL_STATIC_DRAW);

	free(cpu_index_buffer);
	*/

	/*
	const GLuint num_indices = 6 * face_mesh_list.length;
	// DEBUG(face_mesh_list.length, d);
	for (int i = 0; i < 3; i++) {
		GLuint index_set_1[6] = {i, i + 1, i + 2, i, i + 3, i + 1};

		for (int i = 0; i < 6; i++) {
			printf("%d ", index_set_1[i]);
		}
		putchar('\n');
	}
	*/

/////

	/*
	for (int i = 0; i < 6; i++) printf("%d, ", index_set[i]);
	putchar('\n');
	*/

	/*
	TODO: add to index list here

	const GLuint index_set_1[6] =
		// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
		{s, s + 1, s + 2, s, s + 3, s + 1};

	flat || vert ns first || vert ew second -> 0, 1, 2, 0, 3, 1
	vert ns second || vert ew first -> 0, 1, 2, 1, 3, 2

	- If second variant, add 1 to entry[3] and entry[5]
	- How to find start of ibo indices here?
	*/

/////

	/*
	ibo entries:
		flat:
			0, 1, 2, 0, 3, 1
		vert ns, first side:
			0, 1, 2, 0, 3, 1
		vert ns, second side:
			0, 1, 2, 1, 3, 2
		vert ew, first side:
			0, 1, 2, 1, 3, 2
		vert ew, second side:
			0, 1, 2, 0, 3, 1
	*/

/////


	/*
	DEBUG(total_index_bytes, zu);
	DEBUG(index_list -> length, zu);
	DEBUG(index_list -> length * sizeof(index_type_t[indices_per_face]), zu);
	DEBUG(index_list -> max_alloc * index_list -> item_size, zu);

	puts("Looking in index list");

	index_type_t* data = index_list -> data;
	const GLsizeiptr num_elems = index_list -> length * indices_per_face;
	for (GLsizeiptr i = 0; i < num_elems; i++) {
		printf("i = %td, and other = %d\n", i, data[i]);
	}
	// exit(0);
	*/

///// An attempt at chunk copying of unculled sectors:

	/*
	size_t sector_index = 0, base_index = 0;

	while (sector_index < sectors.length) {
		const Sector* sector = ((Sector*) sectors.data) + sector_index;

		index_type_t start_ibo_index = sector -> ibo_range.start, range_ibo_index = 0;

		while (sector_index < sectors.length && sector_in_view_frustum(*sector, frustum_planes)) {
			range_ibo_index += sector -> ibo_range.length;
			base_index += sector -> ibo_range.length;

			sector_index++;
			sector++;
		}

		printf("%d -> %d\n", start_ibo_index, range_ibo_index);
		DEBUG(base_index, d);

		if (range_ibo_index != 0) {
			memcpy(ibo_ptr + base_index, indices + start_ibo_index,
				range_ibo_index * sizeof(index_type_t));
		}
		else sector_index++;
	}
	*/

///// Non-chunked copying:

		/*
		const Sector sector = ((Sector*) sectors.data)[i];
		if (sector_in_view_frustum(sector, frustum_planes)) {
			// printf("see from %d -> %d\n", sector.ibo_range.start, sector.ibo_range.length);
			secs++;

			memcpy(ibo_ptr + num_visible_indices, indices + sector.ibo_range.start,
				sector.ibo_range.length * sizeof(index_type_t));

			num_visible_indices += sector.ibo_range.length;
		}
		*/

///// Ptr increment copying - a bit too messy:

	const Sector* sector = (Sector*) sectors.data;
	const Sector* const final_sector = sector + sectors.length - 1;

	while (sector != final_sector) {
		index_type_t num_indices = 0;
		const index_type_t start_index_index = sector -> ibo_range.start;

		/*
		while (sector != final_sector && sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector++ -> ibo_range.length;
		}
		*/

		while (sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector -> ibo_range.length;
			if (++sector == final_sector) goto bob;
		}


		if (num_indices != 0) {
			memcpy(ibo_ptr + num_visible_indices, indices + start_index_index, num_indices * sizeof(index_type_t));
			num_visible_indices += num_indices;
		}

///// UV shit:

		// "if (face_info_bits == 5u) UV = vec2(0.0f);\n"
		// 4u -> nothing
		// 3u -> nothing
		// 2u -> bottom
		// 6u -> top
		// 1u -> right
		// 5u -> left
		// 0u -> flat

		/* no 5u:
		left rev, right good, top good, bottom rev
		5u:
		left good, right good, top good, bottom rev
		6u:
		// left rev, right _, top _, bottom _
		*/

		"if (face_info_bits == 5u || face_info_bits == 2u) {UV.x = 1.0f - UV.x;}\n"

		// top good, bottom bad, right good, left bad - with no side logic
		// `side` indicates top or left. current bad UVs: bottom and left.
		// num for left: Vert_EW and side = 0b110 = 6. num for bottom: Vert_NS and !side = 0b001 = 1.
		// Vert_NS == 1, and Vert_EW == 2.

		// "bool side = bool(face_info_bits & 4u);\n" // side = left or top

		// "if (side && ) UV = vec2(0.0f);\n"

		// "if (side || (!side && face_type == )) {\n"
			// "UV.x = 1.0f - UV.x;\n"
			// "UV = vec2(0, 0);\n"
		// "}\n"

		// "UV = rev_pos.xz;\n" // Bueno for flat face ([0], [2])
		// "UV = rev_pos.zy;\n" // Bueno for right vert NS face ([2], [1])
		// "UV = vec2(1.0f - rev_pos.z, rev_pos.y);\n"// Bueno for left vert NS face (1 - [2], [1])
		// "UV = rev_pos.xy;\n" // Bueno for top vert EW face ([0] [1])
		// "UV = vec2(1.0f - pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])

		// "UV = vec2(pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])
		// "UV.x = 1.0f - UV.x;\n"

/////

- Sectors contain their meshes
- To begin with, don't clip sector heights based on adjacent heights
- Sectors are rectangular

- Not perfect, but sectors + their meshes for clipping and rendering, and texmaps + heightmaps for game logic
- Ideal: BSPs, but not worth time
- To start, one vbo + texture ptr per sector

/////

	/*
	if (sector.height == 4)

	printf("bottom_left = {%d, %d, %d}, top_right = {%d, %d, %d}\n",
		(int) aabb_corners[0][0],
		(int) aabb_corners[0][1],
		(int) aabb_corners[0][2],
		(int) aabb_corners[1][0],
		(int) aabb_corners[1][1],
		(int) aabb_corners[1][2]
	);
	*/

/////