Some TODOs for a recent next time:
- NEXT: final touches on the fortress map
- NEXT 2: a sector BVH, through metasector trees, also called binary r-trees (alloc through node pool)
- NEXT 3: entities that don't turn to face the player (just static ones); defined by center, size, and normal
- NEXT 4: up-and-down moving platforms that can also work as doors (continually up-and-down moving, down if player close, or down if action fulfilled)
- NEXT 6: deprecate most of StateGL's members and rely solely on vertex_array and any_data
- NEXT 7: a castle level that's crazy high in the sky, where you can look down really far; and a mountain level, like Mount Fuji - running along the mountainside
- NEXT 8: a level based on the Zhangjiajie region

Final lighting model:
- Ambient overall light, diffuse, specular - done
- A shadow map also based on a sun light source - done
- Not-too-strong, penumbra-heavy shadows
	(just for sectors, and only recompute for dynamic sectors when they're in view or moving)
- Ambient occlusion through an occlusion map
- For a sun bounding box, imagine a rotated OBB encompassing an AABB that represents the world (make a demo out of that):
	- First, make an encompassing OBB around a 2D AABB box
	- The box doesn't need to encompass the AABB at first, it just needs to be rotated
	- It can then be resized to the AABB area after
	- Then, expand that to 3D
	- Manage shadow map resolution better for bigger scenes via cascaded shadow maps: https://learnopengl.com/Guest-Articles/2021/CSM
	- A compressed texture for the shadow map, to save space?
	- EVSM with only the positive term may be possible: https://mynameismjp.wordpress.com/2013/09/10/shadow-maps/
	- And optimized copying: face mesh in a VBO, and then selectively copy to a second VBO for culling. First VBO then used for dry rendering for shadow map.
	- EVSM causes some odd light issues where connected voxel sides are partially in shadow, like ambient occlusion
	- Having specular takes away from shadows that come from voxel edges

Other random ideas:
- A map maker; An init json file that specifies textures and dimensions;
	draw/erase modes, line mode, export, and choose heights and textures.
	Or simpler than that, and just height + texture mode, and import/export just the map part of a JSON file.
	Will still have to read textures from the JSON file, and parse out the map. Perhaps use a full JSON parser for that.
- More efficiently set statemap bit ranges, maybe
- Camera var names to yaw, pitch, and roll (maybe)
- Billboard lighting that matches the sector lighting (share uniforms via a uniform buffer object)
- Can't use red cross for health since it's copyrighted
- Premultiplied billboard alphas: http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/ (or perhaps not, since alpha just 0 or 1)
- Can store one more byte in a sector with it staying 16 bytes - maybe do something more with that?
- Catch more warnings with -Weverything
- Macros for common initialization and deinitalization of OpenGL objects (like gl_init, gl_use, and gl_deinit)
- File paths may not work on Windows
- Pass in texture parameters through a bitmask
- Compile modules separarely, and then link them all together with a given demo
- Find a way to have low-res textures that are not blurry or have a loss of detail (nearest = shimmery, and linear = blurry; perhaps more antialiasing for nearest?)
- Use the bit macros more
- Call SDL_GetTicks or SDL_GetPerformanceCounter only once per frame
- Eventually, put the contents of VoxelPhysicsContext inside the camera
- Use fminf and fmaxf more
- Gauge the number of multisample samples based on a runtime constant
- Putting the face texture set at a resolution of 2048x2048 or above turns all of the billboards into this red-green gradient (above 4096x4096, out of OpenGL memory)
- Some color banding at the start of the fortress level for whatever reason. Fix with dithering: https://shader-tutorial.dev/advanced/color-banding-dithering/
- Remove all variadically defined functions and take lists or arrays instead
- One VAO per draw context as well - done as a VertexSpecification struct, or something like that
- A LevelDescription struct that then a SceneState (or some other) struct uses to generate sectors, a shadow map, etc.
	If levels come from C files, put those directly in files; otherwise, JSON will be turned into a LevelDescription.
	The advantage to C files is that you don't have to parse a file for each level; the disadvantage is that map files
	are then not easily editable.
- A demo with a high-res model loaded via assimp, and shadow map resolution management + softness through CSM and ESM (or a penumbra mask)
- A ON_FIRST_CALL macro
- Per each wall texture, define some material parameters like diffuse strength, specularity, and normal map settings
	(note: the normal map settings will only be useful at normal-map-generation time; the rest are useful in real-time rendering)
- Perhaps use the texture id map as a texture, and use the other 5 bits in the face info bitset for something else
- Perhaps read the average texture color (for specular) as if it were in a linear color space instead?

Normal mapping:
- Improper EVSM light coverage leads to some in-shadow areas having bumps on them (this may not make much of a difference)
- Unshadowed areas have no bumps (or is that okay?)
- Mipmaps of normal maps are not normalized, and they disappear at lower mip levels
- Perhaps blur the surfaces on the GPU - that way, only one blurrer between shadow maps and normal maps (only if using EVSM)
- Share some of the looping logic for the Gaussian blur and the normal map generation
- Maybe bake a specular amount into the alpha channel of each normal map

A better shading model:
- Share code between shaders
- Read in shaders from files
- Share shader uniforms via uniform buffer objects

Physics:
- Crouch
- Sliding across the floor (with the head tilted up)
- Animations go slower at 5 FPS (the frame delta leads to only increments of 1, where it should be something more there)
- Having an idle window with vsync on leads to high CPU and GPU usage
- The checker heightmap has faster pacing sometimes
- Pressing left + forward and backward doesn't stop moving on the X axis
- A half-stutter when pressing towards a wall and then letting go of a movement key
- Can get a tiny bit stuck in a wall when jumping downwards close to a wall (so will have to be able to stand a tiny bit off the wall)
- FPS at 120 -> too fast acceleration, which leads to weapon jitter
- If hitting a wall, base the player's speed on the dot product of your 2D direction vector
	and the wall's normal vector (perhaps find the wall vector from my movement delta). Axis where
	no moving happened indicates normal vector orientation. If below tile pos, bottom tile; otherwise, top tile.
	Same idea for side tiles.

Chromebook bugs:
- Memory leak with debug mode at the end of demos 17 and 22 (rest probably too), the lightmapper, the map editor, and the collision demo
- Other demos untested
- Outer project does not even want to start
- Demo test range doesn't work
- Sometimes, mouse control does not work when using the keyboard
- Framerate drop when using the big monitor + optimized + full screen

General future components:
- Blit 2D sprite to whole screen
- Use more of the cglm functions in `update_camera`, or make my own
- A startup setting of magnification filter

- In the end, 5 shaders + accel components: sectors, billboards, skybox, weapon, ui elements
